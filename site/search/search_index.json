{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"reference/","title":"Overview","text":"<p>PyPty is a phase retrieval code that can be applied to near-field or far-field imaging in TEM/STEM. It can be applied to do iterative ptychography, direct ptychography (Wigner distribution deconsvolution), differential phase contrast, tilt-corrected bright field, focal series reconstructions and LARBED reconstructions.</p> <p>The code is written by Anton Gladyshev (AG SEM, Physics Department, Humboldt-Universit\u00e4t zu Berlin). </p>"},{"location":"reference/#installation","title":"Installation","text":""},{"location":"reference/#setting-up-the-python-environment-and-installing-pypty","title":"Setting Up the Python Environment and Installing PyPty","text":"<p>To create a proper Python environment and install PyPty, you can use conda, mamba, or micromamba. With conda, use:</p>"},{"location":"reference/#gpu-installation","title":"GPU Installation","text":"<pre><code>git clone git@github.com:Anton-Gladyshev/pypty.git\ncd pypty\nconda env create -f pypty_gpu.yml\nconda activate pypty\npip install .[gpu]\n</code></pre>"},{"location":"reference/#cpu-installation","title":"CPU Installation","text":"<pre><code>git clone git@github.com:Anton-Gladyshev/pypty.git\ncd pypty\nconda env create -f pypty_cpu.yml\nconda activate pypty\npip install .\n</code></pre>"},{"location":"reference/#examples","title":"Examples","text":"<p>The examples will be provided in the <code>examples</code> folder. To to configure a completely custom preset, please reffer to the next section.</p>"},{"location":"reference/#relevant-literature","title":"Relevant Literature","text":"<p>If you have any questions after reading this guide, the following papers, books and links might explain the working principle of the code:</p>"},{"location":"reference/#multi-slice-formalism-and-the-nn-style-approach","title":"Multi-slice formalism and the NN-style approach","text":"<p>1) Earl J. Kirkland. Advanced Computing  in Electron Microscopy </p> <p>2) W. Van den Broek and C. Koch. General framework for quantitative three-dimensional reconstruction from arbitrary detection geometries in TEM </p> <p>3) W. Van den Broek and C. Koch. Method for Retrieval of the Three-Dimensional Object Potential by Inversion of Dynamical Electron Scattering </p>"},{"location":"reference/#error-metrics","title":"Error metrics:","text":""},{"location":"reference/#lsq","title":"LSQ:","text":"<p>4) M. Schloz et al. Overcoming information reduced data and experimentally uncertain parameters in ptychography with regularized optimization </p> <p>5) M. Du et al. Adorym: a multi-platform generic X-ray image reconstruction framework based on automatic differentiation </p>"},{"location":"reference/#maximum-likelihood-ml","title":"Maximum Likelihood (ML):","text":"<p>6) P. Thibault and M. Guizar-Sicairos. Maximum-likelihood refinement for coherent diffractive imaging </p>"},{"location":"reference/#compressed-lsq","title":"Compressed LSQ:","text":"<p>7) A. Gladyshev et al. Lossy Compression of Electron Diffraction Patterns for Ptychography via Change of Basis</p>"},{"location":"reference/#lsq_sqrt-and-lsq_sqrt2","title":"lsq_sqrt and lsq_sqrt2:","text":"<p>8) P. Godard et al. (2012). Noise models for low counting rate coherent diffraction imaging</p>"},{"location":"reference/#mixed-state-formalism","title":"Mixed state formalism:","text":"<p>9) P Thibault &amp; A.Menzel Reconstructing state mixtures from diffraction measurements\u2014 Flux-preserving formalism (for near-field imaging)</p>"},{"location":"reference/#near-field-imaging","title":"Near-field imaging","text":"<p>10) C. Koch A flux-preserving non-linear inline holography reconstruction algorithm for partially coherent electrons</p>"},{"location":"reference/#tilted-propagator","title":"Tilted propagator:","text":"<p>11) Earl J. Kirkland. Advanced Computing  in Electron Microscopy </p> <p>12) H. She, J. Cui and R. Yu. Deep sub-angstrom resolution imaging by electron ptychography with misorientation correction</p>"},{"location":"reference/#regularization-constaints","title":"Regularization constaints:","text":"<p>13) M. Schloz et al. Overcoming information reduced data and experimentally uncertain parameters in ptychography with regularized optimization </p> <p>14) A. Gladyshev et al. Lossy Compression of Electron Diffraction Patterns for Ptychography via Change of Basis</p>"},{"location":"reference/#linesearch","title":"Linesearch","text":"<p>15) L. Armijo (1966). Minimization of functions having Lipschitz continuous first partial derivatives 16) P. Wolfe (1969). Convergence Conditions for Ascent Methods</p>"},{"location":"reference/#bfgs-algotithm","title":"BFGS algotithm","text":"<p>17) C. G. Broyden (1970). The convergence of a class of double-rank minimization algorithms</p> <p>18) R. Fletcher   (1970). A New Approach to Variable Metric Algorithms</p> <p>19) D. Goldfarb (1970). A Family of Variable Metric Updates Derived by Variational Means</p> <p>20) D. F. Shanno (1970). Conditioning of quasi-Newton methods for function minimization</p>"},{"location":"reference/#complex-derivatives","title":"Complex derivatives","text":"<p>21) W. Wirtinger (1927). Zur formalen theorie der funktionen von mehr komplexen ver\u00e4nderlichen. </p>"},{"location":"reference/pypty/custom_presets/","title":"PyPty Parameters for Creating Custom Presets","text":"<p>All functions in PyPty work dictionary describing your preset. We tend to name it <code>pypty_params</code>. The main function of PyPty package providing an iterative ptychographic reconsturction is launched via <code>run_ptychography()</code> functon from <code>pypty.iterative_ptychography</code> module. It takes a single argument- <code>pypty_params</code>.</p> <p>For an easy preset configuration, please refer to the <code>pypty.initialize</code> module. It allows easy creation of all arrays. However, for a non-trivial experiment please follow this guide to create your own dictionary and fill in the requiered entries.</p>"},{"location":"reference/pypty/custom_presets/#lambda-type-in-pypty","title":"Lambda-type in PyPty","text":"<p>Before starting this guide, one important usage case must be discussed. PyPty is an iterative algorithm and, as you will see, it requires a number of input parameters. Some of these parameters can be specified in an iteration-dependent fashion using a lambda function. This function should take a single input argument and return the desired value for a given epoch.</p> <p>For example, if you want to apply <code>smart_memory</code> parameter every 10 epochs, you can set <code>smart_memory</code> in <code>pypty_params</code> dictionary as:</p> <pre><code>smart_memory: lambda x: x % 10 == 0;\n</code></pre> <p>The parameters that can be written in this way are marked as <code>pypty_lambda</code> type in the  Default Data Type column. They can also be specified as a sting containing the code, e.g. </p> <pre><code>smart_memory: \"lambda x: x % 10 == 0\";\n</code></pre> <p>We do not recommend applying constraints every n epochs, as PyPty\u2019s BFGS algorithm attempts to construct a Hessian matrix, and such modifications can disrupt this process. As a general rule of thumb, we suggest configuring lambda functions so that once an optimization parameter is activated, it maintains a consistent value throughout execution.</p>"},{"location":"reference/pypty/custom_presets/#full-list-of-paramerers-for-pyptyiterative_ptychographyrun_ptychography","title":"Full list of paramerers for pypty.iterative_ptychography.run_ptychography()","text":""},{"location":"reference/pypty/custom_presets/#backend-settings","title":"Backend Settings","text":"Parameter Default Value Default Data Type Description <code>backend</code> <code>cp</code> <code>NumPy-like python module</code> Currently not used, but will be a feature in the future. Right now, whenever CuPy is available, it is used as the GPU backend. If no CUDA is detected, NumPy is used as a CPU replacement. We plan to add support for Apple Silicon, but we are waiting for an optimal library to appear. <code>default_dtype</code> <code>\"double\"</code> <code>str</code> Default data type for computations. Another option is <code>\"single\"</code>."},{"location":"reference/pypty/custom_presets/#dataset","title":"Dataset","text":"Parameter Default Value Default Data Type Description <code>data_path</code> <code>\"\"</code> <code>str</code> Path to the dataset. It can be an <code>.h5</code> file with a dataset named <code>\"data\"</code> containing a 3D measurement array <code>(N_measurements, y, x)</code>. Another option is a 4D <code>.npy</code> array or a 3D <code>.npy</code> array. <code>dataset</code> <code>None</code> <code>numpy-array</code> or None If you don't want to store data on disk, you can attach a numpy-array with your data to the parameters. If it's provided, <code>data_path</code> is ignored. <code>masks</code> <code>None</code> <code>numpy.ndarray</code> or <code>None</code> Masks (virtual detectors) used for data compression. For uncompressed data, leave it as <code>None</code>. <code>data_multiplier</code> <code>1</code> <code>float</code> Multiplier for data values. Used to rescale patterns on the fly without modifying the stored dataset. All patterns will be multiplied by this number. <code>data_pad</code> <code>0</code> <code>int</code> Padding applied to data. Use it to pad patterns on the fly without modifying the stored dataset. We recommend setting it to 1/4 of the pattern width for optimal sampling conditions in far-field mode. <code>data_bin</code> <code>1</code> <code>int</code> Binning factor for data. Used to bin patterns on the fly without modifying the stored dataset. All patterns will be binned by this number. <code>flip_ky</code> <code>False</code> <code>bool</code> Flag indicating that one has to flip <code>ky</code>. Useful if patterns are flipped and you don\u2019t want to modify the stored dataset. Another option is to create a PyPty-style <code>.h5</code> dataset. <code>data_shift_vector</code> <code>[0,0]</code> <code>list</code> Shift vector (list with two-values) applied to measurements. Used to shift patterns on the fly without modifying the stored dataset. All patterns will be shifted by the specified number of pixels. <code>upsample_pattern</code> <code>1</code> <code>int</code> Upsampling factor. If the beam footprint is larger than the extent (in far-field mode), this allows to artificially upsample the beam in reciprocal space. Experimental feature! Windowing constraints may be required. <code>sequence</code> <code>None</code> <code>list</code> or <code>None</code> or <code>pypty_lambda</code> Sequence used in data processing. This is a list indicating the measurements that will be used for iterative refinement. If <code>None</code>, all measurements contribute. This parameter is useful for reconstructions on subscans without creating additional data files. <code>use_full_FOV</code> <code>True</code> <code>bool</code> Boolean flag. Only useful if a sequence is provided. If <code>True</code>, the object can accommodate all measurements. If <code>False</code>, the object accommodates only selected measurements."},{"location":"reference/pypty/custom_presets/#saving-and-printing","title":"Saving and Printing","text":"Parameter Default Value Default Data Type Description <code>output_folder</code> <code>\"\"</code> <code>str</code> Path to the folder where output files will be saved. <code>save_loss_log</code> <code>True</code> <code>bool</code> Boolean flag. If <code>True</code>, the loss log will be saved as <code>loss.csv</code>. <code>epoch_prev</code> <code>0</code> <code>int</code> Previous epoch count. Useful for restarting a reconstruction. <code>save_checkpoints_every_epoch</code> <code>False</code> <code>bool</code>   or <code>int</code> Save checkpoints every epoch. If <code>True</code>, checkpoints will be always saved, if it is provided as an integer, checkpoints will be saved every n'th epoch. <code>save_inter_checkpoints</code> <code>True</code> <code>bool</code>  or <code>int</code> Save intermediate overwritable checkpoints. This will create <code>.npy</code> arrays: <code>co.npy</code> for the object, <code>cp.npy</code> for the probe, <code>cg.npy</code> for the scan grid, <code>ct.npy</code> for the tilts, <code>cs.npy</code> for the static background, and <code>cb.npy</code> for the beam current. If <code>True</code>, checkpoints will be always saved, if it is provided as an integer, checkpoints will be saved every n'th epoch. <code>print_flag</code> <code>3</code> <code>int</code> Print verbosity level: <code>0</code> for no printing, <code>1</code> for one overwritable line, <code>2</code> and <code>3</code> for moderate output. <code>4</code> gives the most detailed output."},{"location":"reference/pypty/custom_presets/#experimental-parameters","title":"Experimental Parameters","text":"Parameter Default Value Default Data Type Description <code>acc_voltage</code> <code>60</code> <code>float</code> Acceleration voltage in kV. <code>aperture_mask</code> <code>None</code> <code>numpy.ndarray</code> or <code>None</code> Mask for the aperture. Can be used for reciprocal probe constaint later (see section constraints). <code>recon_type</code> <code>\"far_field\"</code> <code>str</code> Type of reconstruction. Options: <code>\"far_field\"</code> or <code>\"near_field\"</code>. <code>alpha_near_field</code> <code>0.0</code> <code>float</code> Alpha parameter for near-field reconstruction &amp; flux preservation. <code>defocus_array</code> <code>np.array([0.0])</code> <code>numpy.ndarray</code> Array of defocus values for near-field measurement. Irrelevant for far-field. It can contain either a single common defocus value for all measurements or individual values for each measurement. Units: Angstroms. <code>Cs</code> <code>0.0</code> <code>float</code> Spherical aberration coefficient. Units: Angstroms."},{"location":"reference/pypty/custom_presets/#spatial-calibration","title":"Spatial Calibration","text":"Parameter Default Value Default Data Type Description <code>slice_distances</code> <code>np.array([10.0])</code> <code>numpy.ndarray</code> Distances between object slices. Units: Angstroms. You can specify a single value common for all slices or provide individual values. <code>pixel_size_x_A</code> <code>1.0</code> <code>float</code> Pixel size in the x-direction (Angstroms). <code>pixel_size_y_A</code> <code>1.0</code> <code>float</code> Pixel size in the y-direction (Angstroms). <code>scan_size</code> <code>None</code> <code>tuple</code> or <code>None</code> Tuple describing the number of scan points in y- and x- directions. Required for constraining positions and tilts. <code>num_slices</code> <code>1</code> <code>int</code> Number of slices in the object."},{"location":"reference/pypty/custom_presets/#refinable-arrays","title":"Refinable Arrays","text":"Parameter Default Value Default Data Type Description <code>obj</code> <code>np.ones((1, 1, num_slices, 1))</code> <code>numpy.ndarray</code> Initial guess for the transmission function to be retrieved. Shape: <code>(y, x, z, modes)</code>. If the <code>y</code> and <code>x</code> dimensions are insufficient for the scan grid, the object will be padded with ones. <code>probe</code> <code>None</code> <code>numpy.ndarray</code> or <code>None</code> Real-space probe. Shape: <code>(y, x, modes)</code>. For advanced experiments, the probe can be 4D <code>(y, x, modes, subscans)</code>. If <code>None</code>, PyPty will automatically initialize the beam from the dataset. <code>positions</code> <code>np.array([[0.0, 0.0]])</code> <code>numpy.ndarray</code> Scan positions in pixels of the reconstruction. Shape: <code>[N_measurements, 2]</code>, formatted as <code>[[y0, x0], [y1, x1], ..., [yn, xn]]</code>. Single-shot experiments can define one common scan point, e.g., <code>[[0,0]]</code>. <code>tilts</code> <code>np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]])</code> <code>numpy.ndarray</code> Tilt angles in real and reciprocal spaces. There are 3 types of tilts in PyPty framework: before, inside and after. First one is a beam tilt before the specimen, i.e. a shift in aperture plane. Second type is a tilt inside of a specimen, i.e. after each slice the beam is shifted in real space. Third type is a post-specimen tilt i.e. a shift in a detector plane.  All three types of shifts are contained in this tilt array. Shape:  <code>[N_measurements, 6]</code>. Format: <code>[[y0_before, x0_before, y0_inside, x0_inside, y0_after, x0_after], ..., [yN, xN]]</code>. Single-shot experiments can define one common tilt (with shape <code>[1, 6]</code>). <code>tilt_mode</code> <code>0</code> <code>int</code> Mode for applying tilts: <code>0, 3, 4</code> for inside, <code>2, 4</code> for before, and <code>1, 3, 4</code> for after the specimen. <code>static_background</code> <code>0</code> <code>numpy.ndarray</code> or <code>float</code> Static background intensity. Shape should match initial patterns but padded by <code>data_pad//upsample_pattern</code>. Use <code>0</code> for no static offset. If provided as postive float, the algorithm will initialize the backgrund with a proper shape on its own. <code>beam_current</code> <code>None</code> <code>numpy.ndarray</code> or <code>None</code> Accounts for different currents (or exposure times) during measurements. If provided, must be a 1D array with length matching <code>N_measurements</code>."},{"location":"reference/pypty/custom_presets/#propagation-shifting-and-resizing","title":"Propagation, Shifting, and Resizing","text":"Parameter Default Value Default Data Type Description <code>propmethod</code> <code>\"multislice\"</code> <code>str</code> Wave propagation method. Options: <code>\"multislice\"</code>, <code>\"better_multislice\"</code>, and <code>\"yoshida\"</code>. The last two are higher precision but slower. <code>allow_subPixel_shift</code> <code>True</code> <code>bool</code> Allow subpixel shifts. If <code>False</code>, positions will be rounded to integers until refined. <code>dynamically_resize_yx_object</code> <code>False</code> <code>bool</code> or <code>int</code>  or <code>pypty_lambda</code> If position updates become too large, the object will be padded to accommodate the new scan grid. If set to a positive integer, resizing occurs when position updates exceed this value. <code>extra_space_on_side_px</code> <code>0</code> <code>int</code> Extra space added around the object in pixels."},{"location":"reference/pypty/custom_presets/#bandwidth-limitation","title":"Bandwidth Limitation","text":"Parameter Default Value Default Data Type Description <code>damping_cutoff_multislice</code> <code>2/3</code> <code>float</code> Frequency cutoff for multislice beam propagation. Values larger than <code>2/3</code> can cause aliasing artifacts. Recommended \u2264 2/3. <code>smooth_rolloff</code> <code>0</code> <code>float</code> Rolloff parameter for smooth frequency cutoffs. <code>update_extra_cut</code> <code>0.005</code> <code>float</code> Extra frequency cutoff for the full object. Ensures bandwidth limitation beyond the cropped ROIs of the multislice object. <code>lazy_clean</code> <code>False</code> <code>bool</code> If <code>True</code>, the full transmission function will not be bandwidth-limited (only cropped ROIs will be). Recommended: <code>False</code>."},{"location":"reference/pypty/custom_presets/#optimization-settings","title":"Optimization Settings","text":"Parameter Default Value Default Data Type Description <code>algorithm</code> <code>\"lsq_sqrt\"</code> <code>str</code> Error metric for reconstruction comparison. Options: <code>\"lsq_sqrt\"</code> (Gaussian), <code>\"ml\"</code> (Poisson), <code>\"lsq\"</code> (classic summed squared error), and <code>\"lsq_sqrt_2\"</code> (modified Gaussian). If data is compressed via virtual detectors, the only option is <code>\"lsq_compressed\"</code> (summed squared error  between signals). <code>epoch_max</code> <code>200</code> <code>int</code> Maximum number of epochs (iterations). <code>wolfe_c1_constant</code> <code>0.1</code> <code>float</code>  or <code>pypty_lambda</code> Wolfe condition parameter (C1). Prevents update steps from being too large. Must be &gt; 0 and &lt; C2. Larger values enforce shorter step size. <code>wolfe_c2_constant</code> <code>0.9</code> <code>float</code>   or <code>pypty_lambda</code> Wolfe condition parameter (C2). Prevents update steps from being too small. Must be &gt; C1 but &lt; 1. Larger values allow larger steps. <code>loss_weight</code> <code>1</code> <code>float</code>    or <code>pypty_lambda</code> Weight applied to the loss function. <code>max_count</code> <code>20</code> <code>int</code> or <code>None</code> Maximum number of forward-backward propagations per line search iteration. If exceeded, the update is rejected and history is reset. Use <code>None</code> or <code>np.inf</code> to disable. <code>reduce_factor</code> <code>0.1</code> <code>float</code> Factor for reducing step size when the first Wolfe condition is not met. <code>optimism</code> <code>3.0</code> <code>float</code> Factor for increasing step size when the second Wolfe condition is not met. To prevenet algorithm from going back and forth during linesearch, multiplication of optimism and reduce_factor (or of any powers of them) should not be equal to 1. <code>min_step</code> <code>1e-20</code> <code>float</code> Minimum step size. If the step falls below this value, the algorithm resets history. Use <code>0</code> to disable. <code>hist_length</code> <code>10</code> <code>int</code> or <code>np.inf</code> or <code>pypty_lambda</code> BFGS optimization history length. Values: <code>0</code> (Gradient Descent), <code>1</code> (Conjugate Gradient), <code>N&gt;1</code> (Limited-memory BFGS), <code>np.inf</code> (Full BFGS). <code>update_step_bfgs</code> <code>1</code> <code>float</code> or <code>pypty_lambda</code> Common step applied to all refinable quantities. By default, after the first iteration, a Barzilai-Borwein method is used to inistialize the inverse Hessian, so most of the time, an update step of 1 should be accepted. Only during the very first iteration the linesearch might take some time to find an appropriate step. <code>phase_only_obj</code> <code>False</code> <code>bool</code> or <code>pypty_lambda</code> Whether to consider the object as phase-only. <code>tune_only_probe_phase</code> <code>False</code> <code>bool</code> or <code>pypty_lambda</code> Optimize only the reciprocal-space phase (CTF) of the probe. <code>tune_only_probe_abs</code> <code>False</code> <code>bool</code> or <code>pypty_lambda</code> Optimize only the reciprocal-space amplitude (aperture) of the probe. <code>reset_history_flag</code> <code>False</code> <code>bool</code> or <code>pypty_lambda</code> Flag to reset optimization history. See section \"lambda-types\" in this document. If provided, history will be manually resetted."},{"location":"reference/pypty/custom_presets/#updating-refinable-arrays","title":"Updating Refinable Arrays","text":"Parameter Default Value Default Data Type Description <code>update_probe</code> <code>1</code> <code>bool</code>   or <code>pypty_lambda</code> Whether to update the probe (<code>1</code> for yes, <code>0</code> for no). <code>update_obj</code> <code>1</code> <code>bool</code>   or <code>pypty_lambda</code> Whether to update the object (<code>1</code> for yes, <code>0</code> for no). <code>update_probe_pos</code> <code>0</code> <code>bool</code>   or <code>pypty_lambda</code> Whether to update probe positions (<code>1</code> for yes, <code>0</code> for no). <code>update_tilts</code> <code>0</code> <code>bool</code>   or <code>pypty_lambda</code> Whether to update tilt angles (<code>1</code> for yes, <code>0</code> for no). <code>update_beam_current</code> <code>0</code> <code>bool</code>    or <code>pypty_lambda</code> Whether to update beam current (<code>1</code> for yes, <code>0</code> for no). <code>update_aberrations_array</code> <code>0</code> <code>bool</code>   or <code>pypty_lambda</code> Whether to update aberration array (<code>1</code> for yes, <code>0</code> for no). <code>update_static_background</code> <code>0</code> <code>bool</code>   or <code>pypty_lambda</code> Whether to update static background (<code>1</code> for yes, <code>0</code> for no)."},{"location":"reference/pypty/custom_presets/#multiple-illumination-functions","title":"Multiple Illumination Functions","text":"Parameter Default Value Default Data Type Description <code>aberrations_array</code> <code>np.array([[0.0]])</code> <code>numpy.ndarray</code> Array of aberration values for multiple beams. Useful for large fields of view where the beam changes. Shape: <code>[N_subscans, N_aberrations]</code>. <code>phase_plate_in_h5</code> <code>None</code> <code>str</code> or <code>None</code> Path to an HDF5 file containing phase plates for different measurements. Dataset name should be <code>\"configs\"</code>. Shape: <code>[N_measurements, Y_probe, X_probe]</code>. <code>aberration_marker</code> <code>None</code> <code>numpy.ndarray</code> or <code>None</code> Marker for multiple CTFs. Should be a 1D array of length <code>N_measurements</code>, where each entry corresponds to a CTF index in <code>aberrations_array</code>. <code>probe_marker</code> <code>None</code> <code>numpy.ndarray</code> or <code>None</code> Marker for probe variations. If provided, the probe should have shape <code>[y, x, modes, N_subscans]</code>, and this array should contain indices specifying which probe to use for each measurement."},{"location":"reference/pypty/custom_presets/#memory-usage","title":"Memory Usage","text":"Parameter Default Value Default Data Type Description <code>load_one_by_one</code> <code>True</code> <code>bool</code> If <code>True</code>, data is loaded dynamically to save GPU memory. If <code>False</code>, all data is loaded at once (faster but memory-intensive). <code>smart_memory</code> <code>True</code> <code>bool</code>   or <code>pypty_lambda</code> If <code>True</code>, memory is managed intelligently, clearing cache when necessary to prevent memory fragmentation. <code>remove_fft_cache</code> <code>False</code> <code>bool</code> If <code>True</code>, FFT cache is removed periodically to save memory. (Experimental feature) <code>compute_batch</code> <code>\"auto\"</code> <code>int</code> or <code>str</code> Batch size for multislice computation. Default value \"auto\" will automatically estimate a value that would fit into your memory, but ideally one should balance it by hand for a particular GPU. Increasing this can speed up reconstruction but requires more GPU memory. Super large values are also useless as at some point you will reash the limit the compute capability. <code>force_dataset_dtype</code> <code>default_float_cpu</code> <code>numpy.dtype</code> Forces the dataset to be stored in a specified data type. Can help reduce memory usage at the cost of precision. <code>preload_to_cpu</code> <code>False</code> <code>bool</code> If <code>True</code>, preloads data to CPU before transferring it to GPU, improving transfer speeds for <code>.h5</code> datasets. <code>force_pad</code> <code>False</code> <code>bool</code> If <code>True</code>, pads data at the start of reconstruction (uses more memory but speeds up computation). If <code>False</code>, padding is applied on the fly to save memory. <code>memory_saturation</code> <code>0.7</code> <code>float</code> If compute batch is set to <code>\"auto\"</code>, this ratio will be used to estimate a compute batch that would requiere <code>memory_saturation</code> of the avalible GPU memory. If <code>compute_batch</code> is integer, <code>memory_saturation</code> is ignored."},{"location":"reference/pypty/custom_presets/#constraints-contributing-to-the-loss","title":"Constraints Contributing to the Loss","text":"Parameter Default Value Default Data Type Description <code>mixed_variance_weight</code> <code>0</code> <code>float</code>   or <code>pypty_lambda</code> Regularization weight that prevents low-frequency variations between object states. <code>mixed_variance_sigma</code> <code>0.5</code> <code>float</code>   or <code>pypty_lambda</code> Controls the spatial frequency range affected by <code>mixed_variance_weight</code>. <code>probe_constraint_mask</code> <code>None</code> <code>numpy.ndarray</code> or <code>None</code> Mask for probe constraint in reciprocal space. Masked pixels are regularized using L2 norm. <code>probe_reg_constraint_weight</code> <code>0</code> <code>float</code> L2 regularization weight for the probe in reciprocal space. <code>window_weight</code> <code>0</code> <code>float</code>   or <code>pypty_lambda</code> L2 regularization weight for the probe in real space. <code>window</code> <code>None</code> <code>numpy.ndarray</code> or <code>None</code> or or <code>pypty_lambda</code> Window function used to constrain the probe in real space. Masked pixels are damped using L2 regularization. It can be either a 2d- real valued array with the same shape as upsampled and padded beam or a list containing two values: inner radius (fraction) and outer radius (fraction). Fractions will be multiplied with half of the probe width, everything inside of window will be kept intact, everything outside will be zeroed and intermediate values will be slighly damped. <code>abs_norm_weight</code> <code>0</code> <code>float</code> L1 regularization weight applied to the absorptive potential (negative log of the transmission function\u2019s absolute value). <code>phase_norm_weight</code> <code>0</code> <code>float</code>   or <code>pypty_lambda</code> L1 regularization weight applied to the phase of the object. <code>atv_weight</code> <code>0</code> <code>float</code>   or <code>pypty_lambda</code> Weight for Adaptive Total Variation (ATV) regularization on the transmission function. <code>atv_q</code> <code>1</code> <code>float</code>   or <code>pypty_lambda</code> ATV q parameter (controls the strength of smoothing). Recommended: <code>1</code>. <code>atv_p</code> <code>2</code> <code>float</code>  or <code>pypty_lambda</code> ATV p parameter (<code>1</code> = L1-like regularization, <code>2</code> = L2-like smoothing). Recommended: <code>2</code>. <code>fast_axis_reg_weight_positions</code> <code>0</code> <code>float</code> or <code>pypty_lambda</code> Regularization weight for fast-axis scan positions. Reduces the acceleration along one line. <code>slow_axis_reg_weight_positions</code> <code>0</code> <code>float</code> or <code>pypty_lambda</code> Regularization weight for slow-axis scan positions. Reduces the acceleration along one column. <code>fast_axis_reg_weight_tilts</code> <code>0</code> <code>float</code>  or <code>pypty_lambda</code> Regularization weight for fast-axis tilts. Reduces the acceleration along one line. <code>slow_axis_reg_weight_tilts</code> <code>0</code> <code>float</code>  or <code>pypty_lambda</code> Regularization weight for slow-axis tilts. Reduces the acceleration along one column. <code>deformation_reg_weight_positions</code> <code>0</code> <code>float</code>  or <code>pypty_lambda</code> Regularization weight for enfourcing a regular (but deformed) scan grid. <code>deformation_reg_weight_tilts</code> <code>0</code> <code>float</code>  or <code>pypty_lambda</code> Regularization weight for enfourcing a regular (but deformed) tilts grid."},{"location":"reference/pypty/custom_presets/#constraints-that-modify-the-object-and-probe-by-hand","title":"Constraints That Modify the Object and Probe 'By Hand'","text":"<p>Warning: These constraints reset the BFGS history when applied.</p> Parameter Default Value Default Data Type Description <code>apply_gaussian_filter</code> <code>False</code> <code>bool</code>   or <code>pypty_lambda</code> Applies a Gaussian filter to the phase of the object. <code>apply_gaussian_filter_amplitude</code> <code>False</code> <code>bool</code>    or <code>pypty_lambda</code> Applies a Gaussian filter to the amplitude of the object. <code>beta_wedge</code> <code>0</code> <code>float</code>  or <code>pypty_lambda</code> Removes high kz frequencies for low kx and ky in 3D object FFTs. <code>keep_probe_states_orthogonal</code> <code>False</code> <code>bool</code>  or <code>pypty_lambda</code> Enforces orthogonality of probe modes. <code>do_charge_flip</code> <code>False</code> <code>bool</code> Performs charge flipping on the object. <code>cf_delta_phase</code> <code>0.1</code> <code>float</code> Delta phase for charge flipping. <code>cf_delta_abs</code> <code>0.01</code> <code>float</code> Delta amplitude for charge flipping. <code>do_charge_flip</code> <code>False</code> <code>bool</code>      or <code>pypty_lambda</code> Perform charge flipping on the object. <code>cf_delta_phase</code> <code>0.1</code> <code>float</code> or <code>pypty_lambda</code> Delta phase for charge flipping. <code>cf_delta_abs</code> <code>0.01</code> <code>float</code> or <code>pypty_lambda</code> Delta amplitude for charge flipping. <code>cf_beta_phase</code> <code>-0.95</code> <code>float</code> or <code>pypty_lambda</code> Beta phase parameter for charge flipping. <code>cf_beta_abs</code> <code>-0.95</code> <code>float</code> or <code>pypty_lambda</code> Beta amplitude parameter for charge flipping. <code>fancy_sigma</code> <code>None</code> <code>None</code> or <code>float</code> oor <code>pypty_lambda</code> Custom sigma parameter to enforce atomicity. <code>restart_from_vacuum</code> <code>False</code> <code>bool</code> or <code>pypty_lambda</code> Resets the object to 1 while keeping other parameters unchanged. See section \"lambda-types\" in this document. <code>reset_positions</code> <code>False</code> <code>bool</code> or <code>pypty_lambda</code> Resets the positions to initial guess while keeping other parameters unchanged. See section \"lambda-types\" in this document."},{"location":"reference/pypty/custom_presets/#beam-initialization","title":"Beam Initialization","text":"Parameter Default Value Default Data Type Description <code>n_hermite_probe_modes</code> <code>None</code> <code>tuple</code> or <code>None</code> Number of Hermite probe modes. A tuple <code>[nx, ny]</code> specifying mode orders in <code>x</code> and <code>y</code> directions. If <code>None</code>, no Hermite modes are applied. <code>defocus_spread_modes</code> <code>None</code> <code>numpy.ndarray</code> or <code>None</code> 1D array with different defocus values for initializing probe modes. Useful for simulating defocus spread in the beam. <code>aberrations</code> <code>None</code> <code>numpy.ndarray</code> or <code>None</code> 1D array of aberration coefficients in Krivanek notation, e.g., <code>C10, C12a, C12b, C21a, C21b, C23a, C23b, C30</code>. Units: Angstroms. <code>extra_probe_defocus</code> <code>0</code> <code>float</code> Extra probe defocus applied in Angstroms. Useful for adjusting initial beam focus in multislice reconstructions. <code>estimate_aperture_based_on_binary</code> <code>0</code> <code>float</code> If &gt; 0, the aperture is estimated based on a binary threshold. Pixels in the data larger than <code>mean(data) * estimate_aperture_based_on_binary</code> are considered part of the aperture. <code>beam_ctf</code> <code>None</code> <code>numpy.ndarray</code> or <code>None</code> Beam Contrast Transfer Function (CTF). If provided, must be a 2D NumPy array with dimensions matching the upsampled probe size. <code>mean_pattern</code> <code>None</code> <code>numpy.ndarray</code> or <code>None</code> Mean diffraction pattern used for probe initialization. If provided, the probe is created using an inverse Fourier transform of this pattern."},{"location":"reference/pypty/direct_ptychography/","title":"Module pypty.direct_ptychography","text":""},{"location":"reference/pypty/direct_ptychography/#functions","title":"Functions","text":"<p><code>wdd(pypty_params, eps_wiener=0.001, thresh=None, save=0)</code> :   Perform Wigner Distribution Deconvolution.</p> <pre><code>This function applies Wigner Distribution Deconvolution to the provided data, allowing for enhanced reconstruction of complex objects and probes.\n\nParameters\n----------\npypty_params : dict\n    Dictionary containing calibrated parameters, including paths and settings for data processing.\neps_wiener : float, optional\n    Epsilon parameter for the Wiener filter (default is 1e-3).\nthresh : float, optional\n    Threshold for an alternative deconvolution approach. If provided, `eps_wiener` is ignored, and denominator values below this threshold are set to 1 while the corresponding numerator values are set to 0.\nsave : int, optional\n    Flag indicating whether to save the output files (default is 0, which means False). Ignored if `save_preprocessing_files` is provided in `pypty_params`.\n\nReturns\n-------\no : 2D complex ndarray\n    The deconvolved complex object.\nprobe : 2D complex ndarray\n    The reconstructed complex beam.\n\nNotes\n-----\n- The function handles both GPU (via CuPy) and CPU (via NumPy) computations based on the availability of the CuPy library.\n- The `pypty_params` dictionary must be prepaired via initilize module\n</code></pre>"},{"location":"reference/pypty/dpc/","title":"Module pypty.dpc","text":""},{"location":"reference/pypty/dpc/#functions","title":"Functions","text":"<p><code>GetPLRotation(dpcx, dpcy)</code> :   Estimate rotation angle that minimizes the curl of the DPC signal.</p> <pre><code>Parameters\n----------\ndpcx : ndarray\n    X-component of the DPC signal (2D array).\ndpcy : ndarray\n    Y-component of the DPC signal (2D array).\n\nReturns\n-------\nfloat\n    Optimal rotation angle in radians.\n</code></pre> <p><code>fft_based_dpc(pypty_params, hpass=0, lpass=0, save=False, comx=None, comy=None, plot=False)</code> :   FFT-based DPC phase reconstruction. If you setted up the pypty_params properly, you would only need to specify the hpass and lpass values, both are non-negative floats.     Parameters     ----------     pypty_params : dict         PyPty parameter dictionary with dataset and calibration settings.     hpass : float, optional         High-pass filtering coefficient (default is 0).     lpass : float, optional         Low-pass filtering coefficient (default is 0).     save : bool, optional         Whether to save the reconstructed phase (default is False).     comx : ndarray or None, optional         Precomputed center-of-mass x-component.     comy : ndarray or None, optional         Precomputed center-of-mass y-component.     plot : bool, optional         If True, display the phase reconstruction.</p> <pre><code>Returns\n-------\npot : ndarray\n    Reconstructed 2D phase image.\npypty_params : dict\n    Updated parameter dictionary with computed COM and rotation angle.\n</code></pre> <p><code>get_curl(angle, dpcx, dpcy)</code> :   Compute the standard deviation of the curl of a rotated DPC vector field. This is the objective function for minimization. This particular function was copied from a DPC plugin written by Jordan Hachtel.</p> <pre><code>Parameters\n----------\nangle : float\n    Rotation angle in radians.\ndpcx : ndarray\n    X-component of the DPC signal.\ndpcy : ndarray\n    Y-component of the DPC signal.\n\nReturns\n-------\nfloat\n    Standard deviation of the curl after rotation.\n</code></pre> <p><code>get_curl_derivative(angle, dpcx, dpcy)</code> :   Compute the derivative of the curl-based objective function with respect to rotation angle.</p> <pre><code>Parameters\n----------\nangle : float\n    Rotation angle in radians.\ndpcx : ndarray\n    X-component of the DPC signal.\ndpcy : ndarray\n    Y-component of the DPC signal.\n\nReturns\n-------\nfloat\n    Derivative of the curl-based objective function.\n</code></pre> <p><code>iterative_dpc(pypty_params, num_iterations=100, beta=0.5, hpass=0, lpass=0, step_size=0.1, COMx=None, COMy=None, px_size=None, print_flag=False, save=False, select=None, plot=True, use_backtracking=True, pad_width=5)</code> :   Iterative DPC phase reconstruction. If you setted up the pypty_params properly, you would only need to specify the hpass and lpass values, both are non-negative floats.</p> <pre><code>Parameters\n----------\npypty_params : dict\n    PyPty parameter dictionary.\nnum_iterations : int, optional\n    Number of gradient descent iterations (default is 100).\nbeta : float, optional\n    Step reduction factor for backtracking (default is 0.5).\nhpass : float, optional\n    High-pass filtering coefficient (default is 0).\nlpass : float, optional\n    Low-pass filtering coefficient (default is 0).\nstep_size : float, optional\n    Initial gradient descent step size (default is 0.1).\nCOMx : ndarray or None\n    X-component of COM map.\nCOMy : ndarray or None\n    Y-component of COM map.\npx_size : float or None\n    Scan step size in \u00c5ngstr\u00f6ms.\nprint_flag : bool, optional\n    Whether to print progress information (default is False).\nsave : bool, optional\n    Whether to save the result to disk (default is False).\nselect : ndarray or None\n    Optional binary mask to constrain reconstruction.\nplot : bool, optional\n    If True, plot the reconstruction result.\nuse_backtracking : bool, optional\n    Whether to use backtracking line search (default is True).\npad_width : int, optional\n    Padding width to suppress FFT boundary artifacts (default is 5).\n\nReturns\n-------\npadded_phase : ndarray\n    Reconstructed 2D phase image.\n</code></pre> <p><code>iterative_poisson_solver(laplace, num_iterations=100, beta=0.5, hpass=0, lpass=0, select=None, px_size=1, print_flag=False, step_size=0.1, use_backtracking=True, pad_width=1, xp=&lt;module 'numpy' from '/Users/anton/miniconda/lib/python3.10/site-packages/numpy/__init__.py'&gt;)</code> :   Iterative solver for Poisson equation given a Laplacian map.</p> <pre><code>Parameters\n----------\nlaplace : ndarray\n    Input 2D array representing the Laplacian of the desired phase.\nnum_iterations : int, optional\n    Number of iterations (default is 100).\nbeta : float, optional\n    Step size reduction factor (default is 0.5).\nhpass : float, optional\n    High-pass filtering parameter (default is 0).\nlpass : float, optional\n    Low-pass filtering parameter (default is 0).\nselect : ndarray or None, optional\n    Optional binary mask to restrict updates.\npx_size : float, optional\n    Pixel size in \u00c5ngstr\u00f6ms (default is 1).\nprint_flag : bool, optional\n    If True, print convergence status (default is False).\nstep_size : float, optional\n    Initial gradient descent step size (default is 0.1).\nuse_backtracking : bool, optional\n    Whether to use backtracking line search (default is True).\npad_width : int, optional\n    Number of pixels to pad around the solution (default is 1).\nxp : module, optional\n    Backend array library (NumPy or CuPy, default is NumPy).\n\nReturns\n-------\nndarray\n    Reconstructed 2D phase from the input Laplacian.\n</code></pre>"},{"location":"reference/pypty/fft/","title":"Module pypty.fft","text":""},{"location":"reference/pypty/fft/#functions","title":"Functions","text":"<p><code>fft2(arr, axes=(0, 1), overwrite_x=False)</code> :   Wrapper for fft2 function.</p> <pre><code>Parameters\n----------\narr : ndarray\n    Input array to be transformed.\naxes : tuple of int, optional\n    Axes over which to compute the FFT (default is (0, 1)).\noverwrite_x : bool, optional\n    If True, allow overwriting the input array (default is False).\n\nReturns\n-------\nndarray\n    2D Fourier Transform of the input array.\n</code></pre> <p><code>fftfreq(length, sampling=1)</code> :   Wrapper for fftfreq function.</p> <pre><code>Parameters\n----------\nlength : int\n    Length of the output array.\nsampling : float, optional\n    Sample spacing (default is 1).\n\nReturns\n-------\nndarray\n    Discrete Fourier Transform sample frequencies.\n</code></pre> <p><code>fftn(arr, axes=(0, 1, 2))</code> :   Wrapper for fftn function.</p> <pre><code>Parameters\n----------\narr : ndarray\n    Input array to be transformed.\naxes : tuple of int, optional\n    Axes over which to compute the FFT (default is (0, 1, 2)).\n\nReturns\n-------\nndarray\n    N-dimensional Fourier Transform of the input array.\n</code></pre> <p><code>fftshift(array)</code> :   Wrapper for fftshift function.</p> <pre><code>Parameters\n----------\narray : ndarray\n    Input array to be shifted.\n\nReturns\n-------\nndarray\n    Shifted array.\n</code></pre> <p><code>ifft2(arr, axes=(0, 1), overwrite_x=False)</code> :   Wrapper for ifft2 function.</p> <pre><code>Parameters\n----------\narr : ndarray\n    Input array to be transformed.\naxes : tuple of int, optional\n    Axes over which to compute the inverse FFT (default is (0, 1)).\noverwrite_x : bool, optional\n    If True, allow overwriting the input array (default is False).\n\nReturns\n-------\nndarray\n    2D inverse Fourier Transform of the input array.\n</code></pre> <p><code>ifft2_ishift(arr, axes=(0, 1), overwrite_x=False)</code> :   Wrapper for xp.fft.ifft2(xp.fft.ifftshift(...)) function.</p> <pre><code>Parameters\n----------\narr : ndarray\n    Input array to be transformed.\naxes : tuple of int, optional\n    Axes over which to compute the inverse FFT (default is (0, 1)).\noverwrite_x : bool, optional\n    If True, allow overwriting the input array (default is False).\n\nReturns\n-------\nndarray\n    2D inverse Fourier Transform of the input array, after shifting.\n</code></pre> <p><code>ifftfreq(length, sampling=1)</code> :   Wrapper for ifftfreq function.</p> <pre><code>Parameters\n----------\nlength : int\n    Length of the output array.\nsampling : float, optional\n    Sample spacing (default is 1).\n\nReturns\n-------\nndarray\n    Discrete inverse Fourier Transform sample frequencies.\n</code></pre> <p><code>ifftn(arr, axes=(0, 1, 2))</code> :   Wrapper for ifftn function.</p> <pre><code>Parameters\n----------\narr : ndarray\n    Input array to be transformed.\naxes : tuple of int, optional\n    Axes over which to compute the inverse FFT (default is (0, 1, 2)).\n\nReturns\n-------\nndarray\n    N-dimensional inverse Fourier Transform of the input array.\n</code></pre> <p><code>ifftn_ishift(arr, axes=(0, 1, 2))</code> :   Wrapper for xp.fft.ifftn(xp.fft.ifftshift(...)) function.</p> <pre><code>Parameters\n----------\narr : ndarray\n    Input array to be transformed.\naxes : tuple of int, optional\n    Axes over which to compute the inverse FFT (default is (0, 1, 2)).\n\nReturns\n-------\nndarray\n    N-dimensional inverse Fourier Transform of the input array, after shifting.\n</code></pre> <p><code>ifftshift(array)</code> :   Wrapper for ifftshift function.</p> <pre><code>Parameters\n----------\narray : ndarray\n    Input array to be inverse shifted.\n\nReturns\n-------\nndarray\n    Inverse shifted array.\n</code></pre> <p><code>shift_fft2(arr, axes=(0, 1), overwrite_x=False)</code> :   Wrapper for xp.fft.fftshift(xp.fft.fft2(...)) functions.</p> <pre><code>Parameters\n----------\narr : ndarray\n    Input array to be transformed.\naxes : tuple of int, optional\n    Axes over which to compute the FFT (default is (0, 1)).\noverwrite_x : bool, optional\n    If True, allow overwriting the input array (default is False).\n\nReturns\n-------\nndarray\n    2D Fourier Transform of the input array, shifted.\n</code></pre> <p><code>shift_fftn(arr, axes=(0, 1, 2))</code> :   Wrapper for xp.fft.fftshift(xp.fft.fftn(...)) function.</p> <pre><code>Parameters\n----------\narr : ndarray\n    Input array to be transformed.\naxes : tuple of int, optional\n    Axes over which to compute the FFT (default is (0, 1, 2)).\n\nReturns\n-------\nndarray\n    N-dimensional Fourier Transform of the input array, shifted.\n</code></pre>"},{"location":"reference/pypty/ini_custom/","title":"Initialization functions availible for configuring custom presets","text":"<p>PyPty is supplied with an inialize module (see API reference). It allows to create a callibrated dataset and a pypty-preset from scratch. Here two core functions are explained in details:</p>"},{"location":"reference/pypty/ini_custom/#create_pypty_data","title":"create_pypty_data()","text":"<p>The <code>create_pypty_data()</code> function is used to generate a PyPty-style <code>.h5</code> dataset from an existing 4D-STEM dataset stored as an <code>.h5</code> or <code>.npy</code> file, or from a raw NumPy array. This function has no returns.</p> Parameter Type Default Description <code>data</code> <code>str</code> or <code>ndarray</code> - Path to an input dataset (<code>.h5</code> or <code>.npy</code>) or a NumPy array containing 4D-STEM data. <code>path_output</code> <code>str</code> - Path where the new PyPty dataset will be saved. <code>swap_axes</code> <code>bool</code> <code>False</code> Swap the last two coordinate axes. <code>flip_ky</code> <code>bool</code> <code>False</code> Flip the second last axis. <code>flip_kx</code> <code>bool</code> <code>False</code> Flip the last axis. <code>flip_y</code> <code>bool</code> <code>False</code> Flip the first axis. <code>flip_x</code> <code>bool</code> <code>False</code> Flip the second axis. <code>comcalc_len</code> <code>int</code> <code>1000</code> Number of measurements used to estimate the center. <code>comx</code> <code>int</code> or <code>None</code> <code>None</code> X-center of the measurements (computed if <code>None</code>). <code>comy</code> <code>int</code> or <code>None</code> <code>None</code> Y-center of the measurements (computed if <code>None</code>). <code>bin</code> <code>int</code> <code>1</code> Binning factor applied to the last two axes. <code>crop_left</code> <code>int</code> <code>None/0</code> Number of pixels cropped from the left. <code>crop_right</code> <code>int</code> <code>None/0</code> Number of pixels cropped from the right. <code>crop_top</code> <code>int</code> <code>None/0</code> Number of pixels cropped from the top. <code>crop_bottom</code> <code>int</code> <code>None/0</code> Number of pixels cropped from the bottom. <code>normalize</code> <code>bool</code> <code>False</code> If <code>True</code>, each pattern is rescaled so that its sum is 1 on average. <code>cutoff_ratio</code> <code>float</code> <code>None</code> If provided, values farther than <code>cutoff_ratio * (width/2)</code> will be zeroed. <code>pad_k</code> <code>int</code> <code>0</code> Padding applied to the last two axes. <code>data_dtype</code> <code>dtype</code> <code>np.float32</code> Data type of the output file. <code>rescale</code> <code>float</code> <code>1</code> If not 1, patterns are divided by this value. <code>exist_ok</code> <code>bool</code> <code>True</code> If <code>True</code>, does not overwrite the output file if it already exists. <p>Usage Example <pre><code>pypty.initialize.create_pypty_data(\"input_data.h5\", \"output_data.h5\", flip_x=True, bin=2, normalize=True)\n</code></pre></p>"},{"location":"reference/pypty/ini_custom/#append_exp_params","title":"append_exp_params()","text":"<p>The <code>append_exp_params()</code> function is used to calibrate an existing PyPty preset to new experimental data by incorporating experimental metadata and calibration parameters.</p>"},{"location":"reference/pypty/ini_custom/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>experimental_params</code> <code>dict</code> - A dictionary containing experimental metadata. (See details below) <code>pypty_params</code> <code>dict</code> or <code>str</code> or <code>None</code> <code>None</code> Existing PyPty parameters. If <code>str</code>, it should be a path to a preset file. If <code>None</code>, a new parameter set is created."},{"location":"reference/pypty/ini_custom/#expected-keys-in-experimental_params","title":"Expected Keys in <code>experimental_params</code>","text":"<p>The <code>experimental_params</code> dictionary should contain the following keys:</p> <p>Essential Data Paths</p> Key Type Description <code>data_path</code> <code>str</code> Path to a 3D PyPty <code>.h5</code> dataset (<code>[N_measurements, ky, kx]</code>) or a 4D-STEM <code>.npy</code> dataset. <code>masks</code> <code>ndarray</code> or <code>None</code> If the data is compressed, provide the virtual detectors (<code>[N_masks, ky, kx]</code>). <code>output_folder</code> <code>str</code> Directory where results will be stored. <code>path_json</code> <code>str</code> Path to a Nion-style <code>.json</code> file with metadata (optional). <p>Electron Beam Properties</p> Key Type Description <code>acc_voltage</code> <code>float</code> Accelerating voltage (in kV). <code>rez_pixel_size_A</code> <code>float</code> Reciprocal pixel size (in \u00c5\u207b\u00b9). <code>rez_pixel_size_mrad</code> <code>float</code> Reciprocal pixel size (in mrad). <code>conv_semiangle_mrad</code> <code>float</code> Beam convergence semi-angle (in mrad). <code>aperture</code> <code>ndarray</code> (optional) Binary 2D mask representing the aperture. <code>bright_threshold</code> <code>float</code> Threshold for estimating an aperture. Everything above <code>threshold * max(PACBED)</code> is considered bright field. <p>Scan and Positioning</p> Key Type Description <code>scan_size</code> <code>tuple(int, int)</code> Number of scan points along slow (y) and fast (x) axes. <code>scan_step_A</code> <code>float</code> Scan step (STEM pixel size) in \u00c5. <code>fov_nm</code> <code>float</code> Field of view (FOV) along the fast axis in nm. <code>special_positions_A</code> <code>ndarray</code> (optional) If data was acquired on a non-rectangular grid, specify positions as <code>[y_0, x_0], ..., [y_n, x_n]</code> (in \u00c5). <code>transform_axis_matrix</code> <code>ndarray (2\u00d72)</code> Transformation matrix for position correction. <code>PLRotation_deg</code> <code>float</code> or <code>\"auto\"</code> Rotation angle between scan and detector axes. If <code>\"auto\"</code>, an iDPC measurement estimates this angle. <p>Reconstruction Settings</p> Key Type Description <code>num_slices</code> <code>int</code> Number of slices used for multislice propagation (default: <code>1</code>). <code>total_thickness</code> <code>float</code> Total thickness of the sample (in \u00c5). <code>data_pad</code> <code>int</code> or <code>None</code> Reciprocal space padding. Default: <code>1/4</code> of pattern width. <code>upsample_pattern</code> <code>int</code> Upsampling factor for diffraction patterns. <code>flip_ky</code> <code>bool</code> Flip the y-axis of diffraction patterns. <code>defocus</code> <code>float</code> Extra probe defocus (besides aberrations). <code>aberrations</code> <code>list</code> or <code>ndarray</code> Beam aberrations (stored in Krivanek notation). <p>Output &amp; Debugging</p> Key Type Description <code>plot</code> <code>bool</code> If <code>True</code>, generates plots of key experimental parameters. <code>print_flag</code> <code>int</code> Controls verbosity (<code>0</code> = silent, <code>1</code> = summary, <code>2+</code> = detailed logs). <code>save_preprocessing_files</code> <code>bool</code> If <code>True</code>, saves intermediate preprocessing files. <p>Nexus Tags</p> Key Type Description <code>chemical_fomula</code> <code>string</code> You can optionally provide a formula for your sample. PyPty will store this information. <code>sample_name</code> <code>string</code> You can optionally provide a name of your sample. PyPty will store this information. <p>Usage Example</p> <pre><code>experimental_params = {\n    \"data_path\": \"experiment_data.h5\",\n    \"acc_voltage\": 300,\n    \"rez_pixel_size_A\": 0.01,\n    \"scan_size\": (256, 256),\n    \"scan_step_A\": 1.5,\n    \"PLRotation_deg\": \"auto\",\n    \"output_folder\": \"results/\"\n}\npypty_params = None # or your custom preset\npypty_params = pypty.initialize.append_exp_params(experimental_params, pypty_params)\n</code></pre>"},{"location":"reference/pypty/initialize/","title":"Module pypty.initialize","text":""},{"location":"reference/pypty/initialize/#functions","title":"Functions","text":"<p><code>append_aperture_to_params(pypty_params, mean_pattern)</code> :   Append a measured aperture to the reconstruction parameters.</p> <pre><code>Parameters\n----------\npypty_params : dict\n    PyPty parameter dictionary.\nmean_pattern : ndarray\n    Aperture image to be rescaled and added.\n\nReturns\n-------\ndict\n    Updated dictionary with aperture.\n</code></pre> <p><code>append_exp_params(experimental_params, pypty_params=None)</code> :   Attach experimental parameters to a PyPty preset dictionary and callibrate an extisting PyPty preset to new data. </p> <pre><code>Parameters\n----------\nexperimental_params : dict\n    Dictionary containing experimental metadata and setup for PyPty reconstruction.\npypty_params : dict or str or None, optional\n    Existing PyPty preset to update, a filepath to a preset, or None to create a new one.\n\nReturns\n-------\ndict\n    Updated PyPty parameter dictionary.\n\nNotes\n-------\nexperimental_params should contain following entries:\n    -data_path - path to a PyPty-style 3d .h5 file [N_measurements, ky,kx] or .npy Nion-style 4d-stem dataset (or 3d .npy dataset)\n    -masks - 3d numpy array or None. if data is compressed provide the virtual detectors (masks) shape should be [N_masks,ky,kx]\n    -output_folder - path to an outputfolder where the results will be stored\n    -path_json - path to a nion-style json file with metadata (optional)\n    -acc_voltage - float, accelerating voltage in kV\n\n    One or multiple of the following callibrations:\n        -rez_pixel_size_A - reciprocal pixel size in \u00c5^-1\n        -rez_pixel_size_mrad - reciprocal pixel size in mrad\n\n        -conv_semiangle_mrad - beam convergence semi-angle in mrad\n        -aperture - (optional)- binary 2D mask\n        -bright_threshold - threshold to estimate an aperture, everything above threshold times maximum value in a pacbed will be concidered as bright field disk.\n    -data_pad - int, reciprocal space padding. If None (default), pading is 1/4 of the total width of a diffraction pattern\n    -upsample_pattern - int, default 1 (no upsampling)\n\n    -aberrations - list or 1d numpy array containing beam aberrations (in \u00c5). Aberrations are stored in Krivanek notation, e.g. C10, C12a, C12b, C21a, C21b, C23a, C23b, C30 etc\n    -defocus - float, default 0. Extra probe defocus besides the one contained in aberrations.\n\n    -scan_size - tuple of two ints, number of scan points along slow (y) and fast (x) axes. Optional. If no scan step or position grid is provided, it will be used to get the scan step\n    -scan_step_A - float, scan step (STEM pixel size) in \u00c5.\n    -fov_nm - float, FOV along the fast axis in nm.\n    -special_postions_A - 2d numpy array, default None. If you acquiered a data on a special non-rectangular grid, please specify the positions in \u00c5 via this array for all measurements in a following form: [y_0,x_0],[y_1,x_1],....[y_n,x_n]]\n    -transform_axis_matrix- 2x2 matrix for postions transformation\n    -PLRotation_deg - float, rotation angle between scan and detector axes. Default None. If None, a DPC measurement will be exectuted to get this angle. !!!!!!! Note that negative PLRotation_deg values rotate scan counter clockwise and diffraction space clockwise !!!!!!!!!!!\n    -flip_ky - boolean Flag. Default is False. If no PyPty-style h5 data was created, this flag will flip the y-axis of diffraction patterns.\n\n    -total_thickness - total thickness of a sample in \u00c5. Has no effect if num_slices is 1 and propagation method (pypty_params entry) is multislice \n    -num_slices - integer, number of slices, default is 1.\n\n    -plot - boolean Flag, default is True \n    -print_flag - integer. Default is 1. If 0 nothing will be printed. 1 prints only thelatest state of the computation, 2 prints every state as a separate line. 3 prints the linesearch progress in iterative optimization. 4 prints everything that 3 does and if constraints are applied, it prints how they contribute so that a user can configure the weights properly.\n    -save_preprocessing_files - Boolean Flag. Default is True.\n</code></pre> <p><code>conjugate_beam(pypty_params)</code> :   Apply beam conjugation (flip defocus and aberrations).</p> <pre><code>Parameters\n----------\npypty_params : dict\n    PyPty parameter dictionary.\n\nReturns\n-------\ndict\n    Updated dictionary with conjugated probe and CTF.\n</code></pre> <p><code>create_aberrations_chunks(pypty_params, chop_size, n_abs)</code> :   Create chunks, i.e. multiple subscans with independent beam aberrations. Usefull for large fields of view where the beam is varyying. If applied, the iterative reconstruction will have the same beam in each subscan, but apply a different CTF in each of these regions.</p> <pre><code>Parameters\n----------\npypty_params : dict\n    PyPty parameter dictionary.\nchop_size : int\n    Size of each subscan region (in scan points).\nn_abs : int\n    Number of aberration coefficients per region.\n\nReturns\n-------\ndict\n    Updated parameter dictionary with aberration array and marker.\n</code></pre> <p><code>create_probe_marker_chunks(pypty_params, chop_size)</code> :   Creates chunks, i.e. multiple subscans with independent beam aberrations. Usefull for large fields of view where the beam is varyying. If applied, the iterative reconstruction will have the a differenet beam in each of these subscans.</p> <pre><code>Parameters\n----------\npypty_params : dict\n    PyPty parameter dictionary.\nchop_size : int\n    Size of each subscan region (in scan points).\n\nReturns\n-------\ndict\n    Updated dictionary with probe marker.\n</code></pre> <p><code>create_pypty_data(data, path_output, swap_axes=False, flip_ky=False, flip_kx=False, flip_y=False, flip_x=False, comcalc_len=1000, comx=None, comy=None, bin=1, crop_left=None, crop_right=None, crop_top=None, crop_bottom=None, normalize=False, cutoff_ratio=None, pad_k=0, data_dtype=numpy.float32, rescale=1, exist_ok=True)</code> :   Create a PyPty-style <code>.h5</code> dataset from 4D-STEM data.</p> <pre><code>Parameters\n----------\ndata : str or ndarray\n    Path to `.h5` or `.npy` data file or a 4D numpy array [scan_y, scan_x, ky, kx].\npath_output : str\n    Output file path for the PyPty `.h5` dataset.\nswap_axes : bool, optional\n    Swap the last two axes (kx, ky). Default is False.\nflip_ky, flip_kx, flip_y, flip_x : bool, optional\n    Flip the data along specific axes. Default is False.\ncomcalc_len : int, optional\n    Number of patterns to use to estimate center-of-mass. Default is 1000.\ncomx, comy : int or None, optional\n    Predefined center-of-mass. If None, it will be computed.\nbin : int, optional\n    Spatial binning factor on the diffraction patterns. Default is 1.\ncrop_left, crop_right, crop_top, crop_bottom : int or None, optional\n    Crop edges of patterns. Defaults are None.\nnormalize : bool, optional\n    Normalize pattern sums to 1. Default is False.\ncutoff_ratio : float or None, optional\n    Mask out pixels farther than `cutoff_ratio \u00d7 max_radius`. Default is None.\npad_k : int, optional\n    Padding to apply to diffraction patterns. Default is 0.\ndata_dtype : dtype, optional\n    Output data type. Default is np.float32.\nrescale : float, optional\n    Scale factor for intensity. Default is 1.\nexist_ok : bool, optional\n    If True, skip writing if file exists. Default is True.\n\nReturns\n-------\nNone\n\nNotes\n-----\nSaves a `.h5` file containing processed 4D-STEM data with standardized formatting for PyPty.\n</code></pre> <p><code>create_sequence_from_points(pypty_params, yf, xf, width_roi=20)</code> :   Create scan subsequence around specified feature points.</p> <pre><code>Parameters\n----------\npypty_params : dict\n    PyPty parameter dictionary.\nyf : list of int\n    Y-coordinates of feature points (in scan points).\nxf : list of int\n    X-coordinates of feature points.\nwidth_roi : int, optional\n    Width of the reconstruction window around each point.\n\nReturns\n-------\nlist\n    List of scan indices to reconstruct.\n</code></pre> <p><code>create_sub_sequence(pypty_params, left, top, width, height, sub)</code> :   Define a measurement subsequence for local reconstructions.</p> <pre><code>Parameters\n----------\npypty_params : dict\n    PyPty parameter dictionary.\nleft : int\n    Leftmost scan coordinate.\ntop : int\n    Top scan coordinate.\nwidth : int\n    Width of subregion (in scan points).\nheight : int\n    Height of subregion (in scan points).\nsub : int\n    Sampling factor (take every Nth point).\n\nReturns\n-------\ndict\n    Updated parameter dictionary with `sequence` key.\n</code></pre> <p><code>get_approx_beam_tilt(pypty_params, power=3, make_binary=False, percentile_filter_value=None, percentile_filter_size=10)</code> :   Estimate scan-position-dependent beam tilt from PACBED. </p> <pre><code>Parameters\n----------\npypty_params : dict\n    PyPty parameter dictionary.\npower : int or str\n    Degree of polynomial fitting.\nmake_binary : bool or float\n    If True or float &gt; 0, binarize patterns.\npercentile_filter_value : float or None\n    Value for optional percentile filtering.\npercentile_filter_size : int\n    Filter size if filtering is enabled.\n\nReturns\n-------\ndict\n    Updated dictionary with estimated tilts.\n</code></pre> <p><code>get_focussed_probe_from_vacscan(pypty_params, mean_pattern)</code> :   Reconstruct a focused probe from a vacuum PACBED pattern.</p> <pre><code>Parameters\n----------\npypty_params : dict\n    PyPty parameter dictionary.\nmean_pattern : ndarray\n    Measured PACBED from vacuum.\n\nReturns\n-------\ndict\n    Updated dictionary with a probe estimate.\n</code></pre> <p><code>get_grid_for_upsampled_image(pypty_params, image, image_pixel_size, left_zero_of_scan_grid=0, top_zero_of_scan_grid=0)</code> :   Map coordinates of an upsampled image onto the reconstruction grid.</p> <pre><code>This function calculates where pixel of an arbitary image (e.g. upsampled tcBF image) will land on a grid corresponding to a ptychographic reconstruction.\n\n\nParameters\n----------\npypty_params : dict\n    Dictionary of PyPty reconstruction parameters.\nimage : ndarray\n    2D image (e.g., upsampled tcBF) to map.\nimage_pixel_size : float\n    Pixel size of the image in \u00c5.\nleft_zero_of_scan_grid : int, optional\n    Pixel offset on left side of image relative to scan grid. Default is 0.\ntop_zero_of_scan_grid : int, optional\n    Pixel offset on top side of image relative to scan grid. Default is 0.\n\nReturns\n-------\nsc : ndarray\n    Array of pixel coordinates [[y, x], ...] in reconstruction grid units.\n</code></pre> <p><code>get_offset(x_range, y_range, scan_step_A, detector_pixel_size_rezA, patternshape, rot_angle_deg=0)</code> :   Compute pixel offsets between scan grid and reconstruction grid. In PyPty framework, scan grid is usually rotated to compensate the misalignment between scan- and detector- axes. Also, a reconstruction grid is larger than the scanned FOV, this is done to accomodate the extent of the probe. </p> <pre><code>Parameters\n----------\nx_range, y_range : int\n    Scan dimensions.\nscan_step_A : float\n    STEM scan step size in \u00c5.\ndetector_pixel_size_rezA : float\n    Reciprocal space pixel size in \u00c5\u207b\u00b9.\npatternshape : tuple\n    Shape of diffraction patterns.\nrot_angle_deg : float, optional\n    Rotation between scan and detector axes (degrees).\n\nReturns\n-------\noffy, offx : float\n    Offset values (in reconstruction pixels).\n</code></pre> <p><code>get_positions_pixel_size(x_range, y_range, scan_step_A, detector_pixel_size_rezA, patternshape, rot_angle_deg=0, flip_x=False, flip_y=False, print_flag=False, transform_axis_matrix=array([[1., 0.],        [0., 1.]]))</code> :   Generate scan positions in reconstruction pixel units.</p> <pre><code>Parameters\n----------\nx_range, y_range : int\n    Scan grid size.\nscan_step_A : float\n    STEM scan step size (\u00c5).\ndetector_pixel_size_rezA : float\n    Pixel size in reciprocal space (\u00c5\u207b\u00b9).\npatternshape : tuple\n    Shape of the diffraction pattern.\nrot_angle_deg : float, optional\n    Scan-detector rotation angle in degrees. Default is 0.\nflip_x, flip_y : bool, optional\n    Flip scan axes. Default is False.\nprint_flag : bool, optional\n    Print pixel size. Default is False.\ntransform_axis_matrix : array_like\n    Optional 2x2 matrix to apply to positions.\n\nReturns\n-------\npositions : ndarray\n    Scan positions in reconstruction pixels.\npixel_size : float\n    Size of one reconstruction pixel in \u00c5.\n</code></pre> <p><code>get_ptycho_obj_from_scan(params, num_slices=None, array_phase=None, array_abs=None, scale_phase=1, scale_abs=1, scan_array_A=None, fill_value_type=None)</code> :   Construct an initial object guess using interpolated phase and amplitude maps. You can use output of dpc, wdd of tcBF reconstructions to generate it.</p> <pre><code>Parameters\n----------\nparams : dict\n    PyPty parameter dictionary.\nnum_slices : int or str, optional\n    Number of slices or \"auto\" to estimate from max phase shift.\narray_phase : ndarray, optional\n    2D phase map to interpolate.\narray_abs : ndarray, optional\n    2D amplitude map to interpolate.\nscale_phase : float, optional\n    Scale factor for phase.\nscale_abs : float, optional\n    Scale factor for amplitude.\nscan_array_A : ndarray or None, optional\n    Spatial reference grid for the input maps (in \u00c5).\nfill_value_type : str or None, optional\n    Padding strategy outside scanned region: None, \"edge\", or \"median\".\n\nReturns\n-------\ndict\n    Updated PyPty parameter dictionary with object guess.\n</code></pre> <p><code>rotate_scan_grid(pypty_params, angle_deg)</code> :   Apply a rigid rotation to the scan grid.</p> <pre><code>Parameters\n----------\npypty_params : dict\n    PyPty parameter dictionary.\nangle_deg : float\n    Rotation angle in degrees.\n\nReturns\n-------\ndict\n    Updated dictionary with rotated positions and angle.\n</code></pre> <p><code>tiltbeamtodata(pypty_params, align_type='com')</code> :   Align the probe momentum to the center of the measured PACBED pattern.</p> <pre><code>Parameters\n----------\npypty_params : dict\n    PyPty parameter dictionary.\nalign_type : str, optional\n    Type of alignment (\"com\" or \"cross_corr\").\n\nReturns\n-------\ndict\n    Updated dictionary with shifted probe.\n</code></pre>"},{"location":"reference/pypty/iterative_ptychography/","title":"Module pypty.iterative_ptychography","text":""},{"location":"reference/pypty/iterative_ptychography/#functions","title":"Functions","text":"<p><code>bfgs_update(algorithm_type, this_slice_distances, this_step_probe, this_step_obj, this_step_pos_correction, this_step_tilts, measured_array, this_wavelength, masks, pixel_size_x_A, pixel_size_y_A, phase_norm_weight, abs_norm_weight, stepsize_threshold_low, probe_reg_weight, aperture_mask, recon_type, defocus_array, Cs, alpha_near_field, damping_cutoff_multislice, smooth_rolloff, update_extra_cut, keep_probe_states_orthogonal, do_charge_flip, cf_delta_phase, cf_delta_abs, cf_beta_phase, cf_beta_abs, phase_only_obj, beta_wedge, wolfe_c1_constant, wolfe_c2_constant, atv_weight, atv_q, atv_p, tune_only_probe_phase, propmethod, this_chopped_sequence, load_one_by_one, data_multiplier, data_pad, phase_plate_in_h5, print_flag, this_loss_weight, max_count, reduce_factor, optimism, mixed_variance_weight, mixed_variance_sigma, data_bin, data_shift_vector, smart_memory, default_float, default_complex, default_int, upsample_pattern, this_step_static_background, tilt_mode, fancy_sigma, tune_only_probe_abs, aberration_marker, this_step_aberrations_array, probe_marker, compute_batch, current_window, current_window_weight, dynamically_resize_yx_object, lazy_clean, current_gaussian_filter, current_apply_gaussian_filter_amplitude, this_beam_current_step, xp, remove_fft_cache, is_first_epoch, hist_length, actual_step, fast_axis_reg_weight_positions, fast_axis_reg_weight_tilts, slow_axis_reg_weight_positions, slow_axis_reg_weight_tilts, scan_size, current_deformation_reg_weight_positions, current_deformation_reg_weight_tilts, warnings)</code> :   This is one of the core functions of PyPty. It performs updates of all active reconstruction parameters (object, probe, positions, tilts, etc.) via l-BFGS algorithm.</p> <pre><code>Parameters\n----------\nParams : list\n    Way to many to describe right now\nReturns\n-------\ntotal_loss : float\n    Total loss value.\nthis_sse : float\n    Sum of squared errors.\nconstraint_contributions: list\n    List of reg. constraint values for this epoch\nactual_step : float\n    Linesearch step that was found during this iteration\ncount : int\n    Number of linesearch iterations (calls of loss_and_direction) that was required during this epoch\nd_value : float\n    Value of the direction derivative at this epoch\nnew_d_value : float\n    Value of the direction derivative at the newly estimated point\nwarnings : string\n    Warnings during this epoch\n</code></pre> <p><code>reset_bfgs_history()</code> :   Reset a global variable history_bfgs that contains information about previous steps.</p> <pre><code>Parameters\n----------\nNone\n\nReturns\n-------\nNone\n</code></pre> <p><code>run_ptychography(pypty_params)</code> :   Launch iterative ptychographic reconstuction.</p> <pre><code>Parameters\n----------\npypty_params : dict\n    Dictionary containing calibrated parameters, including paths and settings for data processing.\n\nReturns\n-------\nNone\n\nNotes\n-----\npypty_params dictionary can be constructed from a predefined preset and a given dataset via append_exp_params() function. Otherwise one can create the  pypty_params dictionary by hand. For more info about creating pypty_params from scratch please reffer to https://github.com/Anton-Gladyshev/pypty/tree/main (there is a .md file lisitng all possible entries). Otherwise contact Anton Gladyshev directly.\n</code></pre>"},{"location":"reference/pypty/loss_and_direction/","title":"Module pypty.loss_and_direction","text":""},{"location":"reference/pypty/loss_and_direction/#functions","title":"Functions","text":"<p><code>charge_flip(a, delta_phase=0.03, delta_abs=0.14, beta_phase=-0.95, beta_abs=-0.95, fancy_sigma=None)</code> :   Perform charge-flipping style object regularization to enhance phase and absorption contrast.</p> <pre><code>Parameters\n----------\na : ndarray\n    Complex object to regularize.\ndelta_phase : float\n    Phase threshold ratio.\ndelta_abs : float\n    Absorption threshold ratio.\nbeta_phase : float\n    Inversion multiplier for low-phase regions.\nbeta_abs : float\n    Inversion multiplier for low-absorption regions.\nfancy_sigma : tuple or None\n    Tuple of atomic-shape gaussian kernel sigmas (for phase, absorption).\n\nReturns\n-------\nndarray\n    Regularized complex object.\n</code></pre> <p><code>clear_missing_wedge(obj, px_size_x_A, px_size_y_A, slice_distance, beta_wedge)</code> :   Remove missing wedge artifacts by applying a cone filter in 3D FFT space.</p> <pre><code>Parameters\n----------\nobj : ndarray\n    3D complex object.\npx_size_x_A : float\n    Pixel size along x (\u00c5).\npx_size_y_A : float\n    Pixel size along y (\u00c5).\nslice_distance : float\n    Distance between slices (\u00c5).\nbeta_wedge : float\n    Cone sharpness parameter.\n\nReturns\n-------\nndarray\n    Filtered object with reduced missing wedge effects.\n</code></pre> <p><code>compute_atv_constraint(obj, atv_weight, atv_q, atv_p, pixel_size_x_A, pixel_size_y_A, atv_grad_mask, return_direction, smart_memory)</code> :   Apply adaptive total variation (ATV) regularization to the object.</p> <pre><code>Parameters\n----------\nobj : ndarray\n    Complex object.\natv_weight : float\n    Regularization weight.\natv_q : float\n    q-norm parameter.\natv_p : float\n    p-norm parameter.\npixel_size_x_A : float\n    Pixel size along x (\u00c5).\npixel_size_y_A : float\n    Pixel size along y (\u00c5).\natv_grad_mask : ndarray or None\n    Optional gradient mask.\nreturn_direction : bool\n    If True, return the gradient.\nsmart_memory : bool\n    If True, use memory-efficient computation.\n\nReturns\n-------\nreg_term : float\n    ATV regularization value.\ndR_dTerm : ndarray\n    Gradient with respect to the object.\n</code></pre> <p><code>compute_deformation_constraint_on_grid(something, scan_size, reg_weight)</code> :   Penalize deviations from affine transformations in local scan patches.</p> <pre><code>Parameters\n----------\nsomething : ndarray\n    Grid to regularize (positions or tilts).\nscan_size : tuple\n    Dimensions of the scan.\nreg_weight : float\n    Regularization weight.\n\nReturns\n-------\nreg_term : float\n    Regularization loss.\ngrad : ndarray\n    Gradient of the loss with respect to the grid.\n</code></pre> <p><code>compute_fast_axis_constraint_on_grid(something, scan_size, tv_reg_weight)</code> :   Apply second-order TV regularization along the fast scan axis.</p> <pre><code>Parameters\n----------\nsomething : ndarray\n    Positions or tilts to regularize.\nscan_size : tuple\n    Size of the scan grid.\ntv_reg_weight : float\n    Regularization weight.\n\nReturns\n-------\nreg_term : float\n    Value of the regularization term.\ngrad : ndarray\n    Gradient of the regularization.\n</code></pre> <p><code>compute_full_l1_constraint(object, abs_norm_weight, phase_norm_weight, grad_mask, return_direction, smart_memory)</code> :   Apply L1 norm regularization to the object's phase and absorption.</p> <pre><code>Parameters\n----------\nobject : ndarray\n    Complex object array.\nabs_norm_weight : float\n    Weight for absorption norm.\nphase_norm_weight : float\n    Weight for phase norm.\ngrad_mask : ndarray\n    Mask to restrict gradient computation.\nreturn_direction : bool\n    If True, return the gradient.\nsmart_memory : bool\n    Memory-efficient option.\n\nReturns\n-------\nreg_term : float\n    Regularization loss.\ngrad : ndarray or None\n    Gradient if `return_direction` is True, else None.\n</code></pre> <p><code>compute_missing_wedge_constraint(obj, px_size_x_A, px_size_y_A, slice_distance, beta_wedge, wegde_mu)</code> :   Enforce missing wedge constraint in 3D reciprocal space.</p> <pre><code>Parameters\n----------\nobj : ndarray\n    3D complex object.\npx_size_x_A : float\n    Pixel size along x (\u00c5).\npx_size_y_A : float\n    Pixel size along y (\u00c5).\nslice_distance : float\n    Slice spacing (\u00c5).\nbeta_wedge : float\n    Cone sharpness.\nwegde_mu : float\n    Regularization weight.\n\nReturns\n-------\nloss_term : float\n    Regularization loss.\ngrad_obj : ndarray\n    Gradient of the loss with respect to the object.\n</code></pre> <p><code>compute_mixed_object_variance_constraint(this_obj, weight, sigma, return_direction, smart_memory)</code> :   Regularize variance across object modes by penalizing their differences.</p> <pre><code>Parameters\n----------\nthis_obj : ndarray\n    Complex object array with multiple modes.\nweight : float\n    Regularization strength.\nsigma : float\n    Smoothing kernel width in frequency space.\nreturn_direction : bool\n    If True, return the gradient.\nsmart_memory : bool\n    Use memory-efficient FFT loops.\n\nReturns\n-------\nreg_term : float\n    Mixed variance loss.\ngrad : ndarray or None\n    Gradient with respect to the object if `return_direction` is True.\n</code></pre> <p><code>compute_probe_constraint(to_reg_probe, aperture, weight, return_direction)</code> :   Apply reciprocal space constraint to the probe using an aperture mask. Penalize probe values outside an aperture.</p> <pre><code>Parameters\n----------\nto_reg_probe : ndarray\n    Complex probe array.\naperture : ndarray or float\n    Binary mask or scalar defining aperture radius.\nweight : float\n    Regularization weight.\nreturn_direction : bool\n    If True, return the gradient.\n\nReturns\n-------\nreg_term : float\n    Loss from masked frequency components.\nprobe_fft : ndarray or None\n    Gradient of the constraint if requested.\n</code></pre> <p><code>compute_slow_axis_constraint_on_grid(something, scan_size, tv_reg_weight)</code> :   Apply second-order TV regularization along the slow scan axis.</p> <pre><code>Parameters\n----------\nsomething : ndarray\n    Positions or tilts to regularize.\nscan_size : tuple\n    Size of the scan grid.\ntv_reg_weight : float\n    Regularization weight.\n\nReturns\n-------\nreg_term : float\n    Regularization loss.\ngrad : ndarray\n    Gradient with respect to the input.\n</code></pre> <p><code>compute_window_constraint(to_reg_probe, current_window, current_window_weight)</code> :   Penalize probe values outside a predefined window region in real-space.</p> <pre><code>Parameters\n----------\nto_reg_probe : ndarray\n    Complex probe array.\ncurrent_window : ndarray\n    Window mask.\ncurrent_window_weight : float\n    Weight of the constraint.\n\nReturns\n-------\nreg_term : float\n    Window constraint loss.\nreg_grad : ndarray\n    Gradient of the loss with respect to the probe.\n</code></pre> <p><code>loss_and_direction(this_obj, full_probe, this_pos_array, this_pos_correction, this_tilt_array, this_tilts_correction, this_distances, measured_array, algorithm_type, this_wavelength, this_step_probe, this_step_obj, this_step_pos_correction, this_step_tilts, masks, pixel_size_x_A, pixel_size_y_A, recon_type, Cs, defocus_array, alpha_near_field, damping_cutoff_multislice, smooth_rolloff, propmethod, this_chopped_sequence, load_one_by_one, data_multiplier, data_pad, phase_plate_in_h5, this_loss_weight, data_bin, data_shift_vector, upsample_pattern, static_background, this_step_static_background, tilt_mode, aberration_marker, probe_marker, aberrations_array, compute_batch, phase_only_obj, beam_current, this_beam_current_step, this_step_aberrations_array, default_float, default_complex, xp, is_first_epoch, scan_size, fast_axis_reg_weight_positions, slow_axis_reg_weight_positions, slow_axis_reg_weight_tilts, current_deformation_reg_weight_positions, current_deformation_reg_weight_tilts, fast_axis_reg_weight_tilts, aperture_mask, probe_reg_weight, current_window_weight, current_window, phase_norm_weight, abs_norm_weight, atv_weight, atv_q, atv_p, mixed_variance_weight, mixed_variance_sigma, smart_memory, print_flag)</code> :   Compute the total loss and gradients for ptychographic reconstruction.</p> <pre><code>This is the core function of PyPty that performs forward and backward propagation,\ncalculates the loss between measured and simulated patterns, and computes the gradients\nof all active reconstruction parameters (object, probe, positions, tilts, etc.).\n\nParameters\n----------\nParams : list\n    Way to many to describe right now\n\nReturns\n-------\nloss : float\n    Total loss value.\nsse : float\n    Sum of squared errors.\nobject_grad : ndarray\n    Gradient of the loss with respect to the object.\nprobe_grad : ndarray\n    Gradient of the loss with respect to the probe.\npos_grad : ndarray\n    Gradient of the loss with respect to scan position corrections.\ntilts_grad : ndarray\n    Gradient of the loss with respect to tilts.\nstatic_background_grad : ndarray\n    Gradient of the loss with respect to static background.\naberrations_array_grad : ndarray\n    Gradient of the loss with respect to aberration coefficients.\nbeam_current_grad : ndarray\n    Gradient of the loss with respect to beam current.\nconstraint_contributions : list\n    Individual regularization loss terms added to the total loss.\n</code></pre> <p><code>make_basis_orthogonal(vectors)</code> :   Orthogonalize a set of 1D basis vectors using Gram-Schmidt.</p> <pre><code>Parameters\n----------\nvectors : ndarray\n    2D array of vectors to orthogonalize.\n\nReturns\n-------\nndarray\n    Orthogonalized basis.\n</code></pre> <p><code>make_states_orthogonal(probe_states)</code> :   Apply Gram-Schmidt orthogonalization to probe modes.</p> <pre><code>Parameters\n----------\nprobe_states : ndarray\n    Probe array with multiple modes.\n\nReturns\n-------\nndarray\n    Orthogonalized probe states.\n</code></pre> <p><code>scatteradd_abers(full, indic, batches)</code> :   Adds batched aberration updates to their respective positions in the full aberration array. This wrapper is needed to support older CuPy version.</p> <pre><code>Parameters\n----------\nfull : ndarray\n    Full aberration gradient array.\nindic : array_like\n    Indices specifying where to add each batch.\nbatches : ndarray\n    Batched gradients to scatter-add.\nReturns\n-------\n</code></pre> <p><code>scatteradd_probe(full, indic, batches)</code> :   Adds batched probe updates to their respective positions in the full probe array. This wrapper is needed to support older CuPy version.</p> <pre><code>Parameters\n----------\nfull : ndarray\n    Full probe gradient array.\nindic : array_like\n    Indices specifying where to add each batch.\nbatches : ndarray\n    Batched gradients to scatter-add.\nReturns\n-------\n</code></pre>"},{"location":"reference/pypty/multislice/","title":"Module pypty.multislice","text":""},{"location":"reference/pypty/multislice/#functions","title":"Functions","text":"<p><code>better_multislice(full_probe, this_obj_chopped, num_slices, n_obj_modes, n_probe_modes, this_distances, this_wavelength, q2, qx, qy, exclude_mask, is_single_dist, this_tan_x, this_tan_y, damping_cutoff_multislice, smooth_rolloff, master_propagator_phase_space, half_master_propagator_phase_space, mask_clean, waves_multislice, wave, default_float, default_complex)</code> :   Simulate multislice wave propagation using an additive split-step method (5th order precision with respect to slice thickness).</p> <pre><code>Parameters\n----------\nfull_probe : ndarray\n    Probe wavefunction with shape [N_batch, y,x, modes]\nthis_obj_chopped : ndarray\n    Object slices with shape [N_batch, y,x, z, modes].\nnum_slices : int\n    Number of object slices.\nn_obj_modes : int\n    Number of object modes.\nn_probe_modes : int\n    Number of probe modes.\nthis_distances : ndarray\n    Slice thicknesses.\nthis_wavelength : float\n    Electron wavelength.\nq2, qx, qy : ndarray\n    Spatial frequency grids.\nexclude_mask : ndarray\n    Mask to exclude undesired frequencies.\nis_single_dist : bool\n    If True, use the same distance for all slices.\nthis_tan_x, this_tan_y : ndarray\n    Beam tilts with shape N_batch\ndamping_cutoff_multislice : float\n    Damping frequency cutoff.\nsmooth_rolloff : float\n    Rolloff rate for the damping filter.\nmaster_propagator_phase_space : ndarray or None\n    Full propagator in Fourier space (optional).\nhalf_master_propagator_phase_space : ndarray or None\n    Half-step propagator (optional).\nmask_clean : ndarray\n    Clean propagation mask.\nwaves_multislice : ndarray\n    This array contains interediate exit-waves\nwave : ndarray\n    This array contains final exit-wave\ndefault_float, default_complex : dtype\n    Numerical types.\n\nReturns\n-------\nwaves_multislice : ndarray\n    Multislice stack of propagated waves.\nwave : ndarray\n    Final exit wave.\n</code></pre> <p><code>better_multislice_grads(dLoss_dP_out, waves_multislice, this_obj_chopped, object_grad, tilts_grad, is_single_dist, this_distances, exclude_mask, this_wavelength, q2, qx, this_tan_x, qy, this_tan_y, num_slices, n_probe_modes, n_obj_modes, tiltind, this_step_tilts, master_propagator_phase_space, half_master_propagator_phase_space, damping_cutoff_multislice, smooth_rolloff, tilt_mode, compute_batch, mask_clean, masked_pixels_y, masked_pixels_x, default_float, default_complex)</code> :   Compute gradients of object, probe, and tilts for the \"better_multislice\" wave propagation model.</p> <pre><code>Parameters\n----------\ndLoss_dP_out : ndarray\n    Gradient of the loss with respect to the final exit wave.\nwaves_multislice : ndarray\n    Stack of intermediate wavefields saved during the forward pass.\nthis_obj_chopped : ndarray\n    The sliced object with shape [batch, y, x, z, modes].\nobject_grad : ndarray\n    Gradient accumulator for the object slices.\ntilts_grad : ndarray\n    Gradient accumulator for the tilts.\nis_single_dist : bool\n    Whether all slices have the same thickness.\nthis_distances : ndarray\n    Thickness per slice.\nexclude_mask : ndarray\n    Frequency mask used in propagation.\nthis_wavelength : float\n    Wavelength of the probe in \u00c5ngstr\u00f6ms.\nq2, qx, qy : ndarray\n    Spatial frequency grids.\nthis_tan_x, this_tan_y : float\n    Beam tilt values per batch.\nnum_slices : int\n    Number of slices in the object.\nn_probe_modes : int\n    Number of probe modes.\nn_obj_modes : int\n    Number of object modes.\ntiltind : int\n    Index for updating `tilts_grad`.\nthis_step_tilts : int\n    Whether to update tilts (0 = off).\nmaster_propagator_phase_space : ndarray\n    Full propagator for the current slice.\nhalf_master_propagator_phase_space : ndarray\n    Half-step propagator.\ndamping_cutoff_multislice : float\n    Cutoff for high frequencies in damping.\nsmooth_rolloff : float\n    Smoothing width for damping filter.\ntilt_mode : int\n    Specifies which tilts to optimize.\ncompute_batch : int\n    Number of scan positions processed in batch.\nmask_clean : ndarray\n    FFT mask used to remove unstable frequencies.\nmasked_pixels_y, masked_pixels_x : ndarray\n    Indices to scatter object gradients into global coordinates.\ndefault_float : dtype\n    Floating point precision.\ndefault_complex : dtype\n    Complex precision.\n\nReturns\n-------\nobject_grad : ndarray\n    Updated gradient of the object slices.\ninterm_probe_grad : ndarray\n    Gradient of the probe (summed over object modes).\ntilts_grad : ndarray\n    Updated tilt gradients.\n</code></pre> <p><code>multislice(full_probe, this_obj_chopped, num_slices, n_obj_modes, n_probe_modes, this_distances, this_wavelength, q2, qx, qy, exclude_mask, is_single_dist, this_tan_x, this_tan_y, damping_cutoff_multislice, smooth_rolloff, master_propagator_phase_space, half_master_propagator_phase_space, mask_clean, waves_multislice, wave, default_float, default_complex)</code> :   Simulate multislice wave propagation using a classic split-step integrator (2nd order precision with respect to slice thickness if beam is optimized).</p> <pre><code>Parameters\n----------\nfull_probe : ndarray\n    Probe wavefunction with shape [N_batch, y,x, modes]\nthis_obj_chopped : ndarray\n    Object slices with shape [N_batch, y,x, z, modes].\nnum_slices : int\n    Number of object slices.\nn_obj_modes : int\n    Number of object modes.\nn_probe_modes : int\n    Number of probe modes.\nthis_distances : ndarray\n    Slice thicknesses.\nthis_wavelength : float\n    Electron wavelength.\nq2, qx, qy : ndarray\n    Spatial frequency grids.\nexclude_mask : ndarray\n    Mask to exclude undesired frequencies.\nis_single_dist : bool\n    If True, use the same distance for all slices.\nthis_tan_x, this_tan_y : ndarray\n    Beam tilts with shape N_batch\ndamping_cutoff_multislice : float\n    Damping frequency cutoff.\nsmooth_rolloff : float\n    Rolloff rate for the damping filter.\nmaster_propagator_phase_space : ndarray or None\n    Full propagator in Fourier space (optional).\nhalf_master_propagator_phase_space : ndarray or None\n    Half-step propagator (optional).\nmask_clean : ndarray\n    Clean propagation mask.\nwaves_multislice : ndarray\n    This array contains interediate exit-waves\nwave : ndarray\n    This array contains final exit-wave\ndefault_float, default_complex : dtype\n    Numerical types.\n\nReturns\n-------\nwaves_multislice : ndarray\n    Multislice stack of propagated waves.\nwave : ndarray\n    Final exit wave.\n</code></pre> <p><code>multislice_grads(dLoss_dP_out, waves_multislice, this_obj_chopped, object_grad, tilts_grad, is_single_dist, this_distances, exclude_mask, this_wavelength, q2, qx, this_tan_x, qy, this_tan_y, num_slices, n_obj_modes, tiltind, master_propagator_phase_space, this_step_tilts, damping_cutoff_multislice, smooth_rolloff, tilt_mode, compute_batch, mask_clean, this_step_probe, this_step_obj, this_step_pos_correction, masked_pixels_y, masked_pixels_x, default_float, default_complex, helper_flag_4)</code> :   Compute gradients for classic multislice propagation model (object, probe, and tilts).</p> <pre><code>Parameters\n----------\ndLoss_dP_out : ndarray\n    Gradient of the loss with respect to the final propagated wave.\nwaves_multislice : ndarray\n    Intermediate wave stack from the forward multislice pass.\nthis_obj_chopped : ndarray\n    4D sliced object [batch, y, x, z, modes].\nobject_grad : ndarray\n    Gradient accumulator for object slices.\ntilts_grad : ndarray\n    Accumulator for tilt gradients.\nis_single_dist : bool\n    If True, slice distances are constant.\nthis_distances : ndarray\n    Per-slice thicknesses.\nexclude_mask : ndarray\n    Frequency mask for FFT operations.\nthis_wavelength : float\n    Probe wavelength (\u00c5).\nq2, qx, qy : ndarray\n    Spatial frequency grids.\nthis_tan_x, this_tan_y : float\n    Beam tilt values per batch.\nnum_slices : int\n    Number of slices.\nn_obj_modes : int\n    Number of object modes.\ntiltind : int\n    Index in tilt update array.\nmaster_propagator_phase_space : ndarray\n    Full Fourier propagation kernel.\nthis_step_tilts : int\n    Whether tilt gradient is updated.\ndamping_cutoff_multislice : float\n    Damping cutoff for high-frequency noise.\nsmooth_rolloff : float\n    Width of damping transition.\ntilt_mode : int\n    Mode selector for tilt optimization.\ncompute_batch : int\n    Current batch size.\nmask_clean : ndarray\n    FFT domain mask.\nthis_step_probe : int\n    Whether to compute probe gradient.\nthis_step_obj : int\n    Whether to compute object gradient.\nthis_step_pos_correction : int\n    (Unused) Flag for positional corrections.\nmasked_pixels_y, masked_pixels_x : ndarray\n    Indices for applying gradients to global object.\ndefault_float : dtype\n    Floating-point type.\ndefault_complex : dtype\n    Complex type.\nhelper_flag_4 : bool\n    If True, return probe gradient; else return None.\n\nReturns\n-------\nobject_grad : ndarray\n    Gradient for object slices.\ninterm_probe_grad : ndarray or None\n    Gradient for input probe (if helper_flag_4 is True).\ntilts_grad : ndarray\n    Updated tilt gradient.\n</code></pre> <p><code>scatteradd(full, masky, maskx, chop)</code> :   Adds batched object updates to their respective positions in the full object array.     This wrapper is needed to support older CuPy versions.</p> <pre><code>Parameters\n----------\nfull : ndarray\n    Full object gradient array.\nmasky : ndarray\n    Index array for the y-axis.\nmaskx : ndarray\n    Index array for the x-axis.\nchop : ndarray\n    Batched gradients to scatter-add.\n\nReturns\n-------\nNone\n</code></pre> <p><code>yoshida_multislice(full_probe, this_obj_chopped, num_slices, n_obj_modes, n_probe_modes, this_distances, this_wavelength, q2, qx, qy, exclude_mask, is_single_dist, this_tan_x, this_tan_y, damping_cutoff_multislice, smooth_rolloff, master_propagator_phase_space, half_master_propagator_phase_space, mask_clean, waves_multislice, wave, default_float, default_complex)</code> :   Simulate multislice wave propagation using an yoshida integrator (5th order precision with respect to slice thickness).</p> <pre><code>Parameters\n----------\nfull_probe : ndarray\n    Probe wavefunction with shape [N_batch, y,x, modes]\nthis_obj_chopped : ndarray\n    Object slices with shape [N_batch, y,x, z, modes].\nnum_slices : int\n    Number of object slices.\nn_obj_modes : int\n    Number of object modes.\nn_probe_modes : int\n    Number of probe modes.\nthis_distances : ndarray\n    Slice thicknesses.\nthis_wavelength : float\n    Electron wavelength.\nq2, qx, qy : ndarray\n    Spatial frequency grids.\nexclude_mask : ndarray\n    Mask to exclude undesired frequencies.\nis_single_dist : bool\n    If True, use the same distance for all slices.\nthis_tan_x, this_tan_y : ndarray\n    Beam tilts with shape N_batch\ndamping_cutoff_multislice : float\n    Damping frequency cutoff.\nsmooth_rolloff : float\n    Rolloff rate for the damping filter.\nmaster_propagator_phase_space : ndarray or None\n    Full propagator in Fourier space (optional).\nhalf_master_propagator_phase_space : ndarray or None\n    Half-step propagator (optional).\nmask_clean : ndarray\n    Clean propagation mask.\nwaves_multislice : ndarray\n    This array contains interediate exit-waves\nwave : ndarray\n    This array contains final exit-wave\ndefault_float, default_complex : dtype\n    Numerical types.\n\nReturns\n-------\nwaves_multislice : ndarray\n    Multislice stack of propagated waves.\nwave : ndarray\n    Final exit wave.\n</code></pre> <p><code>yoshida_multislice_grads(dLoss_dP_out, waves_multislice, this_obj_chopped, object_grad, tilts_grad, is_single_dist, this_distances, exclude_mask, this_wavelength, q2, qx, this_tan_x, qy, this_tan_y, num_slices, n_probe_modes, n_obj_modes, tiltind, this_step_tilts, master_propagator_phase_space, half_master_propagator_phase_space, damping_cutoff_multislice, smooth_rolloff, tilt_mode, compute_batch, mask_clean, masked_pixels_y, masked_pixels_x, default_float, default_complex)</code> :   Compute gradients for object, probe, and tilt parameters using Yoshida multislice propagation.</p> <pre><code>Parameters\n----------\ndLoss_dP_out : ndarray\n    Gradient of the loss with respect to the output wave.\nwaves_multislice : ndarray\n    Stored intermediate wavefields from forward Yoshida multislice pass.\nthis_obj_chopped : ndarray\n    Object slices with shape [batch, y, x, z, modes].\nobject_grad : ndarray\n    Gradient buffer for object update.\ntilts_grad : ndarray\n    Gradient buffer for tilt update.\nis_single_dist : bool\n    Whether slice distances are constant.\nthis_distances : ndarray\n    Thickness of each slice.\nexclude_mask : ndarray\n    FFT mask for excluding unstable frequencies.\nthis_wavelength : float\n    Probe wavelength in \u00c5ngstr\u00f6ms.\nq2, qx, qy : ndarray\n    FFT spatial frequency grids.\nthis_tan_x, this_tan_y : float\n    Beam tilts (tangent of the angle).\nnum_slices : int\n    Number of object slices.\nn_probe_modes : int\n    Number of probe modes.\nn_obj_modes : int\n    Number of object modes.\ntiltind : int\n    Index of current tilt in `tilts_grad`.\nthis_step_tilts : int\n    Whether tilt updates are enabled.\nmaster_propagator_phase_space : ndarray\n    Full propagation kernel in Fourier domain.\nhalf_master_propagator_phase_space : ndarray\n    Half-step propagation kernel.\ndamping_cutoff_multislice : float\n    Frequency cutoff for damping high frequencies.\nsmooth_rolloff : float\n    Rolloff profile width for damping.\ntilt_mode : int\n    Determines which tilt parameters to optimize.\ncompute_batch : int\n    Number of scan points in the current batch.\nmask_clean : ndarray\n    Fourier domain mask to stabilize calculations.\nmasked_pixels_y, masked_pixels_x : ndarray\n    Indices for inserting gradients into global object.\ndefault_float : dtype\n    Float precision.\ndefault_complex : dtype\n    Complex precision.\n\nReturns\n-------\nobject_grad : ndarray\n    Updated object gradient.\ninterm_probe_grad : ndarray\n    Gradient of the probe (combined over object modes).\ntilts_grad : ndarray\n    Updated tilt gradient.\n</code></pre>"},{"location":"reference/pypty/signal_extraction/","title":"Module pypty.signal_extraction","text":""},{"location":"reference/pypty/signal_extraction/#functions","title":"Functions","text":"<p><code>compensate_pattern_drift(aperture, patterns)</code> :   Compensate for drift in diffraction patterns via phase correlation.</p> <pre><code>Parameters\n----------\naperture : ndarray\n    The binary aperture mask used for phase correlation.\npatterns : ndarray\n    The diffraction patterns to be compensated for drift.\n\nReturns\n-------\npatterns : ndarray\n    The compensated diffraction patterns.\n</code></pre> <p><code>create_binned_dataset(path_orig, path_new, bin)</code> :   Downsample a dataset by spatial binning and save it to a new file.</p> <pre><code>Parameters\n----------\npath_orig : str\n    The file path of the original dataset.\npath_new : str\n    The file path to save the binned dataset.\nbin : int\n    The binning factor to downsample the dataset.\n</code></pre> <p><code>get_aperture(params)</code> :   Generate a binary aperture mask based on the mean diffraction pattern.</p> <pre><code>Parameters\n----------\nparams : dict\n    Dictionary containing parameters including data path, data padding, plotting option, and bright threshold.\n\nReturns\n-------\nparams : dict\n    Updated parameters dictionary containing the generated aperture mask.\n</code></pre> <p><code>get_virtual_annular_detector(pypty_params, inner_rad=0, outer_rad=1, save=False, offset_x=0, offset_y=0)</code> :   Create virtual detector signals from annular masks.</p> <pre><code>Parameters\n----------\npypty_params : dict\n    Dictionary containing parameters including data path, scan size, plotting option, and output folder.\ninner_rad : float, optional\n    Inner radius of the annular mask. Default is 0.\nouter_rad : float, optional\n    Outer radius of the annular mask. Default is 1.\nsave : bool, optional\n    Whether to save the resulting virtual detector signal as a .npy file. Default is False.\noffset_x : float, optional\n    X-offset for the annular mask. Default is 0.\noffset_y : float, optional\n    Y-offset for the annular mask. Default is 0.\n\nReturns\n-------\nsignal : ndarray\n    The computed virtual detector signal.\n</code></pre> <p><code>getvirtualhaadf(pypty_params, save=True)</code> :   Compute a virtual HAADF image from a 4D-STEM dataset.</p> <pre><code>Parameters\n----------\npypty_params : dict\n    Dictionary containing parameters including data path, scan size, plotting option, and output folder.\nsave : bool, optional\n    Whether to save the resulting HAADF image as a .npy file. Default is True.\n\nReturns\n-------\nhaadf : ndarray\n    The computed virtual HAADF image.\n</code></pre>"},{"location":"reference/pypty/tcbf/","title":"Module pypty.tcbf","text":""},{"location":"reference/pypty/tcbf/#functions","title":"Functions","text":"<p><code>run_tcbf_alignment(params, binning_for_fit=[8], save=True, optimize_angle=True, aberrations=None, n_aberrations_to_fit=12, reference_type='bf', refine_box_dim=10, upsample=3, cross_corr_type='phase', cancel_large_shifts=None, pattern_blur_width=None, scan_pad=None, aperture=None, subscan_region=None, compensate_lowfreq_drift=False, append_lowfreq_shifts_to_params=True, interpolate_scan_factor=1, binning_cross_corr=1, phase_cross_corr_formula=False, f_scale_lsq=1, x_scale_lsq=1, loss_lsq='linear', tol_ctf=1e-08)</code> :   Align and fit the beam contrast transfer function (CTF) using 4D-STEM data.</p> <pre><code>This function estimates beam aberrations by aligning individual pixel images using \ncross-correlation and fitting a CTF model. It supports iterative fitting with various \nbinning levels and options for low-frequency drift compensation.\n\nParameters\n----------\nparams : dict\n    Dictionary containing PyPTY experimental and reconstruction settings.\nbinning_for_fit : list of int, optional\n    List of binning factors for each iteration of the CTF fit.\nsave : bool, optional\n    Whether to save intermediate tcBF images and shift estimates.\noptimize_angle : bool, optional\n    Whether to include probe rotation angle in the fit.\naberrations : list or None, optional\n    Initial guess for aberrations. If None, `n_aberrations_to_fit` zeros will be used.\nn_aberrations_to_fit : int, optional\n    Number of aberrations to fit if no initial guess is provided.\nreference_type : str, optional\n    Reference used for cross-correlation (\"bf\" or \"zero\").\nrefine_box_dim : int, optional\n    Radius (in pixels) of the interpolation box for sub-pixel shift refinement.\nupsample : int, optional\n    Factor for refining cross-correlation to estimate sub-pixel shifts.\ncross_corr_type : str, optional\n    Type of cross-correlation to use (\"phase\" or \"classical\").\ncancel_large_shifts : float or None, optional\n    Threshold (0\u20131) to ignore large shift outliers in the fit.\npattern_blur_width : int or None, optional\n    Radius for optional circular blur mask applied to patterns.\nscan_pad : int or None, optional\n    Number of scan pixels to pad around the dataset (auto if None).\naperture : ndarray or None, optional\n    Aperture mask. If None, attempts to extract from parameters.\nsubscan_region : list or None, optional\n    Subregion for CTF fitting: [left, top, right, bottom].\ncompensate_lowfreq_drift : bool, optional\n    Whether to compensate for pattern drift in large FOVs.\nappend_lowfreq_shifts_to_params : bool, optional\n    Whether to store low-frequency drift corrections in `params`.\ninterpolate_scan_factor : int, optional\n    Factor to upsample the scan via interpolation (experimental).\nbinning_cross_corr : int, optional\n    Binning factor before peak detection in cross-correlation.\nphase_cross_corr_formula : bool, optional\n    Use analytical peak refinement formula for phase correlation.\nf_scale_lsq : float, optional\n    Scaling factor for residuals in `least_squares`.\nx_scale_lsq : float, optional\n    Scaling for initial step size in `least_squares`.\nloss_lsq : str, optional\n    Loss function for `least_squares` optimization.\ntol_ctf : float, optional\n    Tolerance (`ftol`) for stopping criterion in optimization.\n\nReturns\n-------\npypty_params : dict\n    Updated parameter dictionary with fitted aberrations, defocus, and potentially\n    updated scan positions and rotation.\nNotes\n-----\n- Requires a scan dataset and optionally a precomputed aperture mask.\n- Intermediate results and diagnostics can be saved to disk if `save` is True.\n</code></pre> <p><code>run_tcbf_compressed_alignment(params, num_iterations, save=True, optimize_angle=True, aberrations=None, n_aberrations_to_fit=12, reference_type='bf', refine_box_dim=10, upsample=3, cross_corr_type='phase', cancel_large_shifts=None, pattern_blur_width=None, scan_pad=None, aperture=None, subscan_region=None, compensate_lowfreq_drift=False, append_lowfreq_shifts_to_params=True, interpolate_scan_factor=1, binning_cross_corr=1, phase_cross_corr_formula=False, f_scale_lsq=1, x_scale_lsq=1, loss_lsq='linear', tol_ctf=1e-08)</code> :   Perform a CTF alignment using compressed 4D-STEM data and masked bright-field regions.</p> <pre><code>This function fits the beam CTF to the shifts between the individual pixel images of the 4d-stem dataset. It's the same as run_tcbf_alignment, but for compressed data. The shift estimation is done via cross-correaltion.\n\nParameters\n----------\nparams : dict\n    Dictionary containing experimental and reconstruction settings.\nnum_iterations : int\n    Number of fitting iterations to perform.\nsave : bool, optional\n    Whether to save intermediate tcBF images and shift maps. Default is True.\noptimize_angle : bool, optional\n    Whether to include probe rotation angle in the CTF fit. Default is True.\naberrations : list or None, optional\n    Initial guess for the aberration coefficients. If None, it will be inferred or zero-initialized.\nn_aberrations_to_fit : int, optional\n    Number of aberration coefficients to fit if `aberrations` is not provided. Default is 12.\nreference_type : str, optional\n    \"bf\" to use the tcBF image as a reference, \"zero\" to use the central pixel. Default is \"bf\".\nrefine_box_dim : int, optional\n    Size of the cropped region around the cross-correlation peak for sub-pixel refinement. Default is 10.\nupsample : int, optional\n    Upsampling factor for sub-pixel interpolation. Default is 3.\ncross_corr_type : str, optional\n    Cross-correlation method: \"phase\" (recommended) or \"classic\". Default is \"phase\".\ncancel_large_shifts : float or None, optional\n    Threshold to reject large shift outliers during fitting. Value between 0 and 1. Default is None.\npattern_blur_width : int or None, optional\n    Width of blur kernel for patterns prior to analysis. Default is None.\nscan_pad : int or None, optional\n    Number of scan pixels to pad around the scan to prevent wrap-around. Default is auto.\naperture : ndarray or None, optional\n    Aperture mask defining pixels to analyze. If None, it will be loaded from `params`.\nsubscan_region : list or None, optional\n    Optional subregion [left, top, right, bottom] on which to perform the alignment. Default is None.\ncompensate_lowfreq_drift : bool, optional\n    Whether to compute and correct for slow drifting of the aperture over time. Default is False.\nappend_lowfreq_shifts_to_params : bool, optional\n    If True, saves the low-frequency correction back into `params`. Default is True.\ninterpolate_scan_factor : int, optional\n    Experimental: interpolate scan grid by this factor (e.g., 2 for 2x upsampled grid). Default is 1.\nbinning_cross_corr : int, optional\n    Binning factor applied to cross-correlation maps before refinement. Default is 1.\nphase_cross_corr_formula : bool, optional\n    If True, uses analytical subpixel peak estimation for phase correlation. Default is False.\nf_scale_lsq : float, optional\n    Scaling factor for least squares residuals (`f_scale`). Default is 1.\nx_scale_lsq : float, optional\n    Initial step scaling (`x_scale`) for least squares. Default is 1.\nloss_lsq : str, optional\n    Loss type for least squares optimizer. E.g., \"linear\", \"huber\". Default is \"linear\".\ntol_ctf : float, optional\n    Tolerance for optimizer convergence (`ftol`). Default is 1e-8.\n\nReturns\n-------\npypty_params : dict\n    Updated dictionary of reconstruction parameters including fitted aberrations and scan rotation.\n\nNotes\n-----\n- Requires masks to define the compressed bright field regions.\n</code></pre> <p><code>upsampled_tcbf(pypty_params, upsample=5, pad=10, compensate_lowfreq_drift=False, default_float=64, round_shifts=False, xp=&lt;module 'numpy' from '/Users/anton/miniconda/lib/python3.10/site-packages/numpy/__init__.py'&gt;, save=0, max_parallel_fft=100, bin_fac=1)</code> :   Perform an upsampled tcBF (transmission coherent Bright Field) reconstruction.</p> <pre><code>This function reconstructs a tcBF image on an upsampled scan grid from 4D-STEM data.\nIt applies Fourier-based shifts to align the bright field pixel images and combines them into a final image.\nPrior to calling this function, it is recommended to run the tcBF alignment routine to update `pypty_params`.\n\nParameters\n----------\npypty_params : dict\n    Dictionary containing experimental parameters and reconstruction settings.\n    This should include keys such as 'data_path', 'scan_size', 'aperture_mask', 'acc_voltage', etc.\nupsample : int, optional\n    Upsampling factor for the scan grid. Default is 5.\npad : int, optional\n    Number of additional scan positions to pad on each side to avoid wrap-around artifacts.\n    Default is 10.\ncompensate_lowfreq_drift : bool, optional\n    If True, compensates for low-frequency drift of the aperture.\n    Requires that run_tcbf_alignment has been executed to provide drift corrections.\n    Default is False.\ndefault_float : {64, 32}, optional\n    Precision for floating point computations. Use 64 for higher precision or 32 for lower memory usage.\n    Default is 64.\nround_shifts : bool, optional\n    If True, shifts are rounded and alignment is performed using array roll operations.\n    If False, FFT-based subpixel shifting is used. Default is False.\nxp : module, optional\n    Backend array module (e.g., numpy or cupy). Default is cupy.\nsave : bool or int, optional\n    Flag to save the output image. If True, the image is saved to disk.\n    Ignored if 'save_preprocessing_files' is set in `pypty_params`. Default is 0 (False).\nmax_parallel_fft : int, optional\n    Maximum number of FFTs to perform in parallel for vectorized processing.\n    Default is 100.\nbin_fac : int, optional\n    Binning factor for the data in reciprocal space. Default is 1 (no binning).\n\nReturns\n-------\nO_r : ndarray\n    Real-valued tcBF image reconstructed on the upsampled grid.\npx_size_final : float\n    Final pixel size in \u00c5ngstr\u00f6ms after upsampling.\n</code></pre>"},{"location":"reference/pypty/utils/","title":"Module pypty.utils","text":""},{"location":"reference/pypty/utils/#functions","title":"Functions","text":"<p><code>apply_defocus_probe(probe, distance, acc_voltage, pixel_size_x_A, pixel_size_y_A, default_complex, default_float, xp)</code> :   Apply a defocus phase shift to a probe in Fourier space.</p> <pre><code>Parameters\n----------\nprobe : ndarray\n    The input probe wavefunction.\ndistance : float\n    Defocus distance in meters.\nacc_voltage : float\n    Acceleration voltage in kiloelectronvolts (keV).\npixel_size_x_A : float\n    Pixel size along x in angstroms.\npixel_size_y_A : float\n    Pixel size along y in angstroms.\ndefault_complex : dtype\n    Complex data type for computation.\ndefault_float : dtype\n    Float data type for computation.\nxp : module\n    Numerical backend (NumPy or CuPy).\n\nReturns\n-------\nndarray\n    The defocused probe.\n</code></pre> <p><code>apply_probe_modulation(probe, extra_probe_defocus, acc_voltage, pixel_size_x_A, pixel_size_y_A, aberrations, print_flag, beam_ctf, n_hermite_probe_modes, defocus_spread_modes, probe_marker, default_complex, default_float, xp)</code> :   Apply defocus, aberrations, Hermite mode generation, and other modulations to the probe.</p> <pre><code>Parameters\n----------\nprobe : ndarray\n    Initial probe.\nextra_probe_defocus : float\n    Defocus distance to apply.\nacc_voltage : float\n    Accelerating voltage in keV.\npixel_size_x_A : float\n    Pixel size in x (\u00c5).\npixel_size_y_A : float\n    Pixel size in y (\u00c5).\naberrations : list or ndarray\n    List of aberration coefficients.\nprint_flag : bool\n    Whether to print info.\nbeam_ctf : ndarray or None\n    Optional beam CTF to apply.\nn_hermite_probe_modes : tuple or None\n    Number of Hermite modes in (y, x).\ndefocus_spread_modes : list or None\n    Defocus values to generate additional modes.\nprobe_marker : ndarray or None\n    Probe assignment array for multi-scenario.\ndefault_complex : dtype\n    Complex type.\ndefault_float : dtype\n    Float type.\nxp : module\n    Numerical backend.\n\nReturns\n-------\nndarray\n    Modulated probe array.\n</code></pre> <p><code>complex_grad_to_mag_grad(grad, abs, phase)</code> :   Calculate a magnitude gradient from a complex gradient and separate magnitude and phase arrays.</p> <pre><code>Parameters\n----------\ngrad : array_like\n    The complex gradient.\nabs : array_like\n    The magnitude array.\nphase : array_like\n    The phase array.\n\nReturns\n-------\narray_like\n    The magnitude gradient.\n</code></pre> <p><code>complex_grad_to_phase_abs_grad(grad, array)</code> :   Compute the phase gradient and negative amplitude gradient from a complex gradient.</p> <pre><code>Parameters\n----------\ngrad : array_like\n    The Wirtinger derivative (dL/dz*).\narray : array_like\n    The complex array (z = exp(-a + i*phase)).\n\nReturns\n-------\ntuple of array_like\n    A tuple containing:\n    - Phase gradient (dL/dp).\n    - Negative amplitude gradient (dL/da).\n</code></pre> <p><code>complex_grad_to_phase_grad(grad, array)</code> :   Convert a Wirtinger derivative to the gradient with respect to the phase.</p> <pre><code>Parameters\n----------\ngrad : array_like\n    The Wirtinger derivative (dL/dz*).\narray : array_like\n    The complex array (z = |z| exp(i*phase)).\n\nReturns\n-------\narray_like\n    The phase gradient (dL/dp).\n</code></pre> <p><code>construct_update_abs_proto_phase(object_grad, obj)</code> :   Compute object updates projected along phase gradients.</p> <pre><code>Parameters\n----------\nobject_grad : array_like\n    The gradient of the object.\nobj : array_like\n    The current object array.\n\nReturns\n-------\narray_like\n    The computed update for the object.\n</code></pre> <p><code>convert_num_to_nmab(num_abs)</code> :   Convert a number of aberration terms to (n, m, ab) indices based on Krivanek notation.</p> <pre><code>Parameters\n----------\nnum_abs : int\n    Number of aberration coefficients.\n\nReturns\n-------\ntuple of lists\n    Lists of n, m, and ab strings ('', 'a', or 'b') for each aberration mode.\n</code></pre> <p><code>convert_to_nxs(folder_path, output_file)</code> :   Convert saved PyPty reconstruction data to NeXus (.nxs) format.</p> <pre><code>Parameters\n----------\nfolder_path : str\n    Directory containing saved reconstruction files.\noutput_file : str\n    Path where the NeXus file will be saved.\n\nReturns\n-------\nNone\n</code></pre> <p><code>convert_to_string(dicti2, strip_dataset_from_params=True)</code> :   Convert parameter dictionary to string format, including lambda serialization.</p> <pre><code>Parameters\n----------\ndicti2 : dict\n    Original parameter dictionary.\nstrip_dataset_from_params : bool, optional\n    Whether to exclude 'dataset' key (default is True).\n\nReturns\n-------\ndict\n    Dictionary with string values.\n</code></pre> <p><code>create_probe_from_nothing(probe, data_pad, mean_pattern, aperture_mask, tilt_mode, tilts, dataset, estimate_aperture_based_on_binary, pixel_size_x_A, acc_voltage, data_multiplier, masks, data_shift_vector, data_bin, upsample_pattern, default_complex_cpu, print_flag, algorithm, measured_data_shape, n_obj_modes, probe_marker, recon_type, defocus_array, Cs)</code> :   Generate an initial probe guess when no valid probe is provided.</p> <pre><code>Depending on the input, this function either uses an aperture mask, computes a mean pattern\nfrom the dataset, or adjusts an existing mean pattern to generate a probe. It applies shifting,\nbinning, padding, and scaling to produce a probe suitable for the specified reconstruction type.\n\nParameters\n----------\nprobe : ndarray, str, or None\n    Input probe. If set to \"aperture\", the aperture mask is used. If None, the probe is generated\n    based on the mean pattern.\ndata_pad : int\n    Padding size applied to the data.\nmean_pattern : ndarray or None\n    Mean pattern used to generate the probe if no probe is provided.\naperture_mask : ndarray\n    Aperture mask used when probe is set to \"aperture\".\ntilt_mode : bool\n    Flag indicating if tilt mode is active.\ntilts : ndarray\n    Tilt values.\ndataset : ndarray\n    Measured dataset.\nestimate_aperture_based_on_binary : bool or float\n    Factor used to threshold the dataset for aperture estimation.\npixel_size_x_A : float\n    Pixel size in the x-direction in angstroms.\nacc_voltage : float\n    Acceleration voltage in keV.\ndata_multiplier : float\n    Factor to scale the data intensity.\nmasks : ndarray or None\n    Optional masks to apply to the mean pattern.\ndata_shift_vector : list or tuple of int\n    Vector indicating the shift to be applied to the data.\ndata_bin : int\n    Binning factor.\nupsample_pattern : int\n    Upsampling factor applied to the pattern.\ndefault_complex_cpu : dtype\n    Complex data type for CPU computations.\nprint_flag : int\n    Flag controlling verbosity.\nalgorithm : str\n    Identifier for the reconstruction algorithm.\nmeasured_data_shape : tuple\n    Shape of the measured data.\nn_obj_modes : int\n    Number of object modes.\nprobe_marker : ndarray or None\n    Marker array for probe scenarios.\nrecon_type : str\n    Type of reconstruction (\"near_field\" or \"far_field\").\ndefocus_array : ndarray\n    Array of defocus values.\nCs : float\n    Spherical aberration coefficient.\n\nReturns\n-------\nndarray\n    The generated probe as a complex array.\n</code></pre> <p><code>create_spatial_frequencies(px, py, shape, damping_cutoff_multislice, smooth_rolloff, default_float)</code> :   Generate spatial frequency grids and corresponding masks for multislice simulations.</p> <pre><code>Parameters\n----------\npx : float\n    Pixel size in the x-direction.\npy : float\n    Pixel size in the y-direction.\nshape : int\n    Size of the grid.\ndamping_cutoff_multislice : float\n    Damping cutoff factor for multislice simulations.\nsmooth_rolloff : float\n    Smoothing rolloff parameter.\ndefault_float : data-type\n    Data type for computations.\n\nReturns\n-------\ntuple\n    Tuple containing:\n    - q2: 2D array of squared spatial frequencies.\n    - qx: 2D array of spatial frequencies in x.\n    - qy: 2D array of spatial frequencies in y.\n    - exclude_mask: Mask in Fourier space.\n    - exclude_mask_ishift: Unshifted mask.\n</code></pre> <p><code>create_static_background_from_nothing(static_background, probe, damping_cutoff_multislice, data_pad, upsample_pattern, default_float, recon_type)</code> :   Generate an initial static background if none is provided.</p> <pre><code>Parameters\n----------\nstatic_background : float or ndarray\n    Initial static background value or None.\nprobe : ndarray\n    Probe wavefunction.\ndamping_cutoff_multislice : float\n    Maximum spatial frequency used.\ndata_pad : int\n    Padding to be applied.\nupsample_pattern : int\n    Upsampling factor used.\ndefault_float : dtype\n    Data type for output.\nrecon_type : str\n    Type of reconstruction ('near_field' or 'far_field').\n\nReturns\n-------\nndarray\n    Initialized static background.\n</code></pre> <p><code>delete_dataset_from_params(params_path)</code> :   Delete the 'dataset' key from saved parameter file.</p> <pre><code>Parameters\n----------\nparams_path : str\n    Path to the pickled parameters file.\n\nReturns\n-------\nNone\n</code></pre> <p><code>downsample_something(something, upsample, xp)</code> :   Downsample a 2D array.</p> <pre><code>Parameters\n----------\nsomething : ndarray\n    The 2D array to be downsampled.\nupsample : int\n    Downsampling factor.\nxp : module\n    Array module, e.g., numpy or cupy.\n\nReturns\n-------\nndarray\n    The downsampled array.\n</code></pre> <p><code>downsample_something_3d(something, upsample, xp)</code> :   Downsample a 3D array along the last two axes.</p> <pre><code>Parameters\n----------\nsomething : ndarray\n    The 3D array to be downsampled.\nupsample : int\n    Downsampling factor.\nxp : module\n    Array module, e.g., numpy or cupy.\n\nReturns\n-------\nndarray\n    The downsampled 3D array.\n</code></pre> <p><code>fourier_clean(array, cutoff=0.66, mask=None, rolloff=0, default_float=numpy.float32, xp=&lt;module 'numpy' from '/Users/anton/miniconda/lib/python3.10/site-packages/numpy/__init__.py'&gt;)</code> :   Apply a Fourier filter to the input array. Supports 2D or 3D arrays.</p> <pre><code>Parameters\n----------\narray : array_like\n    Input array (2D or 3D) to be filtered.\ncutoff : float, optional\n    Cutoff frequency (default is 0.66).\nmask : array_like or None, optional\n    Predefined mask to apply. If None, a mask is generated.\nrolloff : float, optional\n    Rolloff parameter for smoothing the mask (default is 0).\ndefault_float : data-type, optional\n    Data type for computations (default is cp.float32).\nxp : module, optional\n    Array module (default is cp).\n\nReturns\n-------\narray_like\n    The filtered array after applying the Fourier filter.\n</code></pre> <p><code>fourier_clean_3d(array, cutoff=0.66, mask=None, rolloff=0, default_float=numpy.float32, xp=&lt;module 'numpy' from '/Users/anton/miniconda/lib/python3.10/site-packages/numpy/__init__.py'&gt;)</code> :   Apply a 3D Fourier filter to the input array.</p> <pre><code>Parameters\n----------\narray : array_like\n    Input 3D array to be filtered.\ncutoff : float, optional\n    Cutoff frequency (default is 0.66).\nmask : array_like or None, optional\n    Predefined mask to apply. If None, a mask is generated.\nrolloff : float, optional\n    Rolloff parameter for smoothing the mask (default is 0).\ndefault_float : data-type, optional\n    Data type for computations (default is cp.float32).\nxp : module, optional\n    Array module (default is cp).\n\nReturns\n-------\narray_like\n    The filtered array after applying the Fourier filter.\n</code></pre> <p><code>generate_hermite_modes(main_mode, n_herm_x, n_herm_y, default_complex, xp)</code> :   Generate Hermite polynomial-based probe modes from a main mode.</p> <pre><code>Parameters\n----------\nmain_mode : ndarray\n    The main probe mode.\nn_herm_x : int\n    Max Degree of Hermite polynomials in x.\nn_herm_y : int\n    Max Degree of Hermite polynomials in y.\ndefault_complex : dtype\n    Complex data type to use.\nxp : module\n    Numerical backend.\n\nReturns\n-------\nndarray\n    Stack of Hermite-based probe modes.\n</code></pre> <p><code>generate_mask_for_grad_from_pos(shapex, shapey, positions_list, shape_footprint_x, shape_footprint_y, shrink=0)</code> :   Construct a binary mask from given positions and footprint dimensions.</p> <pre><code>Parameters\n----------\nshapex : int\n    Width of the mask.\nshapey : int\n    Height of the mask.\npositions_list : list of tuple\n    List of (y, x) positions where the mask should be activated.\nshape_footprint_x : int\n    Footprint width.\nshape_footprint_y : int\n    Footprint height.\nshrink : int, optional\n    Shrink factor to adjust the footprint (default is 0).\n\nReturns\n-------\narray_like\n    The constructed binary mask.\n</code></pre> <p><code>get_compute_batch(compute_batch, load_one_by_one, hist_size, measured_data_shape, memory_saturation, smart_memory, data_pad, obj_shape, probe_shape, dtype, propmethod, print_flag)</code> :   Estimate the optimal compute batch size based on GPU memory usage.</p> <pre><code>Parameters\n----------\ncompute_batch : int\n    Initial guess or default.\nload_one_by_one : bool\n    Whether data is streamed instead of fully loaded.\nhist_size : int\n    History size for optimizers.\nmeasured_data_shape : tuple\n    Shape of the input dataset.\nmemory_saturation : float\n    Proportion of GPU memory to use.\nsmart_memory : callable or bool\n    User-provided memory strategy.\ndata_pad : int\n    Padding applied to data.\nobj_shape : tuple\n    Shape of the object array.\nprobe_shape : tuple\n    Shape of the probe array.\ndtype : str\n    Data type string ('single' or 'double').\npropmethod : str\n    Propagation method name.\nprint_flag : int\n    Verbosity.\n\nReturns\n-------\ntuple\n    Suggested batch size, load_one_by_one flag, and memory strategy.\n</code></pre> <p><code>get_ctf(aberrations, kx, ky, wavelength, angle_offset=0)</code> :   Compute the scalar contrast transfer function (CTF) from aberrations.</p> <pre><code>Parameters\n----------\naberrations : list or ndarray\n    List of aberration coefficients.\nkx : ndarray\n    Spatial frequency in x-direction.\nky : ndarray\n    Spatial frequency in y-direction.\nwavelength : float\n    Electron wavelength.\nangle_offset : float, optional\n    Additional rotation angle in radians (default is 0).\n\nReturns\n-------\nndarray\n    The computed CTF.\n</code></pre> <p><code>get_ctf_derivatives(aberrations, kx, ky, wavelength, angle_offset=0)</code> :   Compute spatial derivatives of the CTF with respect to kx and ky.</p> <pre><code>Parameters\n----------\naberrations : list or ndarray\n    List of aberration coefficients.\nkx : ndarray\n    Spatial frequency in x-direction.\nky : ndarray\n    Spatial frequency in y-direction.\nwavelength : float\n    Electron wavelength.\nangle_offset : float, optional\n    Additional rotation angle (default is 0).\n\nReturns\n-------\ntuple of ndarray\n    Derivatives of CTF with respect to kx and ky.\n</code></pre> <p><code>get_ctf_gradient_rotation_angle(aberrations, kx, ky, wavelength, angle_offset=0)</code> :   Compute the gradient of the phase with respect to rotation angle.</p> <pre><code>Parameters\n----------\naberrations : list or ndarray\n    List of aberration coefficients.\nkx : ndarray\n    Spatial frequency in x-direction.\nky : ndarray\n    Spatial frequency in y-direction.\nwavelength : float\n    Electron wavelength.\nangle_offset : float, optional\n    Additional angular offset (default is 0).\n\nReturns\n-------\ntuple of ndarray\n    Derivatives of the CTF gradient in x and y directions with respect to angular change.\n</code></pre> <p><code>get_ctf_matrix(kx, ky, num_abs, wavelength, xp=&lt;module 'numpy' from '/Users/anton/miniconda/lib/python3.10/site-packages/numpy/__init__.py'&gt;)</code> :   Generate a matrix of phase contributions for all aberration modes.</p> <pre><code>Parameters\n----------\nkx : ndarray\n    Spatial frequency in x-direction.\nky : ndarray\n    Spatial frequency in y-direction.\nnum_abs : int\n    Number of aberration coefficients.\nwavelength : float\n    Electron wavelength.\nxp : module, optional\n    Array module (default is cupy).\n\nReturns\n-------\nndarray\n    list of Zernike polynomials (num_abs, height, width) with phase contributions.\n</code></pre> <p><code>get_cupy_memory_usage()</code> :   Print current CuPy GPU memory usage statistics.</p> <pre><code>Returns\n-------\nNone\n</code></pre> <p><code>get_steps_epoch(steps, epoch, default_float)</code> :   Evaluate step values for the current epoch.</p> <pre><code>Parameters\n----------\nsteps : list\n    List of (multiplier, callable) or fixed values.\nepoch : int\n    Current training epoch.\ndefault_float : dtype\n    Float precision type.\n\nReturns\n-------\nlist\n    List of step values.\n</code></pre> <p><code>get_value_for_epoch(func_or_value, epoch, default_float)</code> :   Evaluate a list of values or functions at the current epoch.</p> <pre><code>Parameters\n----------\nfunc_or_value : list\n    List of fixed values or callables.\nepoch : int\n    Current epoch number.\ndefault_float : dtype\n    Float precision type.\n\nReturns\n-------\nlist\n    Evaluated values.\n</code></pre> <p><code>get_window(shape, r0, r_max, inverted=True)</code> :   Create a circular cosine-tapered window mask.</p> <pre><code>Parameters\n----------\nshape : int\n    Size of the square window.\nr0 : float\n    Inner radius where tapering begins (normalized).\nr_max : float\n    Outer radius where mask falls to zero (normalized).\ninverted : bool, optional\n    If True, returns 1 - mask (default is True).\n\nReturns\n-------\nndarray\n    A 2D mask array of the specified shape.\n</code></pre> <p><code>lambda_to_string(f)</code> :   Extract lambda function source as a string.</p> <pre><code>Parameters\n----------\nf : function\n    Lambda function.\n\nReturns\n-------\nstr\n    Extracted string source of the lambda.\n</code></pre> <p><code>load_nexus_params(path_nexus)</code> :   Load reconstruction parameters from a NeXus (.nxs) HDF5 file.</p> <pre><code>Parameters\n----------\npath_nexus : str\n    Path to the .nxs file.\n\nReturns\n-------\ndict\n    Dictionary of extracted parameters.\n</code></pre> <p><code>load_params(path)</code> :   Load parameter dictionary from a .pkl file.</p> <pre><code>Parameters\n----------\npath : str\n    Path to the .pkl parameter file.\n\nReturns\n-------\ndict\n    Loaded parameters.\n</code></pre> <p><code>nmab_to_strings(possible_n, possible_m, possible_ab)</code> :   Convert aberration indices into string identifiers in Krivanek notation.</p> <pre><code>Parameters\n----------\npossible_n : list of int\n    List of radial indices.\npossible_m : list of int\n    List of azimuthal indices.\npossible_ab : list of str\n    List of aberration mode types ('', 'a', 'b').\n\nReturns\n-------\nlist of str\n    List of formatted aberration identifiers like 'C30a', 'C11', etc.\n</code></pre> <p><code>padfft(array, pad)</code> :   Pad the input array in Fourier space by padding its FFT.</p> <pre><code>Parameters\n----------\narray : ndarray\n    Input array to be padded.\npad : int\n    Number of pixels to pad on each side.\n\nReturns\n-------\nndarray\n    The padded array in spatial domain.\n</code></pre> <p><code>padprobetodatafarfield(probe, measured_data_shape, data_pad, upsample_pattern)</code> :   Pad or crop a probe in Fourier space to match far-field data dimensions.</p> <pre><code>Parameters\n----------\nprobe : ndarray\n    The probe wavefunction.\nmeasured_data_shape : tuple\n    Shape of the measured data.\ndata_pad : int\n    Padding applied to the data.\nupsample_pattern : int\n    Upsampling factor used in the reconstruction.\n\nReturns\n-------\nndarray\n    Adjusted probe wavefunction.\n</code></pre> <p><code>padprobetodatanearfield(probe, measured_data_shape, data_pad, upsample_pattern)</code> :   Pad or crop a probe for near-field reconstruction.</p> <pre><code>This function adjusts the probe wavefunction by padding or cropping it to match the\nnear-field measured data dimensions after upsampling and padding.\n\nParameters\n----------\nprobe : ndarray\n    The input probe wavefunction.\nmeasured_data_shape : tuple\n    Shape of the measured data.\ndata_pad : int\n    Padding size applied to the data.\nupsample_pattern : int\n    Upsampling factor applied to the measured data.\n\nReturns\n-------\nndarray\n    The adjusted probe wavefunction.\n</code></pre> <p><code>phase_cross_corr_align(im_ref_fft, im_2_fft, refine_box_dim, upsample, x_real, y_real, shift_y=None, shift_x=None)</code> :   Align two FFT-transformed images using phase cross-correlation.</p> <pre><code>Parameters\n----------\nim_ref_fft : ndarray\n    Reference image FFT.\nim_2_fft : ndarray\n    FFT of the image to be aligned.\nrefine_box_dim : int\n    Size of the interpolation box for sub-pixel alignment.\nupsample : int\n    Upsampling factor for interpolation.\nx_real : ndarray\n    Real space x grid.\ny_real : ndarray\n    Real space y grid.\nshift_y : float or None\n    Predefined shift in y (optional).\nshift_x : float or None\n    Predefined shift in x (optional).\n\nReturns\n-------\nndarray\n    Shifted FFT of the second image.\n</code></pre> <p><code>prepare_main_loop_params(algorithm, probe, obj, positions, tilts, measured_data_shape, acc_voltage, allow_subPixel_shift=True, sequence=None, use_full_FOV=False, print_flag=0, default_float_cpu=numpy.float64, default_complex_cpu=numpy.complex128, default_int_cpu=numpy.int64, probe_constraint_mask=None, aperture_mask=None, extra_space_on_side_px=0)</code> :   Prepare main loop parameters for reconstruction.</p> <pre><code>This function adjusts scan positions, pads the object if necessary, handles subpixel corrections,\nand computes the electron wavelength based on the accelerating voltage.\n\nParameters\n----------\nalgorithm : any\n    Identifier for the reconstruction algorithm.\nprobe : ndarray\n    The probe array.\nobj : ndarray\n    The object array.\npositions : ndarray\n    Array of scan positions.\ntilts : ndarray\n    Array of tilt angles.\nmeasured_data_shape : tuple\n    Shape of the measured data.\nacc_voltage : float\n    Accelerating voltage in keV.\nallow_subPixel_shift : bool, optional\n    If True, compute subpixel corrections (default is True).\nsequence : list or callable, optional\n    Sequence of indices for positions (default is None, which uses full range).\nuse_full_FOV : bool, optional\n    If True, use full field-of-view adjustments (default is False).\nprint_flag : int, optional\n    Verbosity flag (default is 0).\ndefault_float_cpu : data-type, optional\n    Float data type for CPU computations (default is np.float64).\ndefault_complex_cpu : data-type, optional\n    Complex data type for CPU computations (default is np.complex128).\ndefault_int_cpu : data-type, optional\n    Integer data type for CPU computations (default is np.int64).\nprobe_constraint_mask : ndarray or None, optional\n    Optional mask for probe constraints.\naperture_mask : ndarray or None, optional\n    Optional aperture mask.\nextra_space_on_side_px : int, optional\n    Extra padding (in pixels) to add to scan positions (default is 0).\n\nReturns\n-------\ntuple\n    A tuple containing:\n    - obj : ndarray\n        The padded object array.\n    - positions : ndarray\n        Adjusted (rounded) scan positions.\n    - int\n        A placeholder zero (reserved for future use).\n    - sequence : list\n        The sequence of indices used.\n    - wavelength : float\n        Computed electron wavelength in angstroms.\n    - full_pos_correction : ndarray\n        Subpixel corrections for scan positions.\n    - tilts_correction : ndarray\n        Array of zeros with same shape as tilts (tilt corrections).\n    - aperture_mask : ndarray or None\n        The probe constraint mask or aperture mask if provided.\n</code></pre> <p><code>prepare_saving_stuff(output_folder, save_loss_log, epoch_prev)</code> :   Prepare folder and loss CSV for saving training logs.</p> <pre><code>Parameters\n----------\noutput_folder : str\n    Directory for results.\nsave_loss_log : bool\n    Whether to save loss values.\nepoch_prev : int\n    Previous epoch index.\n\nReturns\n-------\nNone\n</code></pre> <p><code>preprocess_dataset(dataset, load_one_by_one, algorithm_type, recon_type, data_shift_vector, data_bin, data_pad, upsample_pattern, data_multiplier, xp, force_pad)</code> :   Apply preprocessing steps to the dataset including shifting, binning, padding, and scaling.</p> <pre><code>Parameters\n----------\ndataset : ndarray\n    The input dataset.\nload_one_by_one : bool\n    Whether data is loaded incrementally.\nalgorithm_type : str\n    Type of reconstruction algorithm.\nrecon_type : str\n    Type of reconstruction (e.g., near_field, far_field).\ndata_shift_vector : list of int\n    Vector indicating pixel shift in y and x.\ndata_bin : int\n    Binning factor.\ndata_pad : int\n    Padding size.\nupsample_pattern : int\n    Upsampling factor for the pattern.\ndata_multiplier : float\n    Factor to scale data intensity.\nxp : module\n    Array module, e.g., numpy or cupy.\nforce_pad : bool\n    If True, apply forced padding.\n\nReturns\n-------\ntuple\n    Tuple containing:\n    - preprocessed dataset\n    - data_shift_vector\n    - data_bin\n    - data_pad\n    - data_multiplier\n</code></pre> <p><code>print_pypty_header(data_path, output_folder, save_loss_log)</code> :   Print formatted header announcing start of reconstruction.</p> <pre><code>Parameters\n----------\ndata_path : str\n    Path to the dataset.\noutput_folder : str\n    Directory where results are saved.\nsave_loss_log : bool\n    Whether loss logging is enabled.\n\nReturns\n-------\nNone\n</code></pre> <p><code>print_recon_state(t0, algorithm, epoch, current_loss, current_sse, current_obj_step, current_probe_step, current_probe_pos_step, current_tilts_step, current_static_background_step, current_aberrations_array_step, current_beam_current_step, current_hist_length, print_flag)</code> :   Display current reconstruction progress including loss, optimization state, and updates.</p> <pre><code>Parameters\n----------\nt0 : float\n    Start time of the epoch (Unix timestamp).\nalgorithm : str\n    Name of the loss or optimization algorithm used.\nepoch : int\n    Current training epoch.\ncurrent_loss : float\n    Loss value at current epoch.\ncurrent_sse : float\n    Sum of squared errors.\ncurrent_obj_step : bool\n    Whether the object is being updated.\ncurrent_probe_step : bool\n    Whether the probe is being updated.\ncurrent_probe_pos_step : bool\n    Whether the scan grid is being updated.\ncurrent_tilts_step : bool\n    Whether tilt corrections are being updated.\ncurrent_static_background_step : bool\n    Whether static background is being updated.\ncurrent_aberrations_array_step : bool\n    Whether aberration coefficients are being updated.\ncurrent_beam_current_step : bool\n    Whether beam current is being updated.\ncurrent_hist_length : int\n    Optimizer memory length (0=GD, 1=CG, &gt;1=BFGS).\nprint_flag : int\n    Verbosity flag: 0 = silent, 1 = single-line print, 2 = verbose.\n\nReturns\n-------\nNone\n</code></pre> <p><code>save_current_checkpoint_obj_probe(output_folder, obj, probe, tilts_correction, full_pos_correction, positions, tilts, static_background, current_probe_step, current_obj_step, current_probe_pos_step, current_tilts_step, current_static_background_step, current_aberrations_array_step, aberrations_array, beam_current, bcstep, xp)</code> :   Save intermediate reconstruction data as checkpoints.</p> <pre><code>This function saves the current state of the object, probe, tilt corrections, scan positions,\nstatic background, and aberrations to disk. It is intended to allow resuming reconstruction\nfrom the last checkpoint.\n\nParameters\n----------\noutput_folder : str\n    Directory where checkpoint files will be saved.\nobj : ndarray or GPU array\n    The current object array.\nprobe : ndarray or GPU array\n    The current probe array.\ntilts_correction : ndarray\n    Correction values for tilt angles.\nfull_pos_correction : ndarray\n    Sub-pixel correction values for scan positions.\npositions : ndarray\n    Scan positions array.\ntilts : ndarray\n    Tilt angles array.\nstatic_background : ndarray\n    Static background array.\ncurrent_probe_step : bool\n    Flag indicating whether to save the probe.\ncurrent_obj_step : bool\n    Flag indicating whether to save the object.\ncurrent_probe_pos_step : bool\n    Flag indicating whether to save the scan positions.\ncurrent_tilts_step : bool\n    Flag indicating whether to save the tilt angles.\ncurrent_static_background_step : bool\n    Flag indicating whether to save the static background.\ncurrent_aberrations_array_step : bool\n    Flag indicating whether to save the aberrations array.\naberrations_array : ndarray or GPU array\n    The current aberrations array.\nbeam_current : ndarray or GPU array or None\n    The current beam current array.\nbcstep : bool\n    Flag indicating whether to save the beam current.\nxp : module\n    Numerical backend (e.g., numpy or cupy).\n\nReturns\n-------\nNone\n</code></pre> <p><code>save_params(params_path, params, strip_dataset_from_params)</code> :   Save parameters to a .pkl file, optionally removing the dataset.</p> <pre><code>Parameters\n----------\nparams_path : str\n    Output path for the parameter file.\nparams : dict\n    Parameter dictionary to save.\nstrip_dataset_from_params : bool\n    If True, remove the dataset entry.\n\nReturns\n-------\nNone\n</code></pre> <p><code>save_updated_arrays(output_folder, epoch, current_probe_step, current_probe_pos_step, current_tilts_step, current_obj_step, obj, probe, tilts_correction, full_pos_correction, positions, tilts, static_background, current_aberrations_array_step, current_static_background_step, count, current_loss, current_sse, aberrations, beam_current, current_beam_current_step, save_flag, save_loss_log, constraint_contributions, actual_step, count_linesearch, d_value, new_d_value, current_update_step_bfgs, t0, xp, warnings)</code> :   Save current reconstruction state and log loss metrics during training.</p> <pre><code>This function saves checkpoints for object, probe, tilts, scan positions, static background, \naberration coefficients, and beam current if specified. It also logs loss and constraint \ncontributions in a CSV file if logging is enabled.\n\nParameters\n----------\noutput_folder : str\n    Directory where files will be saved.\nepoch : int\n    Current epoch number.\ncurrent_probe_step : bool\n    Whether to save the current probe.\ncurrent_probe_pos_step : bool\n    Whether to save current scan positions.\ncurrent_tilts_step : bool\n    Whether to save current tilts.\ncurrent_obj_step : bool\n    Whether to save the current object.\nobj : ndarray or xp.ndarray\n    Object array to save.\nprobe : ndarray or xp.ndarray\n    Probe array to save.\ntilts_correction : ndarray\n    Tilt correction values.\nfull_pos_correction : ndarray\n    Sub-pixel scan position correction.\npositions : ndarray\n    Integer scan positions.\ntilts : ndarray\n    Original tilt values.\nstatic_background : ndarray or xp.ndarray\n    Static background array.\ncurrent_aberrations_array_step : bool\n    Whether to save aberration array.\ncurrent_static_background_step : bool\n    Whether to save static background.\ncount : int\n    Not used inside the function.\ncurrent_loss : float\n    Current loss value.\ncurrent_sse : float\n    Current sum of squared errors.\naberrations : ndarray or xp.ndarray\n    Array of aberration coefficients.\nbeam_current : ndarray or xp.ndarray\n    Array of beam current values.\ncurrent_beam_current_step : bool\n    Whether to save beam current.\nsave_flag : bool\n    Whether to trigger checkpoint saving.\nsave_loss_log : bool or int\n    Whether to log loss. If set to 2, log full breakdown of constraints.\nconstraint_contributions : list\n    List of constraint term contributions to the loss.\nactual_step : float\n    Step size applied in the optimizer.\ncount_linesearch : int\n    Number of line search iterations.\nd_value : float\n    Initial directional derivative.\nnew_d_value : float\n    New directional derivative after the step.\ncurrent_update_step_bfgs : float\n    Step size suggested by BFGS or optimizer.\nt0 : float\n    Start time of the epoch (used for timing).\nxp : module\n    NumPy or CuPy module used for computation.\nwarnings : str\n    Warning string to be logged.\n\nReturns\n-------\nNone\n</code></pre> <p><code>shift_probe_fourier(probe, shift_px)</code> :   Shift a probe in Fourier space by applying a phase ramp.</p> <pre><code>Parameters\n----------\nprobe : array_like\n    The input probe array.\nshift_px : tuple of float\n    Shift in pixels (y, x).\n\nReturns\n-------\ntuple\n    Tuple containing the shifted probe, the phase mask, the Fourier transform of the probe,\n    and the spatial frequency grids (maskx, masky).\n</code></pre> <p><code>string_params_to_usefull_params(params)</code> :   Convert string-encoded lambdas in parameter dictionary back to callables.</p> <pre><code>Parameters\n----------\nparams : dict\n    Parameter dictionary possibly containing lambda strings.\n\nReturns\n-------\ndict\n    Updated dictionary with callables.\n</code></pre> <p><code>string_to_lambda(lambda_string)</code> :   Convert stringified lambda expression to a Python function.     Parameters     ----------     lambda_string : str         Lambda string to evaluate.</p> <pre><code>Returns\n-------\ncallable or str\n    The resulting function or original string if evaluation fails.\n</code></pre> <p><code>try_to_gpu(obj, probe, positions, full_pos_correction, tilts, tilts_correction, masks, defocus_array, slice_distances, aperture_mask, dataset, load_one_by_one, static_background, aberrations_array, beam_current, default_float, default_complex, default_int, xp)</code> :   Convert all key reconstruction variables to GPU arrays if using CuPy.</p> <pre><code>Parameters\n----------\nobj : ndarray\n    Object array.\nprobe : ndarray\n    Probe array.\npositions : ndarray\n    Integer scan positions.\nfull_pos_correction : ndarray\n    Sub-pixel scan grid correction.\ntilts : ndarray\n    Tilt values.\ntilts_correction : ndarray\n    Tilt corrections.\nmasks : ndarray or None\n    Optional segmentation or region masks.\ndefocus_array : ndarray\n    Array of defocus values per position.\nslice_distances : ndarray\n    Slice spacing in multislice simulations.\naperture_mask : ndarray or None\n    Probe aperture mask.\ndataset : ndarray\n    Measured dataset.\nload_one_by_one : bool\n    Whether dataset is streamed from disk.\nstatic_background : ndarray or None\n    Static background array.\naberrations_array : ndarray or None\n    Array of aberration coefficients.\nbeam_current : ndarray or None\n    Beam current scaling factor.\ndefault_float : dtype\n    Float precision dtype for casting.\ndefault_complex : dtype\n    Complex precision dtype for casting.\ndefault_int : dtype\n    Integer dtype for casting.\nxp : module\n    Numerical backend (`numpy` or `cupy`).\n\nReturns\n-------\ntuple\n    The same variables in GPU format (if using CuPy), with proper types.\n</code></pre> <p><code>try_to_initialize_beam_current(beam_current, measured_data_shape, default_float, xp)</code> :   Initialize beam current array or pad if it's too short.</p> <pre><code>Parameters\n----------\nbeam_current : ndarray or None\n    Existing beam current values.\nmeasured_data_shape : tuple\n    Shape of measured dataset.\ndefault_float : dtype\n    Float type for the array.\nxp : module\n    NumPy or CuPy.\n\nReturns\n-------\nndarray\n    Initialized or padded beam current.\n</code></pre> <p><code>upsample_something(something, upsample, scale=True, xp=&lt;module 'numpy' from '/Users/anton/miniconda/lib/python3.10/site-packages/numpy/__init__.py'&gt;)</code> :   Upsample a 2D array.</p> <pre><code>Parameters\n----------\nsomething : ndarray\n    The 2D array to be upsampled.\nupsample : int\n    Upsampling factor.\nscale : bool, optional\n    If True, scales the result to conserve total sum (default is True).\nxp : module, optional\n    Array module (default is numpy).\n\nReturns\n-------\nndarray\n    The upsampled array.\n</code></pre> <p><code>upsample_something_3d(something, upsample, scale=True, xp=&lt;module 'numpy' from '/Users/anton/miniconda/lib/python3.10/site-packages/numpy/__init__.py'&gt;)</code> :   Upsample a 3D array along the last two axes.</p> <pre><code>Parameters\n----------\nsomething : ndarray\n    The 3D array to be upsampled.\nupsample : int\n    Upsampling factor.\nscale : bool, optional\n    If True, scales the upsampled result to conserve total sum (default is True).\nxp : module, optional\n    Array module, e.g., numpy or cupy (default is numpy).\n\nReturns\n-------\nndarray\n    The upsampled 3D array.\n</code></pre> <p><code>wolfe_1(value, new_value, d_value, step, wolfe_c1=0.5)</code> :   Check the Armijo condition (Wolfe condition 1) for line search.</p> <pre><code>Parameters\n----------\nvalue : float\n    The current function value.\nnew_value : float\n    The function value after the step.\nd_value : float\n    The directional derivative at the current point.\nstep : float\n    Step size.\nwolfe_c1 : float, optional\n    Armijo condition constant (default is 0.5).\n\nReturns\n-------\nbool\n    True if the condition is satisfied, False otherwise.\n</code></pre> <p><code>wolfe_2(d_value, new_d_value, wolfe_c2=0.9)</code> :   Check the curvature condition (Wolfe condition 2) for line search.</p> <pre><code>Parameters\n----------\nd_value : float\n    The directional derivative at the current point.\nnew_d_value : float\n    The directional derivative after the step.\nwolfe_c2 : float, optional\n    Curvature condition constant (default is 0.9).\n\nReturns\n-------\nbool\n    True if the condition is satisfied, False otherwise.\n</code></pre>"},{"location":"reference/pypty/vaa/","title":"Module pypty.vaa","text":""},{"location":"reference/pypty/vaa/#functions","title":"Functions","text":"<p><code>add_scalebar_ax(ax, x, y, width, height, x_t, y_t, px_size, unit)</code> :   Add a scale bar to a given axis.</p> <pre><code>Parameters\n----------\nax : matplotlib.axes.Axes\n    The axes to which the scale bar will be added.\nx : float\n    The x-coordinate of the bottom left corner of the scale bar.\ny : float\n    The y-coordinate of the bottom left corner of the scale bar.\nwidth : float\n    The width of the scale bar in pixels.\nheight : float\n    The height of the scale bar in pixels.\nx_t : float\n    The x-coordinate for the text label.\ny_t : float\n    The y-coordinate for the text label.\npx_size : float\n    The pixel size in the same units as the width and height.\nunit : str\n    The unit of measurement for the scale bar.\n</code></pre> <p><code>complex_array_to_rgb(X, theme='dark', rmax=None)</code> :   Convert a complex array to RGB format.</p> <pre><code>Parameters\n----------\nX : numpy.ndarray\n    The input array of complex numbers.\ntheme : str, optional\n    The color theme, either 'dark' or 'light' (default is 'dark').\nrmax : float, optional\n    Maximum absolute value for normalization (default is None).\n\nReturns\n-------\nnumpy.ndarray\n    The RGB representation of the input array.\n</code></pre> <p><code>complex_pca(data, n_components)</code> :   Perform PCA on complex data.</p> <pre><code>Parameters\n----------\ndata : numpy.ndarray\n    The input data array of shape (N_y, N_x, N_obs).\nn_components : int\n    The number of principal components to retain.\n\nReturns\n-------\nnumpy.ndarray\n    The reduced data array of shape (N_y, N_x, n_components).\n</code></pre> <p><code>fit_aberrations_to_wave(wave, px_size_A, acc_voltage, thresh=0, aberrations_guess=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], plot=True, ftol=1e-20, xtol=1e-20, loss='linear', max_mrad=inf)</code> :   Calculate model positions based on step size and angle.</p> <pre><code>Parameters\n----------\nstep_size : float\n    The step size for the model.\nangle_rad : float\n    The angle in radians.\nx : numpy.ndarray\n    The x coordinates.\ny : numpy.ndarray\n    The y coordinates.\n\nReturns\n-------\ntuple\n    The model x and y coordinates.\n</code></pre> <p><code>get_affine_tranform(positions, scan_size, px_size_A)</code> :   Calculate the affine transformation matrix from positions.</p> <pre><code>Parameters\n----------\npositions : numpy.ndarray\n    The measured positions.\nscan_size : tuple\n    The size of the scan grid.\npx_size_A : float\n    Pixel size in angstroms.\n\nReturns\n-------\nnumpy.ndarray\n    The deformation matrix.\n</code></pre> <p><code>get_step_angle_scan_grid(positions, scan_size)</code> :   Determine the step size and angle for a scan grid.</p> <pre><code>Parameters\n----------\npositions : numpy.ndarray\n    The measured positions.\nscan_size : tuple\n    The size of the scan grid.\n\nReturns\n-------\ntuple\n    The step size and angle in degrees.\n</code></pre> <p><code>mesh_model_positions(step_size, angle_rad, x, y)</code> :   Calculate model positions based on step size and angle.</p> <pre><code>Parameters\n----------\nstep_size : float\n    The step size for the model.\nangle_rad : float\n    The angle in radians.\nx : numpy.ndarray\n    The x coordinates.\ny : numpy.ndarray\n    The y coordinates.\n\nReturns\n-------\ntuple\n    The model x and y coordinates.\n</code></pre> <p><code>mesh_objective_positions(ini_guess, x, y, mesh_x, mesh_y)</code> :   Objective function for mesh optimization.</p> <pre><code>Parameters\n----------\nini_guess : list\n    Initial guess for the optimization.\nx : numpy.ndarray\n    The x coordinates.\ny : numpy.ndarray\n    The y coordinates.\nmesh_x : numpy.ndarray\n    The mesh x coordinates.\nmesh_y : numpy.ndarray\n    The mesh y coordinates.\n\nReturns\n-------\nfloat\n    The sum of squared differences.\n</code></pre> <p><code>outputlog_plots(loss_path, skip_first=0, plot_time=True)</code> :   Plot log file data from PyPty.</p> <pre><code>Parameters\n----------\nloss_path : str\n    Path to the PyPty CSV file.\nskip_first : int, optional\n    Number of initial iterations to skip (default is 0).\nplot_time : bool, optional\n    If True, a second x-axis showing time in seconds will be added on top of the plot.\n\nReturns\n-------\nlist\n    List of plotted figures.\n</code></pre> <p><code>plot_complex_modes(p, nm, sub)</code> :   Plot complex modes in RGB format.</p> <pre><code>Parameters\n----------\np : numpy.ndarray\n    The input array of complex modes.\nnm : int\n    The number of modes to plot.\nsub : int\n    The number of rows for the subplot layout.\n\nReturns\n-------\nmatplotlib.figure.Figure\n    The figure containing the plotted complex modes.\n</code></pre> <p><code>plot_modes(ttt)</code> :   Plot the modes of a tensor.</p> <pre><code>Parameters\n----------\nttt : numpy.ndarray\n    A 3D or 4D array containing the modes to be plotted.\n</code></pre> <p><code>radial_average(ff, r_bins, r_max, r_min, px_size_A, plot=True)</code> :   Calculate the radial average of a 2D array.</p> <pre><code>Parameters\n----------\nff : numpy.ndarray\n    The input 2D array.\nr_bins : float\n    The bin size for the radial average.\nr_max : float\n    The maximum radius for averaging.\nr_min : float\n    The minimum radius for averaging.\npx_size_A : float\n    Pixel size in angstroms.\nplot : bool, optional\n    If True, the radial average will be plotted (default is True).\n\nReturns\n-------\nmatplotlib.figure.Figure\n    The figure containing the plot if `plot` is True.\n</code></pre>"}]}