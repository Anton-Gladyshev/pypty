{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Overview","text":"<p>PyPty is a phase retrieval code that can be applied to near-field or far-field imaging in TEM/STEM. It can be applied to do iterative ptychography, direct ptychography (Wigner distribution deconsvolution), differential phase contrast, tilt-corrected bright field, focal series reconstructions and LARBED reconstructions.</p> <p>The code is written by Anton Gladyshev (AG SEM, Physics Department, Humboldt-Universit\u00e4t zu Berlin). </p>"},{"location":"index.html#installation","title":"Installation","text":""},{"location":"index.html#setting-up-the-python-environment-and-installing-pypty","title":"Setting Up the Python Environment and Installing PyPty","text":"<p>To create a proper Python environment and install PyPty, you can use conda, mamba, or micromamba. With conda, use:</p>"},{"location":"index.html#gpu-installation","title":"GPU Installation","text":"<pre><code>git clone git@github.com:Anton-Gladyshev/pypty.git\ncd pypty\nconda env create -f pypty_gpu.yml\nconda activate pypty\npip install .[gpu]\n</code></pre>"},{"location":"index.html#cpu-installation","title":"CPU Installation","text":"<pre><code>git clone git@github.com:Anton-Gladyshev/pypty.git\ncd pypty\nconda env create -f pypty_cpu.yml\nconda activate pypty\npip install .\n</code></pre>"},{"location":"index.html#examples","title":"Examples","text":"<p>The examples will be provided in the <code>examples</code> folder. To to configure a completely custom preset, please reffer to the next section.</p>"},{"location":"index.html#relevant-literature","title":"Relevant Literature","text":"<p>If you have any questions after reading this guide, the following papers, books and links might explain the working principle of the code:</p>"},{"location":"index.html#multi-slice-formalism-and-the-nn-style-approach","title":"Multi-slice formalism and the NN-style approach","text":"<p>1) Earl J. Kirkland. Advanced Computing  in Electron Microscopy </p> <p>2) W. Van den Broek and C. Koch. General framework for quantitative three-dimensional reconstruction from arbitrary detection geometries in TEM </p> <p>3) W. Van den Broek and C. Koch. Method for Retrieval of the Three-Dimensional Object Potential by Inversion of Dynamical Electron Scattering </p>"},{"location":"index.html#error-metrics","title":"Error metrics:","text":""},{"location":"index.html#lsq","title":"LSQ:","text":"<p>4) M. Schloz et al. Overcoming information reduced data and experimentally uncertain parameters in ptychography with regularized optimization </p> <p>5) M. Du et al. Adorym: a multi-platform generic X-ray image reconstruction framework based on automatic differentiation </p>"},{"location":"index.html#maximum-likelihood-ml","title":"Maximum Likelihood (ML):","text":"<p>6) P. Thibault and M. Guizar-Sicairos. Maximum-likelihood refinement for coherent diffractive imaging </p>"},{"location":"index.html#compressed-lsq","title":"Compressed LSQ:","text":"<p>7) A. Gladyshev et al. Lossy Compression of Electron Diffraction Patterns for Ptychography via Change of Basis</p>"},{"location":"index.html#lsq_sqrt-and-lsq_sqrt2","title":"lsq_sqrt and lsq_sqrt2:","text":"<p>8) P. Godard et al. (2012). Noise models for low counting rate coherent diffraction imaging</p>"},{"location":"index.html#mixed-state-formalism","title":"Mixed state formalism:","text":"<p>9) P Thibault &amp; A.Menzel Reconstructing state mixtures from diffraction measurements\u2014 Flux-preserving formalism (for near-field imaging)</p>"},{"location":"index.html#near-field-imaging","title":"Near-field imaging","text":"<p>10) C. Koch A flux-preserving non-linear inline holography reconstruction algorithm for partially coherent electrons</p>"},{"location":"index.html#tilted-propagator","title":"Tilted propagator:","text":"<p>11) Earl J. Kirkland. Advanced Computing  in Electron Microscopy </p> <p>12) H. She, J. Cui and R. Yu. Deep sub-angstrom resolution imaging by electron ptychography with misorientation correction</p>"},{"location":"index.html#regularization-constaints","title":"Regularization constaints:","text":"<p>13) M. Schloz et al. Overcoming information reduced data and experimentally uncertain parameters in ptychography with regularized optimization </p> <p>14) A. Gladyshev et al. Lossy Compression of Electron Diffraction Patterns for Ptychography via Change of Basis</p>"},{"location":"index.html#linesearch","title":"Linesearch","text":"<p>15) L. Armijo (1966). Minimization of functions having Lipschitz continuous first partial derivatives 16) P. Wolfe (1969). Convergence Conditions for Ascent Methods</p>"},{"location":"index.html#bfgs-algotithm","title":"BFGS algotithm","text":"<p>17) C. G. Broyden (1970). The convergence of a class of double-rank minimization algorithms</p> <p>18) R. Fletcher   (1970). A New Approach to Variable Metric Algorithms</p> <p>19) D. Goldfarb (1970). A Family of Variable Metric Updates Derived by Variational Means</p> <p>20) D. F. Shanno (1970). Conditioning of quasi-Newton methods for function minimization</p>"},{"location":"index.html#complex-derivatives","title":"Complex derivatives","text":"<p>21) W. Wirtinger (1927). Zur formalen theorie der funktionen von mehr komplexen ver\u00e4nderlichen. </p>"},{"location":"custom_presets.html","title":"PyPty Parameters for Creating Custom Presets","text":"<p>All functions in PyPty work dictionary describing your preset. We tend to name it <code>pypty_params</code>. The main function of PyPty package providing an iterative ptychographic reconsturction is launched via <code>run_ptychography()</code> functon from <code>pypty.iterative</code> module. It takes a single argument- <code>pypty_params</code>.</p> <p>For an easy preset configuration, please refer to the <code>pypty.initialize</code> module. It allows easy creation of all arrays. However, for a non-trivial experiment please follow this guide to create your own dictionary and fill in the requiered entries.</p>"},{"location":"custom_presets.html#lambda-type-in-pypty","title":"Lambda-type in PyPty","text":"<p>Before starting this guide, one important usage case must be discussed. PyPty is an iterative algorithm and, as you will see, it requires a number of input parameters. Some of these parameters can be specified in an iteration-dependent fashion using a lambda function. This function should take a single input argument and return the desired value for a given epoch.</p> <p>For example, if you want to apply <code>smart_memory</code> parameter every 10 epochs, you can set <code>smart_memory</code> in <code>pypty_params</code> dictionary as:</p> <pre><code>smart_memory: lambda x: x % 10 == 0;\n</code></pre> <p>The parameters that can be written in this way are marked as <code>pypty_lambda</code> type in the  Default Data Type column. They can also be specified as a sting containing the code, e.g. </p> <pre><code>smart_memory: \"lambda x: x % 10 == 0\";\n</code></pre> <p>We do not recommend applying constraints every n epochs, as PyPty\u2019s BFGS algorithm attempts to construct a Hessian matrix, and such modifications can disrupt this process. As a general rule of thumb, we suggest configuring lambda functions so that once an optimization parameter is activated, it maintains a consistent value throughout execution.</p>"},{"location":"custom_presets.html#full-list-of-paramerers-for-pyptyiterativerun","title":"Full list of paramerers for pypty.iterative.run()","text":""},{"location":"custom_presets.html#backend-settings","title":"Backend Settings","text":"Parameter Default Value Default Data Type Description <code>backend</code> <code>cp</code> <code>NumPy-like python module</code> Currently not used, but will be a feature in the future. Right now, whenever CuPy is available, it is used as the GPU backend. If no CUDA is detected, NumPy is used as a CPU replacement. We plan to add support for Apple Silicon, but we are waiting for an optimal library to appear. <code>default_dtype</code> <code>\"double\"</code> <code>str</code> Default data type for computations. Another option is <code>\"single\"</code>."},{"location":"custom_presets.html#dataset","title":"Dataset","text":"Parameter Default Value Default Data Type Description <code>data_path</code> <code>\"\"</code> <code>str</code> Path to the dataset. It can be an <code>.h5</code> file with a dataset named <code>\"data\"</code> containing a 3D measurement array <code>(N_measurements, y, x)</code>. Another option is a 4D <code>.npy</code> array or a 3D <code>.npy</code> array. <code>dataset</code> <code>None</code> <code>numpy-array</code> or None If you don't want to store data on disk, you can attach a numpy-array with your data to the parameters. If it's provided, <code>data_path</code> is ignored. <code>masks</code> <code>None</code> <code>numpy.ndarray</code> or <code>None</code> Masks (virtual detectors) used for data compression. For uncompressed data, leave it as <code>None</code>. <code>data_multiplier</code> <code>1</code> <code>float</code> Multiplier for data values. Used to rescale patterns on the fly without modifying the stored dataset. All patterns will be multiplied by this number. <code>data_pad</code> <code>0</code> <code>int</code> Padding applied to data. Use it to pad patterns on the fly without modifying the stored dataset. We recommend setting it to 1/4 of the pattern width for optimal sampling conditions in far-field mode. <code>data_bin</code> <code>1</code> <code>int</code> Binning factor for data. Used to bin patterns on the fly without modifying the stored dataset. All patterns will be binned by this number. <code>flip_ky</code> <code>False</code> <code>bool</code> Flag indicating that one has to flip <code>ky</code>. Useful if patterns are flipped and you don\u2019t want to modify the stored dataset. Another option is to create a PyPty-style <code>.h5</code> dataset. <code>data_shift_vector</code> <code>[0,0]</code> <code>list</code> Shift vector (list with two-values) applied to measurements. Used to shift patterns on the fly without modifying the stored dataset. All patterns will be shifted by the specified number of pixels. <code>upsample_pattern</code> <code>1</code> <code>int</code> Upsampling factor. If the beam footprint is larger than the extent (in far-field mode), this allows to artificially upsample the beam in reciprocal space. Experimental feature! Windowing constraints may be required. <code>sequence</code> <code>None</code> <code>list</code> or <code>None</code> or <code>pypty_lambda</code> Sequence used in data processing. This is a list indicating the measurements that will be used for iterative refinement. If <code>None</code>, all measurements contribute. This parameter is useful for reconstructions on subscans without creating additional data files. <code>use_full_FOV</code> <code>True</code> <code>bool</code> Boolean flag. Only useful if a sequence is provided. If <code>True</code>, the object can accommodate all measurements. If <code>False</code>, the object accommodates only selected measurements."},{"location":"custom_presets.html#saving-and-printing","title":"Saving and Printing","text":"Parameter Default Value Default Data Type Description <code>output_folder</code> <code>\"\"</code> <code>str</code> Path to the folder where output files will be saved. <code>save_loss_log</code> <code>True</code> <code>bool</code> Boolean flag. If <code>True</code>, the loss log will be saved as <code>loss.csv</code>. <code>epoch_prev</code> <code>0</code> <code>int</code> Previous epoch count. Useful for restarting a reconstruction. <code>save_checkpoints_every_epoch</code> <code>False</code> <code>bool</code>   or <code>int</code> Save checkpoints every epoch. If <code>True</code>, checkpoints will be always saved, if it is provided as an integer, checkpoints will be saved every n'th epoch. <code>save_inter_checkpoints</code> <code>True</code> <code>bool</code>  or <code>int</code> Save intermediate overwritable checkpoints. This will create <code>.npy</code> arrays: <code>co.npy</code> for the object, <code>cp.npy</code> for the probe, <code>cg.npy</code> for the scan grid, <code>ct.npy</code> for the tilts, <code>cs.npy</code> for the static background, and <code>cb.npy</code> for the beam current. If <code>True</code>, checkpoints will be always saved, if it is provided as an integer, checkpoints will be saved every n'th epoch. <code>print_flag</code> <code>3</code> <code>int</code> Print verbosity level: <code>0</code> for no printing, <code>1</code> for one overwritable line, <code>2</code> and <code>3</code> for moderate output. <code>4</code> gives the most detailed output."},{"location":"custom_presets.html#experimental-parameters","title":"Experimental Parameters","text":"Parameter Default Value Default Data Type Description <code>acc_voltage</code> <code>60</code> <code>float</code> Acceleration voltage in kV. <code>aperture_mask</code> <code>None</code> <code>numpy.ndarray</code> or <code>None</code> Mask for the aperture. Can be used for reciprocal probe constaint later (see section constraints). <code>recon_type</code> <code>\"far_field\"</code> <code>str</code> Type of reconstruction. Options: <code>\"far_field\"</code> or <code>\"near_field\"</code>. <code>alpha_near_field</code> <code>0.0</code> <code>float</code> Alpha parameter for near-field reconstruction &amp; flux preservation. <code>defocus_array</code> <code>np.array([0.0])</code> <code>numpy.ndarray</code> Array of defocus values for near-field measurement. Irrelevant for far-field. It can contain either a single common defocus value for all measurements or individual values for each measurement. Units: Angstroms. <code>Cs</code> <code>0.0</code> <code>float</code> Spherical aberration coefficient. Units: Angstroms."},{"location":"custom_presets.html#spatial-calibration","title":"Spatial Calibration","text":"Parameter Default Value Default Data Type Description <code>slice_distances</code> <code>np.array([10.0])</code> <code>numpy.ndarray</code> Distances between object slices. Units: Angstroms. You can specify a single value common for all slices or provide individual values. <code>pixel_size_x_A</code> <code>1.0</code> <code>float</code> Pixel size in the x-direction (Angstroms). <code>pixel_size_y_A</code> <code>1.0</code> <code>float</code> Pixel size in the y-direction (Angstroms). <code>scan_size</code> <code>None</code> <code>tuple</code> or <code>None</code> Tuple describing the number of scan points in y- and x- directions. Required for constraining positions and tilts. <code>num_slices</code> <code>1</code> <code>int</code> Number of slices in the object."},{"location":"custom_presets.html#refinable-arrays","title":"Refinable Arrays","text":"Parameter Default Value Default Data Type Description <code>obj</code> <code>np.ones((1, 1, num_slices, 1))</code> <code>numpy.ndarray</code> Initial guess for the transmission function to be retrieved. Shape: <code>(y, x, z, modes)</code>. If the <code>y</code> and <code>x</code> dimensions are insufficient for the scan grid, the object will be padded with ones. <code>probe</code> <code>None</code> <code>numpy.ndarray</code> or <code>None</code> Real-space probe. Shape: <code>(y, x, modes)</code>. For advanced experiments, the probe can be 4D <code>(y, x, modes, subscans)</code>. If <code>None</code>, PyPty will automatically initialize the beam from the dataset. <code>positions</code> <code>np.array([[0.0, 0.0]])</code> <code>numpy.ndarray</code> Scan positions in pixels of the reconstruction. Shape: <code>[N_measurements, 2]</code>, formatted as <code>[[y0, x0], [y1, x1], ..., [yn, xn]]</code>. Single-shot experiments can define one common scan point, e.g., <code>[[0,0]]</code>. <code>tilts</code> <code>np.array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]])</code> <code>numpy.ndarray</code> Tilt angles in real and reciprocal spaces. There are 3 types of tilts in PyPty framework: before, inside and after. First one is a beam tilt before the specimen, i.e. a shift in aperture plane. Second type is a tilt inside of a specimen, i.e. after each slice the beam is shifted in real space. Third type is a post-specimen tilt i.e. a shift in a detector plane.  All three types of shifts are contained in this tilt array. Shape:  <code>[N_measurements, 6]</code>. Format: <code>[[y0_before, x0_before, y0_inside, x0_inside, y0_after, x0_after], ..., [yN, xN]]</code>. Single-shot experiments can define one common tilt (with shape <code>[1, 6]</code>). <code>tilt_mode</code> <code>0</code> <code>int</code> Mode for applying tilts: <code>0, 3, 4</code> for inside, <code>2, 4</code> for before, and <code>1, 3, 4</code> for after the specimen. <code>static_background</code> <code>0</code> <code>numpy.ndarray</code> or <code>float</code> Static background intensity. Shape should match initial patterns but padded by <code>data_pad//upsample_pattern</code>. Use <code>0</code> for no static offset. If provided as postive float, the algorithm will initialize the backgrund with a proper shape on its own. <code>beam_current</code> <code>None</code> <code>numpy.ndarray</code> or <code>None</code> Accounts for different currents (or exposure times) during measurements. If provided, must be a 1D array with length matching <code>N_measurements</code>."},{"location":"custom_presets.html#propagation-shifting-and-resizing","title":"Propagation, Shifting, and Resizing","text":"Parameter Default Value Default Data Type Description <code>propmethod</code> <code>\"multislice\"</code> <code>str</code> Wave propagation method. Options: <code>\"multislice\"</code>, <code>\"better_multislice\"</code>, and <code>\"yoshida\"</code>. The last two are higher precision but slower. <code>allow_subPixel_shift</code> <code>True</code> <code>bool</code> Allow subpixel shifts. If <code>False</code>, positions will be rounded to integers until refined. <code>dynamically_resize_yx_object</code> <code>False</code> <code>bool</code> or <code>int</code>  or <code>pypty_lambda</code> If position updates become too large, the object will be padded to accommodate the new scan grid. If set to a positive integer, resizing occurs when position updates exceed this value. <code>extra_space_on_side_px</code> <code>0</code> <code>int</code> Extra space added around the object in pixels."},{"location":"custom_presets.html#bandwidth-limitation","title":"Bandwidth Limitation","text":"Parameter Default Value Default Data Type Description <code>damping_cutoff_multislice</code> <code>2/3</code> <code>float</code> Frequency cutoff for multislice beam propagation. Values larger than <code>2/3</code> can cause aliasing artifacts. Recommended \u2264 2/3. <code>smooth_rolloff</code> <code>0</code> <code>float</code> Rolloff parameter for smooth frequency cutoffs. <code>update_extra_cut</code> <code>0.005</code> <code>float</code> Extra frequency cutoff for the full object. Ensures bandwidth limitation beyond the cropped ROIs of the multislice object. <code>lazy_clean</code> <code>False</code> <code>bool</code> If <code>True</code>, the full transmission function will not be bandwidth-limited (only cropped ROIs will be). Recommended: <code>False</code>."},{"location":"custom_presets.html#optimization-settings","title":"Optimization Settings","text":"Parameter Default Value Default Data Type Description <code>algorithm</code> <code>\"lsq_sqrt\"</code> <code>str</code> Error metric for reconstruction comparison. Options: <code>\"lsq_sqrt\"</code> (Gaussian), <code>\"ml\"</code> (Poisson), <code>\"lsq\"</code> (classic summed squared error), and <code>\"lsq_sqrt_2\"</code> (modified Gaussian). If data is compressed via virtual detectors, the only option is <code>\"lsq_compressed\"</code> (summed squared error  between signals). <code>epoch_max</code> <code>200</code> <code>int</code> Maximum number of epochs (iterations). <code>wolfe_c1_constant</code> <code>0.1</code> <code>float</code>  or <code>pypty_lambda</code> Wolfe condition parameter (C1). Prevents update steps from being too large. Must be &gt; 0 and &lt; C2. Larger values enforce shorter step size. <code>wolfe_c2_constant</code> <code>0.9</code> <code>float</code>   or <code>pypty_lambda</code> Wolfe condition parameter (C2). Prevents update steps from being too small. Must be &gt; C1 but &lt; 1. Larger values allow larger steps. <code>loss_weight</code> <code>1</code> <code>float</code>    or <code>pypty_lambda</code> Weight applied to the loss function. <code>max_count</code> <code>20</code> <code>int</code> or <code>None</code> Maximum number of forward-backward propagations per line search iteration. If exceeded, the update is rejected and history is reset. Use <code>None</code> or <code>np.inf</code> to disable. <code>reduce_factor</code> <code>0.1</code> <code>float</code> Factor for reducing step size when the first Wolfe condition is not met. <code>optimism</code> <code>3.0</code> <code>float</code> Factor for increasing step size when the second Wolfe condition is not met. To prevenet algorithm from going back and forth during linesearch, multiplication of optimism and reduce_factor (or of any powers of them) should not be equal to 1. <code>min_step</code> <code>1e-20</code> <code>float</code> Minimum step size. If the step falls below this value, the algorithm resets history. Use <code>0</code> to disable. <code>hist_length</code> <code>10</code> <code>int</code> or <code>np.inf</code> or <code>pypty_lambda</code> BFGS optimization history length. Values: <code>0</code> (Gradient Descent), <code>1</code> (Conjugate Gradient), <code>N&gt;1</code> (Limited-memory BFGS), <code>np.inf</code> (Full BFGS). <code>update_step_bfgs</code> <code>1</code> <code>float</code> or <code>pypty_lambda</code> Common step applied to all refinable quantities. By default, after the first iteration, a Barzilai-Borwein method is used to inistialize the inverse Hessian, so most of the time, an update step of 1 should be accepted. Only during the very first iteration the linesearch might take some time to find an appropriate step. <code>phase_only_obj</code> <code>False</code> <code>bool</code> or <code>pypty_lambda</code> Whether to consider the object as phase-only. <code>tune_only_probe_phase</code> <code>False</code> <code>bool</code> or <code>pypty_lambda</code> Optimize only the reciprocal-space phase (CTF) of the probe. <code>tune_only_probe_abs</code> <code>False</code> <code>bool</code> or <code>pypty_lambda</code> Optimize only the reciprocal-space amplitude (aperture) of the probe. <code>reset_history_flag</code> <code>False</code> <code>bool</code> or <code>pypty_lambda</code> Flag to reset optimization history. See section \"lambda-types\" in this document. If provided, history will be manually resetted."},{"location":"custom_presets.html#updating-refinable-arrays","title":"Updating Refinable Arrays","text":"Parameter Default Value Default Data Type Description <code>update_probe</code> <code>1</code> <code>bool</code>   or <code>pypty_lambda</code> Whether to update the probe (<code>1</code> for yes, <code>0</code> for no). <code>update_obj</code> <code>1</code> <code>bool</code>   or <code>pypty_lambda</code> Whether to update the object (<code>1</code> for yes, <code>0</code> for no). <code>update_probe_pos</code> <code>0</code> <code>bool</code>   or <code>pypty_lambda</code> Whether to update probe positions (<code>1</code> for yes, <code>0</code> for no). <code>update_tilts</code> <code>0</code> <code>bool</code>   or <code>pypty_lambda</code> Whether to update tilt angles (<code>1</code> for yes, <code>0</code> for no). <code>update_beam_current</code> <code>0</code> <code>bool</code>    or <code>pypty_lambda</code> Whether to update beam current (<code>1</code> for yes, <code>0</code> for no). <code>update_aberrations_array</code> <code>0</code> <code>bool</code>   or <code>pypty_lambda</code> Whether to update aberration array (<code>1</code> for yes, <code>0</code> for no). <code>update_static_background</code> <code>0</code> <code>bool</code>   or <code>pypty_lambda</code> Whether to update static background (<code>1</code> for yes, <code>0</code> for no)."},{"location":"custom_presets.html#multiple-illumination-functions","title":"Multiple Illumination Functions","text":"Parameter Default Value Default Data Type Description <code>aberrations_array</code> <code>np.array([[0.0]])</code> <code>numpy.ndarray</code> Array of aberration values for multiple beams. Useful for large fields of view where the beam changes. Shape: <code>[N_subscans, N_aberrations]</code>. <code>phase_plate_in_h5</code> <code>None</code> <code>str</code> or <code>None</code> Path to an HDF5 file containing phase plates for different measurements. Dataset name should be <code>\"configs\"</code>. Shape: <code>[N_measurements, Y_probe, X_probe]</code>. <code>aberration_marker</code> <code>None</code> <code>numpy.ndarray</code> or <code>None</code> Marker for multiple CTFs. Should be a 1D array of length <code>N_measurements</code>, where each entry corresponds to a CTF index in <code>aberrations_array</code>. <code>probe_marker</code> <code>None</code> <code>numpy.ndarray</code> or <code>None</code> Marker for probe variations. If provided, the probe should have shape <code>[y, x, modes, N_subscans]</code>, and this array should contain indices specifying which probe to use for each measurement."},{"location":"custom_presets.html#memory-usage","title":"Memory Usage","text":"Parameter Default Value Default Data Type Description <code>load_one_by_one</code> <code>True</code> <code>bool</code> If <code>True</code>, data is loaded dynamically to save GPU memory. If <code>False</code>, all data is loaded at once (faster but memory-intensive). <code>smart_memory</code> <code>True</code> <code>bool</code>   or <code>pypty_lambda</code> If <code>True</code>, memory is managed intelligently, clearing cache when necessary to prevent memory fragmentation. <code>remove_fft_cache</code> <code>False</code> <code>bool</code> If <code>True</code>, FFT cache is removed periodically to save memory. (Experimental feature) <code>compute_batch</code> <code>\"auto\"</code> <code>int</code> or <code>str</code> Batch size for multislice computation. Default value \"auto\" will automatically estimate a value that would fit into your memory, but ideally one should balance it by hand for a particular GPU. Increasing this can speed up reconstruction but requires more GPU memory. Super large values are also useless as at some point you will reash the limit the compute capability. <code>force_dataset_dtype</code> <code>default_float_cpu</code> <code>numpy.dtype</code> Forces the dataset to be stored in a specified data type. Can help reduce memory usage at the cost of precision. <code>preload_to_cpu</code> <code>False</code> <code>bool</code> If <code>True</code>, preloads data to CPU before transferring it to GPU, improving transfer speeds for <code>.h5</code> datasets. <code>force_pad</code> <code>False</code> <code>bool</code> If <code>True</code>, pads data at the start of reconstruction (uses more memory but speeds up computation). If <code>False</code>, padding is applied on the fly to save memory. <code>memory_saturation</code> <code>0.7</code> <code>float</code> If compute batch is set to <code>\"auto\"</code>, this ratio will be used to estimate a compute batch that would requiere <code>memory_saturation</code> of the avalible GPU memory. If <code>compute_batch</code> is integer, <code>memory_saturation</code> is ignored."},{"location":"custom_presets.html#constraints-contributing-to-the-loss","title":"Constraints Contributing to the Loss","text":"Parameter Default Value Default Data Type Description <code>mixed_variance_weight</code> <code>0</code> <code>float</code>   or <code>pypty_lambda</code> Regularization weight that prevents low-frequency variations between object states. <code>mixed_variance_sigma</code> <code>0.5</code> <code>float</code>   or <code>pypty_lambda</code> Controls the spatial frequency range affected by <code>mixed_variance_weight</code>. <code>probe_constraint_mask</code> <code>None</code> <code>numpy.ndarray</code> or <code>None</code> Mask for probe constraint in reciprocal space. Masked pixels are regularized using L2 norm. <code>probe_reg_constraint_weight</code> <code>0</code> <code>float</code> L2 regularization weight for the probe in reciprocal space. <code>window_weight</code> <code>0</code> <code>float</code>   or <code>pypty_lambda</code> L2 regularization weight for the probe in real space. <code>window</code> <code>None</code> <code>numpy.ndarray</code> or <code>None</code> or or <code>pypty_lambda</code> Window function used to constrain the probe in real space. Masked pixels are damped using L2 regularization. It can be either a 2d- real valued array with the same shape as upsampled and padded beam or a list containing two values: inner radius (fraction) and outer radius (fraction). Fractions will be multiplied with half of the probe width, everything inside of window will be kept intact, everything outside will be zeroed and intermediate values will be slighly damped. <code>abs_norm_weight</code> <code>0</code> <code>float</code> L1 regularization weight applied to the absorptive potential (negative log of the transmission function\u2019s absolute value). <code>phase_norm_weight</code> <code>0</code> <code>float</code>   or <code>pypty_lambda</code> L1 regularization weight applied to the phase of the object. <code>atv_weight</code> <code>0</code> <code>float</code>   or <code>pypty_lambda</code> Weight for Adaptive Total Variation (ATV) regularization on the transmission function. <code>atv_q</code> <code>1</code> <code>float</code>   or <code>pypty_lambda</code> ATV q parameter (controls the strength of smoothing). Recommended: <code>1</code>. <code>atv_p</code> <code>2</code> <code>float</code>  or <code>pypty_lambda</code> ATV p parameter (<code>1</code> = L1-like regularization, <code>2</code> = L2-like smoothing). Recommended: <code>2</code>. <code>fast_axis_reg_weight_positions</code> <code>0</code> <code>float</code> or <code>pypty_lambda</code> Regularization weight for fast-axis scan positions. Reduces the acceleration along one line. <code>slow_axis_reg_weight_positions</code> <code>0</code> <code>float</code> or <code>pypty_lambda</code> Regularization weight for slow-axis scan positions. Reduces the acceleration along one column. <code>fast_axis_reg_weight_tilts</code> <code>0</code> <code>float</code>  or <code>pypty_lambda</code> Regularization weight for fast-axis tilts. Reduces the acceleration along one line. <code>slow_axis_reg_weight_tilts</code> <code>0</code> <code>float</code>  or <code>pypty_lambda</code> Regularization weight for slow-axis tilts. Reduces the acceleration along one column. <code>deformation_reg_weight_positions</code> <code>0</code> <code>float</code>  or <code>pypty_lambda</code> Regularization weight for enfourcing a regular (but deformed) scan grid. <code>deformation_reg_weight_tilts</code> <code>0</code> <code>float</code>  or <code>pypty_lambda</code> Regularization weight for enfourcing a regular (but deformed) tilts grid."},{"location":"custom_presets.html#constraints-that-modify-the-object-and-probe-by-hand","title":"Constraints That Modify the Object and Probe 'By Hand'","text":"<p>Warning: These constraints reset the BFGS history when applied.</p> Parameter Default Value Default Data Type Description <code>apply_gaussian_filter</code> <code>False</code> <code>bool</code>   or <code>pypty_lambda</code> Applies a Gaussian filter to the phase of the object. <code>apply_gaussian_filter_amplitude</code> <code>False</code> <code>bool</code>    or <code>pypty_lambda</code> Applies a Gaussian filter to the amplitude of the object. <code>beta_wedge</code> <code>0</code> <code>float</code>  or <code>pypty_lambda</code> Removes high kz frequencies for low kx and ky in 3D object FFTs. <code>keep_probe_states_orthogonal</code> <code>False</code> <code>bool</code>  or <code>pypty_lambda</code> Enforces orthogonality of probe modes. <code>do_charge_flip</code> <code>False</code> <code>bool</code> Performs charge flipping on the object. <code>cf_delta_phase</code> <code>0.1</code> <code>float</code> Delta phase for charge flipping. <code>cf_delta_abs</code> <code>0.01</code> <code>float</code> Delta amplitude for charge flipping. <code>do_charge_flip</code> <code>False</code> <code>bool</code>      or <code>pypty_lambda</code> Perform charge flipping on the object. <code>cf_delta_phase</code> <code>0.1</code> <code>float</code> or <code>pypty_lambda</code> Delta phase for charge flipping. <code>cf_delta_abs</code> <code>0.01</code> <code>float</code> or <code>pypty_lambda</code> Delta amplitude for charge flipping. <code>cf_beta_phase</code> <code>-0.95</code> <code>float</code> or <code>pypty_lambda</code> Beta phase parameter for charge flipping. <code>cf_beta_abs</code> <code>-0.95</code> <code>float</code> or <code>pypty_lambda</code> Beta amplitude parameter for charge flipping. <code>fancy_sigma</code> <code>None</code> <code>None</code> or <code>float</code> oor <code>pypty_lambda</code> Custom sigma parameter to enforce atomicity. <code>restart_from_vacuum</code> <code>False</code> <code>bool</code> or <code>pypty_lambda</code> Resets the object to 1 while keeping other parameters unchanged. See section \"lambda-types\" in this document. <code>reset_positions</code> <code>False</code> <code>bool</code> or <code>pypty_lambda</code> Resets the positions to initial guess while keeping other parameters unchanged. See section \"lambda-types\" in this document."},{"location":"custom_presets.html#beam-initialization","title":"Beam Initialization","text":"Parameter Default Value Default Data Type Description <code>n_hermite_probe_modes</code> <code>None</code> <code>tuple</code> or <code>None</code> Number of Hermite probe modes. A tuple <code>[nx, ny]</code> specifying mode orders in <code>x</code> and <code>y</code> directions. If <code>None</code>, no Hermite modes are applied. <code>defocus_spread_modes</code> <code>None</code> <code>numpy.ndarray</code> or <code>None</code> 1D array with different defocus values for initializing probe modes. Useful for simulating defocus spread in the beam. <code>aberrations</code> <code>None</code> <code>numpy.ndarray</code> or <code>None</code> 1D array of aberration coefficients in Krivanek notation, e.g., <code>C10, C12a, C12b, C21a, C21b, C23a, C23b, C30</code>. Units: Angstroms. <code>extra_probe_defocus</code> <code>0</code> <code>float</code> Extra probe defocus applied in Angstroms. Useful for adjusting initial beam focus in multislice reconstructions. <code>estimate_aperture_based_on_binary</code> <code>0</code> <code>float</code> If &gt; 0, the aperture is estimated based on a binary threshold. Pixels in the data larger than <code>mean(data) * estimate_aperture_based_on_binary</code> are considered part of the aperture. <code>beam_ctf</code> <code>None</code> <code>numpy.ndarray</code> or <code>None</code> Beam Contrast Transfer Function (CTF). If provided, must be a 2D NumPy array with dimensions matching the upsampled probe size. <code>mean_pattern</code> <code>None</code> <code>numpy.ndarray</code> or <code>None</code> Mean diffraction pattern used for probe initialization. If provided, the probe is created using an inverse Fourier transform of this pattern."},{"location":"ini_custom.html","title":"Initialization functions availible for configuring custom presets","text":"<p>PyPty is supplied with an inialize module (see API reference). It allows to create a callibrated dataset and a pypty-preset from scratch. Here two core functions are explained in details:</p>"},{"location":"ini_custom.html#create_pypty_data","title":"create_pypty_data()","text":"<p>The <code>create_pypty_data()</code> function is used to generate a PyPty-style <code>.h5</code> dataset from an existing 4D-STEM dataset stored as an <code>.h5</code> or <code>.npy</code> file, or from a raw NumPy array. This function has no returns.</p> Parameter Type Default Description <code>data</code> <code>str</code> or <code>ndarray</code> - Path to an input dataset (<code>.h5</code> or <code>.npy</code>) or a NumPy array containing 4D-STEM data. <code>path_output</code> <code>str</code> - Path where the new PyPty dataset will be saved. <code>swap_axes</code> <code>bool</code> <code>False</code> Swap the last two coordinate axes. <code>flip_ky</code> <code>bool</code> <code>False</code> Flip the second last axis. <code>flip_kx</code> <code>bool</code> <code>False</code> Flip the last axis. <code>flip_y</code> <code>bool</code> <code>False</code> Flip the first axis. <code>flip_x</code> <code>bool</code> <code>False</code> Flip the second axis. <code>comcalc_len</code> <code>int</code> <code>1000</code> Number of measurements used to estimate the center. <code>comx</code> <code>int</code> or <code>None</code> <code>None</code> X-center of the measurements (computed if <code>None</code>). <code>comy</code> <code>int</code> or <code>None</code> <code>None</code> Y-center of the measurements (computed if <code>None</code>). <code>bin</code> <code>int</code> <code>1</code> Binning factor applied to the last two axes. <code>crop_left</code> <code>int</code> <code>None/0</code> Number of pixels cropped from the left. <code>crop_right</code> <code>int</code> <code>None/0</code> Number of pixels cropped from the right. <code>crop_top</code> <code>int</code> <code>None/0</code> Number of pixels cropped from the top. <code>crop_bottom</code> <code>int</code> <code>None/0</code> Number of pixels cropped from the bottom. <code>normalize</code> <code>bool</code> <code>False</code> If <code>True</code>, each pattern is rescaled so that its sum is 1 on average. <code>cutoff_ratio</code> <code>float</code> <code>None</code> If provided, values farther than <code>cutoff_ratio * (width/2)</code> will be zeroed. <code>pad_k</code> <code>int</code> <code>0</code> Padding applied to the last two axes. <code>data_dtype</code> <code>dtype</code> <code>np.float32</code> Data type of the output file. <code>rescale</code> <code>float</code> <code>1</code> If not 1, patterns are divided by this value. <code>exist_ok</code> <code>bool</code> <code>True</code> If <code>True</code>, does not overwrite the output file if it already exists. <p>Usage Example <pre><code>pypty.initialize.create_pypty_data(\"input_data.h5\", \"output_data.h5\", flip_x=True, bin=2, normalize=True)\n</code></pre></p>"},{"location":"ini_custom.html#append_exp_params","title":"append_exp_params()","text":"<p>The <code>append_exp_params()</code> function is used to calibrate an existing PyPty preset to new experimental data by incorporating experimental metadata and calibration parameters.</p>"},{"location":"ini_custom.html#parameters","title":"Parameters","text":"Parameter Type Default Description <code>experimental_params</code> <code>dict</code> - A dictionary containing experimental metadata. (See details below) <code>pypty_params</code> <code>dict</code> or <code>str</code> or <code>None</code> <code>None</code> Existing PyPty parameters. If <code>str</code>, it should be a path to a preset file. If <code>None</code>, a new parameter set is created."},{"location":"ini_custom.html#expected-keys-in-experimental_params","title":"Expected Keys in <code>experimental_params</code>","text":"<p>The <code>experimental_params</code> dictionary should contain the following keys:</p> <p>Essential Data Paths</p> Key Type Description <code>data_path</code> <code>str</code> Path to a 3D PyPty <code>.h5</code> dataset (<code>[N_measurements, ky, kx]</code>) or a 4D-STEM <code>.npy</code> dataset. <code>masks</code> <code>ndarray</code> or <code>None</code> If the data is compressed, provide the virtual detectors (<code>[N_masks, ky, kx]</code>). <code>output_folder</code> <code>str</code> Directory where results will be stored. <code>path_json</code> <code>str</code> Path to a Nion-style <code>.json</code> file with metadata (optional). <p>Electron Beam Properties</p> Key Type Description <code>acc_voltage</code> <code>float</code> Accelerating voltage (in kV). <code>rez_pixel_size_A</code> <code>float</code> Reciprocal pixel size (in \u00c5\u207b\u00b9). <code>rez_pixel_size_mrad</code> <code>float</code> Reciprocal pixel size (in mrad). <code>conv_semiangle_mrad</code> <code>float</code> Beam convergence semi-angle (in mrad). <code>aperture</code> <code>ndarray</code> (optional) Binary 2D mask representing the aperture. <code>bright_threshold</code> <code>float</code> Threshold for estimating an aperture. Everything above <code>threshold * max(PACBED)</code> is considered bright field. <p>Scan and Positioning</p> Key Type Description <code>scan_size</code> <code>tuple(int, int)</code> Number of scan points along slow (y) and fast (x) axes. <code>scan_step_A</code> <code>float</code> Scan step (STEM pixel size) in \u00c5. <code>fov_nm</code> <code>float</code> Field of view (FOV) along the fast axis in nm. <code>special_positions_A</code> <code>ndarray</code> (optional) If data was acquired on a non-rectangular grid, specify positions as <code>[y_0, x_0], ..., [y_n, x_n]</code> (in \u00c5). <code>transform_axis_matrix</code> <code>ndarray (2\u00d72)</code> Transformation matrix for position correction. <code>PLRotation_deg</code> <code>float</code> or <code>\"auto\"</code> Rotation angle between scan and detector axes. If <code>\"auto\"</code>, an iDPC measurement estimates this angle. <p>Reconstruction Settings</p> Key Type Description <code>num_slices</code> <code>int</code> Number of slices used for multislice propagation (default: <code>1</code>). <code>total_thickness</code> <code>float</code> Total thickness of the sample (in \u00c5). <code>data_pad</code> <code>int</code> or <code>None</code> Reciprocal space padding. Default: <code>1/4</code> of pattern width. <code>upsample_pattern</code> <code>int</code> Upsampling factor for diffraction patterns. <code>flip_ky</code> <code>bool</code> Flip the y-axis of diffraction patterns. <code>defocus</code> <code>float</code> Extra probe defocus (besides aberrations). <code>aberrations</code> <code>list</code> or <code>ndarray</code> Beam aberrations (stored in Krivanek notation). <p>Output &amp; Debugging</p> Key Type Description <code>plot</code> <code>bool</code> If <code>True</code>, generates plots of key experimental parameters. <code>print_flag</code> <code>int</code> Controls verbosity (<code>0</code> = silent, <code>1</code> = summary, <code>2+</code> = detailed logs). <code>save_preprocessing_files</code> <code>bool</code> If <code>True</code>, saves intermediate preprocessing files. <p>Nexus Tags</p> Key Type Description <code>chemical_fomula</code> <code>string</code> You can optionally provide a formula for your sample. PyPty will store this information. <code>sample_name</code> <code>string</code> You can optionally provide a name of your sample. PyPty will store this information. <p>Usage Example</p> <pre><code>experimental_params = {\n    \"data_path\": \"experiment_data.h5\",\n    \"acc_voltage\": 300,\n    \"rez_pixel_size_A\": 0.01,\n    \"scan_size\": (256, 256),\n    \"scan_step_A\": 1.5,\n    \"PLRotation_deg\": \"auto\",\n    \"output_folder\": \"results/\"\n}\npypty_params = None # or your custom preset\npypty_params = pypty.initialize.append_exp_params(experimental_params, pypty_params)\n</code></pre>"},{"location":"reference/direct.html","title":"<code>pypty.direct</code>","text":""},{"location":"reference/direct.html#pypty.direct.wdd","title":"<code>wdd</code>","text":"<p>Perform Wigner Distribution Deconvolution (WDD).</p> <p>This function applies Wigner Distribution Deconvolution to the provided data, allowing for enhanced reconstruction of complex objects and probes. It handles both GPU (via CuPy) and CPU (via NumPy) computations based on the availability of CuPy. The <code>pypty_params</code> dictionary must be prepared via the <code>initialize</code> module.</p> PARAMETER DESCRIPTION <code>pypty_params</code> <p>Dictionary containing calibrated parameters, including paths and settings for data processing.</p> <p> TYPE: <code>dict</code> </p> <code>eps_wiener</code> <p>Epsilon parameter for the Wiener filter. Default is 1e-3.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.001</code> </p> <code>thresh</code> <p>If provided, <code>eps_wiener</code> is ignored. Denominator values below this threshold are set to 1, and the corresponding numerator values are set to 0.</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> <code>save</code> <p>Whether to save output files (False by default). Ignored if <code>save_preprocessing_files</code> is specified in <code>pypty_params</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>deconvolved_object</code> <p>2D deconvolved complex object.</p> <p> TYPE: <code>ndarray</code> </p> <code>reconstructed_beam</code> <p>2D reconstructed complex beam.</p> <p> TYPE: <code>ndarray</code> </p> Notes <p>Make sure <code>pypty_params</code> includes all necessary paths and data arrays prior to calling this function.</p>"},{"location":"reference/dpc.html","title":"<code>pypty.dpc</code>","text":""},{"location":"reference/dpc.html#pypty.dpc.GetPLRotation","title":"<code>GetPLRotation</code>","text":"<p>Estimate rotation angle that minimizes the curl of the DPC signal.</p> PARAMETER DESCRIPTION <code>dpcx</code> <p>X-component of the DPC signal (2D array).</p> <p> TYPE: <code>ndarray</code> </p> <code>dpcy</code> <p>Y-component of the DPC signal (2D array).</p> <p> TYPE: <code>ndarray</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Optimal rotation angle in radians.</p>"},{"location":"reference/dpc.html#pypty.dpc.fft_based_dpc","title":"<code>fft_based_dpc</code>","text":"<p>FFT-based DPC phase reconstruction. If you setted up the pypty_params properly, you would only need to specify the hpass and lpass values, both are non-negative floats.</p> PARAMETER DESCRIPTION <code>pypty_params</code> <p>PyPty parameter dictionary with dataset and calibration settings.</p> <p> TYPE: <code>dict</code> </p> <code>hpass</code> <p>High-pass filtering coefficient (default is 0).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0</code> </p> <code>lpass</code> <p>Low-pass filtering coefficient (default is 0).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0</code> </p> <code>save</code> <p>Whether to save the reconstructed phase (default is False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>comx</code> <p>Precomputed center-of-mass x-component.</p> <p> TYPE: <code>ndarray or None</code> DEFAULT: <code>None</code> </p> <code>comy</code> <p>Precomputed center-of-mass y-component.</p> <p> TYPE: <code>ndarray or None</code> DEFAULT: <code>None</code> </p> <code>plot</code> <p>If True, display the phase reconstruction.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>pot</code> <p>Reconstructed 2D phase image.</p> <p> TYPE: <code>ndarray</code> </p> <code>pypty_params</code> <p>Updated parameter dictionary with computed COM and rotation angle.</p> <p> TYPE: <code>dict</code> </p>"},{"location":"reference/dpc.html#pypty.dpc.get_curl","title":"<code>get_curl</code>","text":"<p>Compute the standard deviation of the curl of a rotated DPC vector field. This is the objective function for minimization. This particular function was copied from a DPC plugin written by Jordan Hachtel.</p> PARAMETER DESCRIPTION <code>angle</code> <p>Rotation angle in radians.</p> <p> TYPE: <code>float</code> </p> <code>dpcx</code> <p>X-component of the DPC signal.</p> <p> TYPE: <code>ndarray</code> </p> <code>dpcy</code> <p>Y-component of the DPC signal.</p> <p> TYPE: <code>ndarray</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Standard deviation of the curl after rotation.</p>"},{"location":"reference/dpc.html#pypty.dpc.get_curl_derivative","title":"<code>get_curl_derivative</code>","text":"<p>Compute the derivative of the curl-based objective function with respect to rotation angle.</p> PARAMETER DESCRIPTION <code>angle</code> <p>Rotation angle in radians.</p> <p> TYPE: <code>float</code> </p> <code>dpcx</code> <p>X-component of the DPC signal.</p> <p> TYPE: <code>ndarray</code> </p> <code>dpcy</code> <p>Y-component of the DPC signal.</p> <p> TYPE: <code>ndarray</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Derivative of the curl-based objective function.</p>"},{"location":"reference/dpc.html#pypty.dpc.iterative_dpc","title":"<code>iterative_dpc</code>","text":"<p>Iterative DPC phase reconstruction. If you setted up the pypty_params properly, you would only need to specify the hpass and lpass values, both are non-negative floats.</p> PARAMETER DESCRIPTION <code>pypty_params</code> <p>PyPty parameter dictionary.</p> <p> TYPE: <code>dict</code> </p> <code>num_iterations</code> <p>Number of gradient descent iterations (default is 100).</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>beta</code> <p>Step reduction factor for backtracking (default is 0.5).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.5</code> </p> <code>hpass</code> <p>High-pass filtering coefficient (default is 0).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0</code> </p> <code>lpass</code> <p>Low-pass filtering coefficient (default is 0).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0</code> </p> <code>step_size</code> <p>Initial gradient descent step size (default is 0.1).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.1</code> </p> <code>COMx</code> <p>X-component of COM map.</p> <p> TYPE: <code>ndarray or None</code> DEFAULT: <code>None</code> </p> <code>COMy</code> <p>Y-component of COM map.</p> <p> TYPE: <code>ndarray or None</code> DEFAULT: <code>None</code> </p> <code>px_size</code> <p>Scan step size in \u00c5ngstr\u00f6ms.</p> <p> TYPE: <code>float or None</code> DEFAULT: <code>None</code> </p> <code>print_flag</code> <p>Whether to print progress information (default is False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>save</code> <p>Whether to save the result to disk (default is False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>select</code> <p>Optional binary mask to constrain reconstruction.</p> <p> TYPE: <code>ndarray or None</code> DEFAULT: <code>None</code> </p> <code>plot</code> <p>If True, plot the reconstruction result.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>use_backtracking</code> <p>Whether to use backtracking line search (default is True).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>pad_width</code> <p>Padding width to suppress FFT boundary artifacts (default is 5).</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> RETURNS DESCRIPTION <code>padded_phase</code> <p>Reconstructed 2D phase image.</p> <p> TYPE: <code>ndarray</code> </p>"},{"location":"reference/dpc.html#pypty.dpc.iterative_poisson_solver","title":"<code>iterative_poisson_solver</code>","text":"<p>Iterative solver for Poisson equation given a Laplacian map.</p> PARAMETER DESCRIPTION <code>laplace</code> <p>Input 2D array representing the Laplacian of the desired phase.</p> <p> TYPE: <code>ndarray</code> </p> <code>num_iterations</code> <p>Number of iterations (default is 100).</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>beta</code> <p>Step size reduction factor (default is 0.5).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.5</code> </p> <code>hpass</code> <p>High-pass filtering parameter (default is 0).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0</code> </p> <code>lpass</code> <p>Low-pass filtering parameter (default is 0).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0</code> </p> <code>select</code> <p>Optional binary mask to restrict updates.</p> <p> TYPE: <code>ndarray or None</code> DEFAULT: <code>None</code> </p> <code>px_size</code> <p>Pixel size in \u00c5ngstr\u00f6ms (default is 1).</p> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> <code>print_flag</code> <p>If True, print convergence status (default is False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>step_size</code> <p>Initial gradient descent step size (default is 0.1).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.1</code> </p> <code>use_backtracking</code> <p>Whether to use backtracking line search (default is True).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>pad_width</code> <p>Number of pixels to pad around the solution (default is 1).</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>xp</code> <p>Backend array library (NumPy or CuPy, default is NumPy).</p> <p> TYPE: <code>module</code> DEFAULT: <code>numpy</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>Reconstructed 2D phase from the input Laplacian.</p>"},{"location":"reference/fft.html","title":"<code>pypty.fft</code>","text":""},{"location":"reference/fft.html#pypty.fft.fft2","title":"<code>fft2</code>","text":"<p>Wrapper for fft2 function.</p> PARAMETER DESCRIPTION <code>arr</code> <p>Input array to be transformed.</p> <p> TYPE: <code>ndarray</code> </p> <code>axes</code> <p>Axes over which to compute the FFT (default is (0, 1)).</p> <p> TYPE: <code>tuple of int</code> DEFAULT: <code>(0, 1)</code> </p> <code>overwrite_x</code> <p>If True, allow overwriting the input array (default is False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>2D Fourier Transform of the input array.</p>"},{"location":"reference/fft.html#pypty.fft.fftfreq","title":"<code>fftfreq</code>","text":"<p>Wrapper for fftfreq function.</p> PARAMETER DESCRIPTION <code>length</code> <p>Length of the output array.</p> <p> TYPE: <code>int</code> </p> <code>sampling</code> <p>Sample spacing (default is 1).</p> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>Discrete Fourier Transform sample frequencies.</p>"},{"location":"reference/fft.html#pypty.fft.fftn","title":"<code>fftn</code>","text":"<p>Wrapper for fftn function.</p> PARAMETER DESCRIPTION <code>arr</code> <p>Input array to be transformed.</p> <p> TYPE: <code>ndarray</code> </p> <code>axes</code> <p>Axes over which to compute the FFT (default is (0, 1, 2)).</p> <p> TYPE: <code>tuple of int</code> DEFAULT: <code>(0, 1, 2)</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>N-dimensional Fourier Transform of the input array.</p>"},{"location":"reference/fft.html#pypty.fft.fftshift","title":"<code>fftshift</code>","text":"<p>Wrapper for fftshift function.</p> PARAMETER DESCRIPTION <code>array</code> <p>Input array to be shifted.</p> <p> TYPE: <code>ndarray</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>Shifted array.</p>"},{"location":"reference/fft.html#pypty.fft.ifft2","title":"<code>ifft2</code>","text":"<p>Wrapper for ifft2 function.</p> PARAMETER DESCRIPTION <code>arr</code> <p>Input array to be transformed.</p> <p> TYPE: <code>ndarray</code> </p> <code>axes</code> <p>Axes over which to compute the inverse FFT (default is (0, 1)).</p> <p> TYPE: <code>tuple of int</code> DEFAULT: <code>(0, 1)</code> </p> <code>overwrite_x</code> <p>If True, allow overwriting the input array (default is False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>2D inverse Fourier Transform of the input array.</p>"},{"location":"reference/fft.html#pypty.fft.ifft2_ishift","title":"<code>ifft2_ishift</code>","text":"<p>Wrapper for xp.fft.ifft2(xp.fft.ifftshift(...)) function.</p> PARAMETER DESCRIPTION <code>arr</code> <p>Input array to be transformed.</p> <p> TYPE: <code>ndarray</code> </p> <code>axes</code> <p>Axes over which to compute the inverse FFT (default is (0, 1)).</p> <p> TYPE: <code>tuple of int</code> DEFAULT: <code>(0, 1)</code> </p> <code>overwrite_x</code> <p>If True, allow overwriting the input array (default is False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>2D inverse Fourier Transform of the input array, after shifting.</p>"},{"location":"reference/fft.html#pypty.fft.ifftfreq","title":"<code>ifftfreq</code>","text":"<p>Wrapper for ifftfreq function.</p> PARAMETER DESCRIPTION <code>length</code> <p>Length of the output array.</p> <p> TYPE: <code>int</code> </p> <code>sampling</code> <p>Sample spacing (default is 1).</p> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>Discrete inverse Fourier Transform sample frequencies.</p>"},{"location":"reference/fft.html#pypty.fft.ifftn","title":"<code>ifftn</code>","text":"<p>Wrapper for ifftn function.</p> PARAMETER DESCRIPTION <code>arr</code> <p>Input array to be transformed.</p> <p> TYPE: <code>ndarray</code> </p> <code>axes</code> <p>Axes over which to compute the inverse FFT (default is (0, 1, 2)).</p> <p> TYPE: <code>tuple of int</code> DEFAULT: <code>(0, 1, 2)</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>N-dimensional inverse Fourier Transform of the input array.</p>"},{"location":"reference/fft.html#pypty.fft.ifftn_ishift","title":"<code>ifftn_ishift</code>","text":"<p>Wrapper for xp.fft.ifftn(xp.fft.ifftshift(...)) function.</p> PARAMETER DESCRIPTION <code>arr</code> <p>Input array to be transformed.</p> <p> TYPE: <code>ndarray</code> </p> <code>axes</code> <p>Axes over which to compute the inverse FFT (default is (0, 1, 2)).</p> <p> TYPE: <code>tuple of int</code> DEFAULT: <code>(0, 1, 2)</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>N-dimensional inverse Fourier Transform of the input array, after shifting.</p>"},{"location":"reference/fft.html#pypty.fft.ifftshift","title":"<code>ifftshift</code>","text":"<p>Wrapper for ifftshift function.</p> PARAMETER DESCRIPTION <code>array</code> <p>Input array to be inverse shifted.</p> <p> TYPE: <code>ndarray</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>Inverse shifted array.</p>"},{"location":"reference/fft.html#pypty.fft.shift_fft2","title":"<code>shift_fft2</code>","text":"<p>Wrapper for xp.fft.fftshift(xp.fft.fft2(...)) functions.</p> PARAMETER DESCRIPTION <code>arr</code> <p>Input array to be transformed.</p> <p> TYPE: <code>ndarray</code> </p> <code>axes</code> <p>Axes over which to compute the FFT (default is (0, 1)).</p> <p> TYPE: <code>tuple of int</code> DEFAULT: <code>(0, 1)</code> </p> <code>overwrite_x</code> <p>If True, allow overwriting the input array (default is False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>2D Fourier Transform of the input array, shifted.</p>"},{"location":"reference/fft.html#pypty.fft.shift_fftn","title":"<code>shift_fftn</code>","text":"<p>Wrapper for xp.fft.fftshift(xp.fft.fftn(...)) function.</p> PARAMETER DESCRIPTION <code>arr</code> <p>Input array to be transformed.</p> <p> TYPE: <code>ndarray</code> </p> <code>axes</code> <p>Axes over which to compute the FFT (default is (0, 1, 2)).</p> <p> TYPE: <code>tuple of int</code> DEFAULT: <code>(0, 1, 2)</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>N-dimensional Fourier Transform of the input array, shifted.</p>"},{"location":"reference/initialize.html","title":"<code>pypty.initialize</code>","text":""},{"location":"reference/initialize.html#pypty.initialize.append_aperture_to_params","title":"<code>append_aperture_to_params</code>","text":"<p>Append a measured aperture to the reconstruction parameters.</p> PARAMETER DESCRIPTION <code>pypty_params</code> <p>PyPty parameter dictionary.</p> <p> TYPE: <code>dict</code> </p> <code>mean_pattern</code> <p>Aperture image to be rescaled and added.</p> <p> TYPE: <code>ndarray</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Updated dictionary with aperture.</p>"},{"location":"reference/initialize.html#pypty.initialize.append_exp_params","title":"<code>append_exp_params</code>","text":"<p>Attach experimental parameters to a PyPty preset dictionary and callibrate an extisting PyPty preset to new data. </p> PARAMETER DESCRIPTION <code>experimental_params</code> <p>Dictionary containing experimental metadata and setup for PyPty reconstruction.</p> <p> TYPE: <code>dict</code> </p> <code>pypty_params</code> <p>Existing PyPty preset to update, a filepath to a preset, or None to create a new one.</p> <p> TYPE: <code>dict or str or None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Updated PyPty parameter dictionary.</p> Notes <p>experimental_params should contain following entries:</p> <pre><code>data_path - path to a PyPty-style 3d .h5 file [N_measurements, ky,kx] or .npy Nion-style 4d-stem dataset (or 3d .npy dataset)\n\nmasks - 3d numpy array or None. if data is compressed provide the virtual detectors (masks) shape should be [N_masks,ky,kx]\n\noutput_folder - path to an outputfolder where the results will be stored\n\npath_json - path to a nion-style json file with metadata (optional)\n\nacc_voltage - float, accelerating voltage in kV\n\nOne or multiple of the following callibrations:\n    rez_pixel_size_A - reciprocal pixel size in \u00c5^-1\n    rez_pixel_size_mrad - reciprocal pixel size in mrad\n    conv_semiangle_mrad - beam convergence semi-angle in mrad\n    aperture - (optional)- binary 2D mask\n    bright_threshold - threshold to estimate an aperture, everything above threshold times maximum value in a pacbed will be concidered as bright field disk.\n\ndata_pad - int, reciprocal space padding. If None (default), pading is 1/4 of the total width of a diffraction pattern\nupsample_pattern - int, default 1 (no upsampling)\n\naberrations - list or 1d numpy array containing beam aberrations (in \u00c5). Aberrations are stored in Krivanek notation, e.g. C10, C12a, C12b, C21a, C21b, C23a, C23b, C30 etc\n\ndefocus - float, default 0. Extra probe defocus besides the one contained in aberrations.\n\nscan_size - tuple of two ints, number of scan points along slow (y) and fast (x) axes. Optional. If no scan step or position grid is provided, it will be used to get the scan step\n\nscan_step_A - float, scan step (STEM pixel size) in \u00c5.\n\nfov_nm - float, FOV along the fast axis in nm.\n\nspecial_postions_A - 2d numpy array, default None. If you acquiered a data on a special non-rectangular grid, please specify the positions in \u00c5 via this array for all measurements in a following form: [y_0,x_0],[y_1,x_1],....[y_n,x_n]]\n\ntransform_axis_matrix- 2x2 matrix for postions transformation\n\nPLRotation_deg - float, rotation angle between scan and detector axes. Default None. If None, a DPC measurement will be exectuted to get this angle. !!!!!!! Note that negative PLRotation_deg values rotate scan counter clockwise and diffraction space clockwise !!!!!!!!!!!\n\nflip_ky - boolean Flag. Default is False. If no PyPty-style h5 data was created, this flag will flip the y-axis of diffraction patterns.\n\ntotal_thickness - total thickness of a sample in \u00c5. Has no effect if num_slices is 1 and propagation method (pypty_params entry) is multislice\n\nnum_slices - integer, number of slices, default is 1.\n\nplot - boolean Flag, default is True\n\nprint_flag - integer. Default is 1. If 0 nothing will be printed. 1 prints only thelatest state of the computation, 2 prints every state as a separate line. 3 prints the linesearch progress in iterative optimization. 4 prints everything that 3 does and if constraints are applied, it prints how they contribute so that a user can configure the weights properly.\n\nsave_preprocessing_files - Boolean Flag. Default is True.\n</code></pre>"},{"location":"reference/initialize.html#pypty.initialize.conjugate_beam","title":"<code>conjugate_beam</code>","text":"<p>Apply beam conjugation (flip defocus and aberrations).</p> PARAMETER DESCRIPTION <code>pypty_params</code> <p>PyPty parameter dictionary.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Updated dictionary with conjugated probe and CTF.</p>"},{"location":"reference/initialize.html#pypty.initialize.create_aberrations_chunks","title":"<code>create_aberrations_chunks</code>","text":"<p>Create chunks, i.e. multiple subscans with independent beam aberrations. Usefull for large fields of view where the beam is varyying. If applied, the iterative reconstruction will have the same beam in each subscan, but apply a different CTF in each of these regions.</p> PARAMETER DESCRIPTION <code>pypty_params</code> <p>PyPty parameter dictionary.</p> <p> TYPE: <code>dict</code> </p> <code>chop_size</code> <p>Size of each subscan region (in scan points).</p> <p> TYPE: <code>int</code> </p> <code>n_abs</code> <p>Number of aberration coefficients per region.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Updated parameter dictionary with aberration array and marker.</p>"},{"location":"reference/initialize.html#pypty.initialize.create_probe_marker_chunks","title":"<code>create_probe_marker_chunks</code>","text":"<p>Creates chunks, i.e. multiple subscans with independent beam aberrations. Usefull for large fields of view where the beam is varyying. If applied, the iterative reconstruction will have the a differenet beam in each of these subscans.</p> PARAMETER DESCRIPTION <code>pypty_params</code> <p>PyPty parameter dictionary.</p> <p> TYPE: <code>dict</code> </p> <code>chop_size</code> <p>Size of each subscan region (in scan points).</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Updated dictionary with probe marker.</p>"},{"location":"reference/initialize.html#pypty.initialize.create_pypty_data","title":"<code>create_pypty_data</code>","text":"<p>Create a PyPty-style <code>.h5</code> dataset from 4D-STEM data.</p> PARAMETER DESCRIPTION <code>data</code> <p>Path to <code>.h5</code> or <code>.npy</code> data file or a 4D numpy array [scan_y, scan_x, ky, kx].</p> <p> TYPE: <code>str or ndarray</code> </p> <code>path_output</code> <p>Output file path for the PyPty <code>.h5</code> dataset.</p> <p> TYPE: <code>str</code> </p> <code>swap_axes</code> <p>Swap the last two axes (kx, ky). Default is False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>flip_ky</code> <p>Flip the data along specific axes. Default is False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>flip_kx</code> <p>Flip the data along specific axes. Default is False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>flip_y</code> <p>Flip the data along specific axes. Default is False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>flip_x</code> <p>Flip the data along specific axes. Default is False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>comcalc_len</code> <p>Number of patterns to use to estimate center-of-mass. Default is 1000.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> <code>comx</code> <p>Predefined center-of-mass. If None, it will be computed.</p> <p> TYPE: <code>int or None</code> DEFAULT: <code>None</code> </p> <code>comy</code> <p>Predefined center-of-mass. If None, it will be computed.</p> <p> TYPE: <code>int or None</code> DEFAULT: <code>None</code> </p> <code>bin</code> <p>Spatial binning factor on the diffraction patterns. Default is 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>crop_left</code> <p>Crop edges of patterns. Defaults are None.</p> <p> TYPE: <code>int or None</code> DEFAULT: <code>None</code> </p> <code>crop_right</code> <p>Crop edges of patterns. Defaults are None.</p> <p> TYPE: <code>int or None</code> DEFAULT: <code>None</code> </p> <code>crop_top</code> <p>Crop edges of patterns. Defaults are None.</p> <p> TYPE: <code>int or None</code> DEFAULT: <code>None</code> </p> <code>crop_bottom</code> <p>Crop edges of patterns. Defaults are None.</p> <p> TYPE: <code>int or None</code> DEFAULT: <code>None</code> </p> <code>normalize</code> <p>Normalize pattern sums to 1. Default is False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>cutoff_ratio</code> <p>Mask out pixels farther than <code>cutoff_ratio \u00d7 max_radius</code>. Default is None.</p> <p> TYPE: <code>float or None</code> DEFAULT: <code>None</code> </p> <code>pad_k</code> <p>Padding to apply to diffraction patterns. Default is 0.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>data_dtype</code> <p>Output data type. Default is np.float32.</p> <p> TYPE: <code>dtype</code> DEFAULT: <code>float32</code> </p> <code>rescale</code> <p>Scale factor for intensity. Default is 1.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> <code>exist_ok</code> <p>If True, skip writing if file exists. Default is True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>None</code> Notes <p>Saves a <code>.h5</code> file containing processed 4D-STEM data with standardized formatting for PyPty.</p>"},{"location":"reference/initialize.html#pypty.initialize.create_sequence_from_points","title":"<code>create_sequence_from_points</code>","text":"<p>Create scan subsequence around specified feature points.</p> PARAMETER DESCRIPTION <code>pypty_params</code> <p>PyPty parameter dictionary.</p> <p> TYPE: <code>dict</code> </p> <code>yf</code> <p>Y-coordinates of feature points (in scan points).</p> <p> TYPE: <code>list of int</code> </p> <code>xf</code> <p>X-coordinates of feature points.</p> <p> TYPE: <code>list of int</code> </p> <code>width_roi</code> <p>Width of the reconstruction window around each point.</p> <p> TYPE: <code>int</code> DEFAULT: <code>20</code> </p> RETURNS DESCRIPTION <code>list</code> <p>List of scan indices to reconstruct.</p>"},{"location":"reference/initialize.html#pypty.initialize.create_sub_sequence","title":"<code>create_sub_sequence</code>","text":"<p>Define a measurement subsequence for local reconstructions.</p> PARAMETER DESCRIPTION <code>pypty_params</code> <p>PyPty parameter dictionary.</p> <p> TYPE: <code>dict</code> </p> <code>left</code> <p>Leftmost scan coordinate.</p> <p> TYPE: <code>int</code> </p> <code>top</code> <p>Top scan coordinate.</p> <p> TYPE: <code>int</code> </p> <code>width</code> <p>Width of subregion (in scan points).</p> <p> TYPE: <code>int</code> </p> <code>height</code> <p>Height of subregion (in scan points).</p> <p> TYPE: <code>int</code> </p> <code>sub</code> <p>Sampling factor (take every Nth point).</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Updated parameter dictionary with <code>sequence</code> key.</p>"},{"location":"reference/initialize.html#pypty.initialize.get_approx_beam_tilt","title":"<code>get_approx_beam_tilt</code>","text":"<p>Estimate scan-position-dependent beam tilt from PACBED. </p> PARAMETER DESCRIPTION <code>pypty_params</code> <p>PyPty parameter dictionary.</p> <p> TYPE: <code>dict</code> </p> <code>power</code> <p>Degree of polynomial fitting.</p> <p> TYPE: <code>int or str</code> DEFAULT: <code>3</code> </p> <code>make_binary</code> <p>If True or float &gt; 0, binarize patterns.</p> <p> TYPE: <code>bool or float</code> DEFAULT: <code>False</code> </p> <code>percentile_filter_value</code> <p>Value for optional percentile filtering.</p> <p> TYPE: <code>float or None</code> DEFAULT: <code>None</code> </p> <code>percentile_filter_size</code> <p>Filter size if filtering is enabled.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Updated dictionary with estimated tilts.</p>"},{"location":"reference/initialize.html#pypty.initialize.get_focussed_probe_from_vacscan","title":"<code>get_focussed_probe_from_vacscan</code>","text":"<p>Reconstruct a focused probe from a vacuum PACBED pattern.</p> PARAMETER DESCRIPTION <code>pypty_params</code> <p>PyPty parameter dictionary.</p> <p> TYPE: <code>dict</code> </p> <code>mean_pattern</code> <p>Measured PACBED from vacuum.</p> <p> TYPE: <code>ndarray</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Updated dictionary with a probe estimate.</p>"},{"location":"reference/initialize.html#pypty.initialize.get_grid_for_upsampled_image","title":"<code>get_grid_for_upsampled_image</code>","text":"<p>Map coordinates of an upsampled image onto the reconstruction grid.</p> <p>This function calculates where pixel of an arbitary image (e.g. upsampled tcBF image) will land on a grid corresponding to a ptychographic reconstruction.</p> PARAMETER DESCRIPTION <code>pypty_params</code> <p>Dictionary of PyPty reconstruction parameters.</p> <p> TYPE: <code>dict</code> </p> <code>image</code> <p>2D image (e.g., upsampled tcBF) to map.</p> <p> TYPE: <code>ndarray</code> </p> <code>image_pixel_size</code> <p>Pixel size of the image in \u00c5.</p> <p> TYPE: <code>float</code> </p> <code>left_zero_of_scan_grid</code> <p>Pixel offset on left side of image relative to scan grid. Default is 0.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>top_zero_of_scan_grid</code> <p>Pixel offset on top side of image relative to scan grid. Default is 0.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>sc</code> <p>Array of pixel coordinates [[y, x], ...] in reconstruction grid units.</p> <p> TYPE: <code>ndarray</code> </p>"},{"location":"reference/initialize.html#pypty.initialize.get_offset","title":"<code>get_offset</code>","text":"<p>Compute pixel offsets between scan grid and reconstruction grid. In PyPty framework, scan grid is usually rotated to compensate the misalignment between scan- and detector- axes. Also, a reconstruction grid is larger than the scanned FOV, this is done to accomodate the extent of the probe. </p> PARAMETER DESCRIPTION <code>x_range</code> <p>Scan dimensions.</p> <p> TYPE: <code>int</code> </p> <code>y_range</code> <p>Scan dimensions.</p> <p> TYPE: <code>int</code> </p> <code>scan_step_A</code> <p>STEM scan step size in \u00c5.</p> <p> TYPE: <code>float</code> </p> <code>detector_pixel_size_rezA</code> <p>Reciprocal space pixel size in \u00c5\u207b\u00b9.</p> <p> TYPE: <code>float</code> </p> <code>patternshape</code> <p>Shape of diffraction patterns.</p> <p> TYPE: <code>tuple</code> </p> <code>rot_angle_deg</code> <p>Rotation between scan and detector axes (degrees).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>offy, offx : float</code> <p>Offset values (in reconstruction pixels).</p>"},{"location":"reference/initialize.html#pypty.initialize.get_positions_pixel_size","title":"<code>get_positions_pixel_size</code>","text":"<p>Generate scan positions in reconstruction pixel units.</p> PARAMETER DESCRIPTION <code>x_range</code> <p>Scan grid size.</p> <p> TYPE: <code>int</code> </p> <code>y_range</code> <p>Scan grid size.</p> <p> TYPE: <code>int</code> </p> <code>scan_step_A</code> <p>STEM scan step size (\u00c5).</p> <p> TYPE: <code>float</code> </p> <code>detector_pixel_size_rezA</code> <p>Pixel size in reciprocal space (\u00c5\u207b\u00b9).</p> <p> TYPE: <code>float</code> </p> <code>patternshape</code> <p>Shape of the diffraction pattern.</p> <p> TYPE: <code>tuple</code> </p> <code>rot_angle_deg</code> <p>Scan-detector rotation angle in degrees. Default is 0.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0</code> </p> <code>flip_x</code> <p>Flip scan axes. Default is False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>flip_y</code> <p>Flip scan axes. Default is False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>print_flag</code> <p>Print pixel size. Default is False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>transform_axis_matrix</code> <p>Optional 2x2 matrix to apply to positions.</p> <p> TYPE: <code>array_like</code> DEFAULT: <code>eye(2)</code> </p> RETURNS DESCRIPTION <code>positions</code> <p>Scan positions in reconstruction pixels.</p> <p> TYPE: <code>ndarray</code> </p> <code>pixel_size</code> <p>Size of one reconstruction pixel in \u00c5.</p> <p> TYPE: <code>float</code> </p>"},{"location":"reference/initialize.html#pypty.initialize.get_ptycho_obj_from_scan","title":"<code>get_ptycho_obj_from_scan</code>","text":"<p>Construct an initial object guess using interpolated phase and amplitude maps. You can use output of dpc, wdd of tcBF reconstructions to generate it.</p> PARAMETER DESCRIPTION <code>params</code> <p>PyPty parameter dictionary.</p> <p> TYPE: <code>dict</code> </p> <code>num_slices</code> <p>Number of slices or \"auto\" to estimate from max phase shift.</p> <p> TYPE: <code>int or str</code> DEFAULT: <code>None</code> </p> <code>array_phase</code> <p>2D phase map to interpolate.</p> <p> TYPE: <code>ndarray</code> DEFAULT: <code>None</code> </p> <code>array_abs</code> <p>2D amplitude map to interpolate.</p> <p> TYPE: <code>ndarray</code> DEFAULT: <code>None</code> </p> <code>scale_phase</code> <p>Scale factor for phase.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> <code>scale_abs</code> <p>Scale factor for amplitude.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> <code>scan_array_A</code> <p>Spatial reference grid for the input maps (in \u00c5).</p> <p> TYPE: <code>ndarray or None</code> DEFAULT: <code>None</code> </p> <code>fill_value_type</code> <p>Padding strategy outside scanned region: None, \"edge\", or \"median\".</p> <p> TYPE: <code>str or None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Updated PyPty parameter dictionary with object guess.</p>"},{"location":"reference/initialize.html#pypty.initialize.rotate_scan_grid","title":"<code>rotate_scan_grid</code>","text":"<p>Apply a rigid rotation to the scan grid.</p> PARAMETER DESCRIPTION <code>pypty_params</code> <p>PyPty parameter dictionary.</p> <p> TYPE: <code>dict</code> </p> <code>angle_deg</code> <p>Rotation angle in degrees.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Updated dictionary with rotated positions and angle.</p>"},{"location":"reference/initialize.html#pypty.initialize.tiltbeamtodata","title":"<code>tiltbeamtodata</code>","text":"<p>Align the probe momentum to the center of the measured PACBED pattern.</p> PARAMETER DESCRIPTION <code>pypty_params</code> <p>PyPty parameter dictionary.</p> <p> TYPE: <code>dict</code> </p> <code>align_type</code> <p>Type of alignment (\"com\" or \"cross_corr\").</p> <p> TYPE: <code>str</code> DEFAULT: <code>'com'</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Updated dictionary with shifted probe.</p>"},{"location":"reference/iterative.html","title":"<code>pypty.iterative</code>","text":""},{"location":"reference/iterative.html#pypty.iterative.bfgs_update","title":"<code>bfgs_update</code>","text":"<p>This is one of the core functions of PyPty. It performs updates of all active reconstruction parameters (object, probe, positions, tilts, etc.) via l-BFGS algorithm.</p> PARAMETER DESCRIPTION <code>Params</code> <p>Way to many to describe right now</p> <p> TYPE: <code>list</code> </p> RETURNS DESCRIPTION <code>total_loss</code> <p>Total loss value.</p> <p> TYPE: <code>float</code> </p> <code>this_sse</code> <p>Sum of squared errors.</p> <p> TYPE: <code>float</code> </p> <code>constraint_contributions</code> <p>List of reg. constraint values for this epoch</p> <p> TYPE: <code>list</code> </p> <code>actual_step</code> <p>Linesearch step that was found during this iteration</p> <p> TYPE: <code>float</code> </p> <code>count</code> <p>Number of linesearch iterations (calls of loss_and_direction) that was required during this epoch</p> <p> TYPE: <code>int</code> </p> <code>d_value</code> <p>Value of the direction derivative at this epoch</p> <p> TYPE: <code>float</code> </p> <code>new_d_value</code> <p>Value of the direction derivative at the newly estimated point</p> <p> TYPE: <code>float</code> </p> <code>warnings</code> <p>Warnings during this epoch</p> <p> TYPE: <code>string</code> </p>"},{"location":"reference/iterative.html#pypty.iterative.reset_bfgs_history","title":"<code>reset_bfgs_history</code>","text":"<p>Reset a global variable history_bfgs that contains information about previous steps.</p>"},{"location":"reference/iterative.html#pypty.iterative.run","title":"<code>run</code>","text":"<p>Launch iterative reconstuction.</p> PARAMETER DESCRIPTION <code>pypty_params</code> <p>Dictionary containing calibrated parameters, including paths and settings for data processing.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>None</code> Notes <p>pypty_params dictionary can be constructed from a predefined preset and a given dataset via append_exp_params() function. Otherwise one can create the  pypty_params dictionary by hand. For more info about creating pypty_params from scratch please reffer to https://github.com/Anton-Gladyshev/pypty/tree/main (there is a .md file lisitng all possible entries). Otherwise contact Anton Gladyshev directly.</p>"},{"location":"reference/multicore.html","title":"<code>pypty.multicore</code>","text":""},{"location":"reference/multicore.html#pypty.multicore.better_multislice","title":"<code>better_multislice</code>","text":"<p>Simulate multislice wave propagation using an additive split-step method (5th order precision with respect to slice thickness).</p> PARAMETER DESCRIPTION <code>full_probe</code> <p>Probe wavefunction with shape [N_batch, y,x, modes]</p> <p> TYPE: <code>ndarray</code> </p> <code>this_obj_chopped</code> <p>Object slices with shape [N_batch, y,x, z, modes].</p> <p> TYPE: <code>ndarray</code> </p> <code>num_slices</code> <p>Number of object slices.</p> <p> TYPE: <code>int</code> </p> <code>n_obj_modes</code> <p>Number of object modes.</p> <p> TYPE: <code>int</code> </p> <code>n_probe_modes</code> <p>Number of probe modes.</p> <p> TYPE: <code>int</code> </p> <code>this_distances</code> <p>Slice thicknesses.</p> <p> TYPE: <code>ndarray</code> </p> <code>this_wavelength</code> <p>Electron wavelength.</p> <p> TYPE: <code>float</code> </p> <code>q2</code> <p>Spatial frequency grids.</p> <p> TYPE: <code>ndarray</code> </p> <code>qx</code> <p>Spatial frequency grids.</p> <p> TYPE: <code>ndarray</code> </p> <code>qy</code> <p>Spatial frequency grids.</p> <p> TYPE: <code>ndarray</code> </p> <code>exclude_mask</code> <p>Mask to exclude undesired frequencies.</p> <p> TYPE: <code>ndarray</code> </p> <code>is_single_dist</code> <p>If True, use the same distance for all slices.</p> <p> TYPE: <code>bool</code> </p> <code>this_tan_x</code> <p>Beam tilts with shape N_batch</p> <p> TYPE: <code>ndarray</code> </p> <code>this_tan_y</code> <p>Beam tilts with shape N_batch</p> <p> TYPE: <code>ndarray</code> </p> <code>damping_cutoff_multislice</code> <p>Damping frequency cutoff.</p> <p> TYPE: <code>float</code> </p> <code>smooth_rolloff</code> <p>Rolloff rate for the damping filter.</p> <p> TYPE: <code>float</code> </p> <code>master_propagator_phase_space</code> <p>Full propagator in Fourier space (optional).</p> <p> TYPE: <code>ndarray or None</code> </p> <code>half_master_propagator_phase_space</code> <p>Half-step propagator (optional).</p> <p> TYPE: <code>ndarray or None</code> </p> <code>mask_clean</code> <p>Clean propagation mask.</p> <p> TYPE: <code>ndarray</code> </p> <code>waves_multislice</code> <p>This array contains interediate exit-waves</p> <p> TYPE: <code>ndarray</code> </p> <code>wave</code> <p>This array contains final exit-wave</p> <p> TYPE: <code>ndarray</code> </p> <code>default_float</code> <p>Numerical types.</p> <p> TYPE: <code>dtype</code> </p> <code>default_complex</code> <p>Numerical types.</p> <p> TYPE: <code>dtype</code> </p> RETURNS DESCRIPTION <code>waves_multislice</code> <p>Multislice stack of propagated waves.</p> <p> TYPE: <code>ndarray</code> </p> <code>wave</code> <p>Final exit wave.</p> <p> TYPE: <code>ndarray</code> </p>"},{"location":"reference/multicore.html#pypty.multicore.better_multislice_grads","title":"<code>better_multislice_grads</code>","text":"<p>Compute gradients of object, probe, and tilts for the \"better_multislice\" wave propagation model.</p> PARAMETER DESCRIPTION <code>dLoss_dP_out</code> <p>Gradient of the loss with respect to the final exit wave.</p> <p> TYPE: <code>ndarray</code> </p> <code>waves_multislice</code> <p>Stack of intermediate wavefields saved during the forward pass.</p> <p> TYPE: <code>ndarray</code> </p> <code>this_obj_chopped</code> <p>The sliced object with shape [batch, y, x, z, modes].</p> <p> TYPE: <code>ndarray</code> </p> <code>object_grad</code> <p>Gradient accumulator for the object slices.</p> <p> TYPE: <code>ndarray</code> </p> <code>tilts_grad</code> <p>Gradient accumulator for the tilts.</p> <p> TYPE: <code>ndarray</code> </p> <code>is_single_dist</code> <p>Whether all slices have the same thickness.</p> <p> TYPE: <code>bool</code> </p> <code>this_distances</code> <p>Thickness per slice.</p> <p> TYPE: <code>ndarray</code> </p> <code>exclude_mask</code> <p>Frequency mask used in propagation.</p> <p> TYPE: <code>ndarray</code> </p> <code>this_wavelength</code> <p>Wavelength of the probe in \u00c5ngstr\u00f6ms.</p> <p> TYPE: <code>float</code> </p> <code>q2</code> <p>Spatial frequency grids.</p> <p> TYPE: <code>ndarray</code> </p> <code>qx</code> <p>Spatial frequency grids.</p> <p> TYPE: <code>ndarray</code> </p> <code>qy</code> <p>Spatial frequency grids.</p> <p> TYPE: <code>ndarray</code> </p> <code>this_tan_x</code> <p>Beam tilt values per batch.</p> <p> TYPE: <code>float</code> </p> <code>this_tan_y</code> <p>Beam tilt values per batch.</p> <p> TYPE: <code>float</code> </p> <code>num_slices</code> <p>Number of slices in the object.</p> <p> TYPE: <code>int</code> </p> <code>n_probe_modes</code> <p>Number of probe modes.</p> <p> TYPE: <code>int</code> </p> <code>n_obj_modes</code> <p>Number of object modes.</p> <p> TYPE: <code>int</code> </p> <code>tiltind</code> <p>Index for updating <code>tilts_grad</code>.</p> <p> TYPE: <code>int</code> </p> <code>this_step_tilts</code> <p>Whether to update tilts (0 = off).</p> <p> TYPE: <code>int</code> </p> <code>master_propagator_phase_space</code> <p>Full propagator for the current slice.</p> <p> TYPE: <code>ndarray</code> </p> <code>half_master_propagator_phase_space</code> <p>Half-step propagator.</p> <p> TYPE: <code>ndarray</code> </p> <code>damping_cutoff_multislice</code> <p>Cutoff for high frequencies in damping.</p> <p> TYPE: <code>float</code> </p> <code>smooth_rolloff</code> <p>Smoothing width for damping filter.</p> <p> TYPE: <code>float</code> </p> <code>tilt_mode</code> <p>Specifies which tilts to optimize.</p> <p> TYPE: <code>int</code> </p> <code>compute_batch</code> <p>Number of scan positions processed in batch.</p> <p> TYPE: <code>int</code> </p> <code>mask_clean</code> <p>FFT mask used to remove unstable frequencies.</p> <p> TYPE: <code>ndarray</code> </p> <code>masked_pixels_y</code> <p>Indices to scatter object gradients into global coordinates.</p> <p> TYPE: <code>ndarray</code> </p> <code>masked_pixels_x</code> <p>Indices to scatter object gradients into global coordinates.</p> <p> TYPE: <code>ndarray</code> </p> <code>default_float</code> <p>Floating point precision.</p> <p> TYPE: <code>dtype</code> </p> <code>default_complex</code> <p>Complex precision.</p> <p> TYPE: <code>dtype</code> </p> RETURNS DESCRIPTION <code>object_grad</code> <p>Updated gradient of the object slices.</p> <p> TYPE: <code>ndarray</code> </p> <code>interm_probe_grad</code> <p>Gradient of the probe (summed over object modes).</p> <p> TYPE: <code>ndarray</code> </p> <code>tilts_grad</code> <p>Updated tilt gradients.</p> <p> TYPE: <code>ndarray</code> </p>"},{"location":"reference/multicore.html#pypty.multicore.multislice","title":"<code>multislice</code>","text":"<p>Simulate multislice wave propagation using a classic split-step integrator (2nd order precision with respect to slice thickness if beam is optimized).</p> PARAMETER DESCRIPTION <code>full_probe</code> <p>Probe wavefunction with shape [N_batch, y,x, modes]</p> <p> TYPE: <code>ndarray</code> </p> <code>this_obj_chopped</code> <p>Object slices with shape [N_batch, y,x, z, modes].</p> <p> TYPE: <code>ndarray</code> </p> <code>num_slices</code> <p>Number of object slices.</p> <p> TYPE: <code>int</code> </p> <code>n_obj_modes</code> <p>Number of object modes.</p> <p> TYPE: <code>int</code> </p> <code>n_probe_modes</code> <p>Number of probe modes.</p> <p> TYPE: <code>int</code> </p> <code>this_distances</code> <p>Slice thicknesses.</p> <p> TYPE: <code>ndarray</code> </p> <code>this_wavelength</code> <p>Electron wavelength.</p> <p> TYPE: <code>float</code> </p> <code>q2</code> <p>Spatial frequency grids.</p> <p> TYPE: <code>ndarray</code> </p> <code>qx</code> <p>Spatial frequency grids.</p> <p> TYPE: <code>ndarray</code> </p> <code>qy</code> <p>Spatial frequency grids.</p> <p> TYPE: <code>ndarray</code> </p> <code>exclude_mask</code> <p>Mask to exclude undesired frequencies.</p> <p> TYPE: <code>ndarray</code> </p> <code>is_single_dist</code> <p>If True, use the same distance for all slices.</p> <p> TYPE: <code>bool</code> </p> <code>this_tan_x</code> <p>Beam tilts with shape N_batch</p> <p> TYPE: <code>ndarray</code> </p> <code>this_tan_y</code> <p>Beam tilts with shape N_batch</p> <p> TYPE: <code>ndarray</code> </p> <code>damping_cutoff_multislice</code> <p>Damping frequency cutoff.</p> <p> TYPE: <code>float</code> </p> <code>smooth_rolloff</code> <p>Rolloff rate for the damping filter.</p> <p> TYPE: <code>float</code> </p> <code>master_propagator_phase_space</code> <p>Full propagator in Fourier space (optional).</p> <p> TYPE: <code>ndarray or None</code> </p> <code>half_master_propagator_phase_space</code> <p>Half-step propagator (optional).</p> <p> TYPE: <code>ndarray or None</code> </p> <code>mask_clean</code> <p>Clean propagation mask.</p> <p> TYPE: <code>ndarray</code> </p> <code>waves_multislice</code> <p>This array contains interediate exit-waves</p> <p> TYPE: <code>ndarray</code> </p> <code>wave</code> <p>This array contains final exit-wave</p> <p> TYPE: <code>ndarray</code> </p> <code>default_float</code> <p>Numerical types.</p> <p> TYPE: <code>dtype</code> </p> <code>default_complex</code> <p>Numerical types.</p> <p> TYPE: <code>dtype</code> </p> RETURNS DESCRIPTION <code>waves_multislice</code> <p>Multislice stack of propagated waves.</p> <p> TYPE: <code>ndarray</code> </p> <code>wave</code> <p>Final exit wave.</p> <p> TYPE: <code>ndarray</code> </p>"},{"location":"reference/multicore.html#pypty.multicore.multislice_grads","title":"<code>multislice_grads</code>","text":"<p>Compute gradients for classic multislice propagation model (object, probe, and tilts).</p> PARAMETER DESCRIPTION <code>dLoss_dP_out</code> <p>Gradient of the loss with respect to the final propagated wave.</p> <p> TYPE: <code>ndarray</code> </p> <code>waves_multislice</code> <p>Intermediate wave stack from the forward multislice pass.</p> <p> TYPE: <code>ndarray</code> </p> <code>this_obj_chopped</code> <p>4D sliced object [batch, y, x, z, modes].</p> <p> TYPE: <code>ndarray</code> </p> <code>object_grad</code> <p>Gradient accumulator for object slices.</p> <p> TYPE: <code>ndarray</code> </p> <code>tilts_grad</code> <p>Accumulator for tilt gradients.</p> <p> TYPE: <code>ndarray</code> </p> <code>is_single_dist</code> <p>If True, slice distances are constant.</p> <p> TYPE: <code>bool</code> </p> <code>this_distances</code> <p>Per-slice thicknesses.</p> <p> TYPE: <code>ndarray</code> </p> <code>exclude_mask</code> <p>Frequency mask for FFT operations.</p> <p> TYPE: <code>ndarray</code> </p> <code>this_wavelength</code> <p>Probe wavelength (\u00c5).</p> <p> TYPE: <code>float</code> </p> <code>q2</code> <p>Spatial frequency grids.</p> <p> TYPE: <code>ndarray</code> </p> <code>qx</code> <p>Spatial frequency grids.</p> <p> TYPE: <code>ndarray</code> </p> <code>qy</code> <p>Spatial frequency grids.</p> <p> TYPE: <code>ndarray</code> </p> <code>this_tan_x</code> <p>Beam tilt values per batch.</p> <p> TYPE: <code>float</code> </p> <code>this_tan_y</code> <p>Beam tilt values per batch.</p> <p> TYPE: <code>float</code> </p> <code>num_slices</code> <p>Number of slices.</p> <p> TYPE: <code>int</code> </p> <code>n_obj_modes</code> <p>Number of object modes.</p> <p> TYPE: <code>int</code> </p> <code>tiltind</code> <p>Index in tilt update array.</p> <p> TYPE: <code>int</code> </p> <code>master_propagator_phase_space</code> <p>Full Fourier propagation kernel.</p> <p> TYPE: <code>ndarray</code> </p> <code>this_step_tilts</code> <p>Whether tilt gradient is updated.</p> <p> TYPE: <code>int</code> </p> <code>damping_cutoff_multislice</code> <p>Damping cutoff for high-frequency noise.</p> <p> TYPE: <code>float</code> </p> <code>smooth_rolloff</code> <p>Width of damping transition.</p> <p> TYPE: <code>float</code> </p> <code>tilt_mode</code> <p>Mode selector for tilt optimization.</p> <p> TYPE: <code>int</code> </p> <code>compute_batch</code> <p>Current batch size.</p> <p> TYPE: <code>int</code> </p> <code>mask_clean</code> <p>FFT domain mask.</p> <p> TYPE: <code>ndarray</code> </p> <code>this_step_probe</code> <p>Whether to compute probe gradient.</p> <p> TYPE: <code>int</code> </p> <code>this_step_obj</code> <p>Whether to compute object gradient.</p> <p> TYPE: <code>int</code> </p> <code>this_step_pos_correction</code> <p>(Unused) Flag for positional corrections.</p> <p> TYPE: <code>int</code> </p> <code>masked_pixels_y</code> <p>Indices for applying gradients to global object.</p> <p> TYPE: <code>ndarray</code> </p> <code>masked_pixels_x</code> <p>Indices for applying gradients to global object.</p> <p> TYPE: <code>ndarray</code> </p> <code>default_float</code> <p>Floating-point type.</p> <p> TYPE: <code>dtype</code> </p> <code>default_complex</code> <p>Complex type.</p> <p> TYPE: <code>dtype</code> </p> <code>helper_flag_4</code> <p>If True, return probe gradient; else return None.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>object_grad</code> <p>Gradient for object slices.</p> <p> TYPE: <code>ndarray</code> </p> <code>interm_probe_grad</code> <p>Gradient for input probe (if helper_flag_4 is True).</p> <p> TYPE: <code>ndarray or None</code> </p> <code>tilts_grad</code> <p>Updated tilt gradient.</p> <p> TYPE: <code>ndarray</code> </p>"},{"location":"reference/multicore.html#pypty.multicore.scatteradd","title":"<code>scatteradd</code>","text":"<p>Adds batched object updates to their respective positions in the full object array. This wrapper is needed to support older CuPy versions.</p> PARAMETER DESCRIPTION <code>full</code> <p>Full object gradient array.</p> <p> TYPE: <code>ndarray</code> </p> <code>masky</code> <p>Index array for the y-axis.</p> <p> TYPE: <code>ndarray</code> </p> <code>maskx</code> <p>Index array for the x-axis.</p> <p> TYPE: <code>ndarray</code> </p> <code>chop</code> <p>Batched gradients to scatter-add.</p> <p> TYPE: <code>ndarray</code> </p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/multicore.html#pypty.multicore.yoshida_multislice","title":"<code>yoshida_multislice</code>","text":"<p>Simulate multislice wave propagation using an yoshida integrator (5th order precision with respect to slice thickness).</p> PARAMETER DESCRIPTION <code>full_probe</code> <p>Probe wavefunction with shape [N_batch, y,x, modes]</p> <p> TYPE: <code>ndarray</code> </p> <code>this_obj_chopped</code> <p>Object slices with shape [N_batch, y,x, z, modes].</p> <p> TYPE: <code>ndarray</code> </p> <code>num_slices</code> <p>Number of object slices.</p> <p> TYPE: <code>int</code> </p> <code>n_obj_modes</code> <p>Number of object modes.</p> <p> TYPE: <code>int</code> </p> <code>n_probe_modes</code> <p>Number of probe modes.</p> <p> TYPE: <code>int</code> </p> <code>this_distances</code> <p>Slice thicknesses.</p> <p> TYPE: <code>ndarray</code> </p> <code>this_wavelength</code> <p>Electron wavelength.</p> <p> TYPE: <code>float</code> </p> <code>q2</code> <p>Spatial frequency grids.</p> <p> TYPE: <code>ndarray</code> </p> <code>qx</code> <p>Spatial frequency grids.</p> <p> TYPE: <code>ndarray</code> </p> <code>qy</code> <p>Spatial frequency grids.</p> <p> TYPE: <code>ndarray</code> </p> <code>exclude_mask</code> <p>Mask to exclude undesired frequencies.</p> <p> TYPE: <code>ndarray</code> </p> <code>is_single_dist</code> <p>If True, use the same distance for all slices.</p> <p> TYPE: <code>bool</code> </p> <code>this_tan_x</code> <p>Beam tilts with shape N_batch</p> <p> TYPE: <code>ndarray</code> </p> <code>this_tan_y</code> <p>Beam tilts with shape N_batch</p> <p> TYPE: <code>ndarray</code> </p> <code>damping_cutoff_multislice</code> <p>Damping frequency cutoff.</p> <p> TYPE: <code>float</code> </p> <code>smooth_rolloff</code> <p>Rolloff rate for the damping filter.</p> <p> TYPE: <code>float</code> </p> <code>master_propagator_phase_space</code> <p>Full propagator in Fourier space (optional).</p> <p> TYPE: <code>ndarray or None</code> </p> <code>half_master_propagator_phase_space</code> <p>Half-step propagator (optional).</p> <p> TYPE: <code>ndarray or None</code> </p> <code>mask_clean</code> <p>Clean propagation mask.</p> <p> TYPE: <code>ndarray</code> </p> <code>waves_multislice</code> <p>This array contains interediate exit-waves</p> <p> TYPE: <code>ndarray</code> </p> <code>wave</code> <p>This array contains final exit-wave</p> <p> TYPE: <code>ndarray</code> </p> <code>default_float</code> <p>Numerical types.</p> <p> TYPE: <code>dtype</code> </p> <code>default_complex</code> <p>Numerical types.</p> <p> TYPE: <code>dtype</code> </p> RETURNS DESCRIPTION <code>waves_multislice</code> <p>Multislice stack of propagated waves.</p> <p> TYPE: <code>ndarray</code> </p> <code>wave</code> <p>Final exit wave.</p> <p> TYPE: <code>ndarray</code> </p>"},{"location":"reference/multicore.html#pypty.multicore.yoshida_multislice_grads","title":"<code>yoshida_multislice_grads</code>","text":"<p>Compute gradients for object, probe, and tilt parameters using Yoshida multislice propagation.</p> PARAMETER DESCRIPTION <code>dLoss_dP_out</code> <p>Gradient of the loss with respect to the output wave.</p> <p> TYPE: <code>ndarray</code> </p> <code>waves_multislice</code> <p>Stored intermediate wavefields from forward Yoshida multislice pass.</p> <p> TYPE: <code>ndarray</code> </p> <code>this_obj_chopped</code> <p>Object slices with shape [batch, y, x, z, modes].</p> <p> TYPE: <code>ndarray</code> </p> <code>object_grad</code> <p>Gradient buffer for object update.</p> <p> TYPE: <code>ndarray</code> </p> <code>tilts_grad</code> <p>Gradient buffer for tilt update.</p> <p> TYPE: <code>ndarray</code> </p> <code>is_single_dist</code> <p>Whether slice distances are constant.</p> <p> TYPE: <code>bool</code> </p> <code>this_distances</code> <p>Thickness of each slice.</p> <p> TYPE: <code>ndarray</code> </p> <code>exclude_mask</code> <p>FFT mask for excluding unstable frequencies.</p> <p> TYPE: <code>ndarray</code> </p> <code>this_wavelength</code> <p>Probe wavelength in \u00c5ngstr\u00f6ms.</p> <p> TYPE: <code>float</code> </p> <code>q2</code> <p>FFT spatial frequency grids.</p> <p> TYPE: <code>ndarray</code> </p> <code>qx</code> <p>FFT spatial frequency grids.</p> <p> TYPE: <code>ndarray</code> </p> <code>qy</code> <p>FFT spatial frequency grids.</p> <p> TYPE: <code>ndarray</code> </p> <code>this_tan_x</code> <p>Beam tilts (tangent of the angle).</p> <p> TYPE: <code>float</code> </p> <code>this_tan_y</code> <p>Beam tilts (tangent of the angle).</p> <p> TYPE: <code>float</code> </p> <code>num_slices</code> <p>Number of object slices.</p> <p> TYPE: <code>int</code> </p> <code>n_probe_modes</code> <p>Number of probe modes.</p> <p> TYPE: <code>int</code> </p> <code>n_obj_modes</code> <p>Number of object modes.</p> <p> TYPE: <code>int</code> </p> <code>tiltind</code> <p>Index of current tilt in <code>tilts_grad</code>.</p> <p> TYPE: <code>int</code> </p> <code>this_step_tilts</code> <p>Whether tilt updates are enabled.</p> <p> TYPE: <code>int</code> </p> <code>master_propagator_phase_space</code> <p>Full propagation kernel in Fourier domain.</p> <p> TYPE: <code>ndarray</code> </p> <code>half_master_propagator_phase_space</code> <p>Half-step propagation kernel.</p> <p> TYPE: <code>ndarray</code> </p> <code>damping_cutoff_multislice</code> <p>Frequency cutoff for damping high frequencies.</p> <p> TYPE: <code>float</code> </p> <code>smooth_rolloff</code> <p>Rolloff profile width for damping.</p> <p> TYPE: <code>float</code> </p> <code>tilt_mode</code> <p>Determines which tilt parameters to optimize.</p> <p> TYPE: <code>int</code> </p> <code>compute_batch</code> <p>Number of scan points in the current batch.</p> <p> TYPE: <code>int</code> </p> <code>mask_clean</code> <p>Fourier domain mask to stabilize calculations.</p> <p> TYPE: <code>ndarray</code> </p> <code>masked_pixels_y</code> <p>Indices for inserting gradients into global object.</p> <p> TYPE: <code>ndarray</code> </p> <code>masked_pixels_x</code> <p>Indices for inserting gradients into global object.</p> <p> TYPE: <code>ndarray</code> </p> <code>default_float</code> <p>Float precision.</p> <p> TYPE: <code>dtype</code> </p> <code>default_complex</code> <p>Complex precision.</p> <p> TYPE: <code>dtype</code> </p> RETURNS DESCRIPTION <code>object_grad</code> <p>Updated object gradient.</p> <p> TYPE: <code>ndarray</code> </p> <code>interm_probe_grad</code> <p>Gradient of the probe (combined over object modes).</p> <p> TYPE: <code>ndarray</code> </p> <code>tilts_grad</code> <p>Updated tilt gradient.</p> <p> TYPE: <code>ndarray</code> </p>"},{"location":"reference/objective.html","title":"<code>pypty.objective</code>","text":""},{"location":"reference/objective.html#pypty.objective.charge_flip","title":"<code>charge_flip</code>","text":"<p>Perform charge-flipping style object regularization to enhance phase and absorption contrast.</p> PARAMETER DESCRIPTION <code>a</code> <p>Complex object to regularize.</p> <p> TYPE: <code>ndarray</code> </p> <code>delta_phase</code> <p>Phase threshold ratio.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.03</code> </p> <code>delta_abs</code> <p>Absorption threshold ratio.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.14</code> </p> <code>beta_phase</code> <p>Inversion multiplier for low-phase regions.</p> <p> TYPE: <code>float</code> DEFAULT: <code>-0.95</code> </p> <code>beta_abs</code> <p>Inversion multiplier for low-absorption regions.</p> <p> TYPE: <code>float</code> DEFAULT: <code>-0.95</code> </p> <code>fancy_sigma</code> <p>Tuple of atomic-shape gaussian kernel sigmas (for phase, absorption).</p> <p> TYPE: <code>tuple or None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>Regularized complex object.</p>"},{"location":"reference/objective.html#pypty.objective.clear_missing_wedge","title":"<code>clear_missing_wedge</code>","text":"<p>Remove missing wedge artifacts by applying a cone filter in 3D FFT space.</p> PARAMETER DESCRIPTION <code>obj</code> <p>3D complex object.</p> <p> TYPE: <code>ndarray</code> </p> <code>px_size_x_A</code> <p>Pixel size along x (\u00c5).</p> <p> TYPE: <code>float</code> </p> <code>px_size_y_A</code> <p>Pixel size along y (\u00c5).</p> <p> TYPE: <code>float</code> </p> <code>slice_distance</code> <p>Distance between slices (\u00c5).</p> <p> TYPE: <code>float</code> </p> <code>beta_wedge</code> <p>Cone sharpness parameter.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>Filtered object with reduced missing wedge effects.</p>"},{"location":"reference/objective.html#pypty.objective.compute_atv_constraint","title":"<code>compute_atv_constraint</code>","text":"<p>Apply adaptive total variation (ATV) regularization to the object.</p> PARAMETER DESCRIPTION <code>obj</code> <p>Complex object.</p> <p> TYPE: <code>ndarray</code> </p> <code>atv_weight</code> <p>Regularization weight.</p> <p> TYPE: <code>float</code> </p> <code>atv_q</code> <p>q-norm parameter.</p> <p> TYPE: <code>float</code> </p> <code>atv_p</code> <p>p-norm parameter.</p> <p> TYPE: <code>float</code> </p> <code>pixel_size_x_A</code> <p>Pixel size along x (\u00c5).</p> <p> TYPE: <code>float</code> </p> <code>pixel_size_y_A</code> <p>Pixel size along y (\u00c5).</p> <p> TYPE: <code>float</code> </p> <code>atv_grad_mask</code> <p>Optional gradient mask.</p> <p> TYPE: <code>ndarray or None</code> </p> <code>return_direction</code> <p>If True, return the gradient.</p> <p> TYPE: <code>bool</code> </p> <code>smart_memory</code> <p>If True, use memory-efficient computation.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>reg_term</code> <p>ATV regularization value.</p> <p> TYPE: <code>float</code> </p> <code>dR_dTerm</code> <p>Gradient with respect to the object.</p> <p> TYPE: <code>ndarray</code> </p>"},{"location":"reference/objective.html#pypty.objective.compute_deformation_constraint_on_grid","title":"<code>compute_deformation_constraint_on_grid</code>","text":"<p>Penalize deviations from affine transformations in local scan patches.</p> PARAMETER DESCRIPTION <code>something</code> <p>Grid to regularize (positions or tilts).</p> <p> TYPE: <code>ndarray</code> </p> <code>scan_size</code> <p>Dimensions of the scan.</p> <p> TYPE: <code>tuple</code> </p> <code>reg_weight</code> <p>Regularization weight.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>reg_term</code> <p>Regularization loss.</p> <p> TYPE: <code>float</code> </p> <code>grad</code> <p>Gradient of the loss with respect to the grid.</p> <p> TYPE: <code>ndarray</code> </p>"},{"location":"reference/objective.html#pypty.objective.compute_fast_axis_constraint_on_grid","title":"<code>compute_fast_axis_constraint_on_grid</code>","text":"<p>Apply second-order TV regularization along the fast scan axis.</p> PARAMETER DESCRIPTION <code>something</code> <p>Positions or tilts to regularize.</p> <p> TYPE: <code>ndarray</code> </p> <code>scan_size</code> <p>Size of the scan grid.</p> <p> TYPE: <code>tuple</code> </p> <code>tv_reg_weight</code> <p>Regularization weight.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>reg_term</code> <p>Value of the regularization term.</p> <p> TYPE: <code>float</code> </p> <code>grad</code> <p>Gradient of the regularization.</p> <p> TYPE: <code>ndarray</code> </p>"},{"location":"reference/objective.html#pypty.objective.compute_full_l1_constraint","title":"<code>compute_full_l1_constraint</code>","text":"<p>Apply L1 norm regularization to the object's phase and absorption.</p> PARAMETER DESCRIPTION <code>object</code> <p>Complex object array.</p> <p> TYPE: <code>ndarray</code> </p> <code>abs_norm_weight</code> <p>Weight for absorption norm.</p> <p> TYPE: <code>float</code> </p> <code>phase_norm_weight</code> <p>Weight for phase norm.</p> <p> TYPE: <code>float</code> </p> <code>grad_mask</code> <p>Mask to restrict gradient computation.</p> <p> TYPE: <code>ndarray</code> </p> <code>return_direction</code> <p>If True, return the gradient.</p> <p> TYPE: <code>bool</code> </p> <code>smart_memory</code> <p>Memory-efficient option.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>reg_term</code> <p>Regularization loss.</p> <p> TYPE: <code>float</code> </p> <code>grad</code> <p>Gradient if <code>return_direction</code> is True, else None.</p> <p> TYPE: <code>ndarray or None</code> </p>"},{"location":"reference/objective.html#pypty.objective.compute_missing_wedge_constraint","title":"<code>compute_missing_wedge_constraint</code>","text":"<p>Enforce missing wedge constraint in 3D reciprocal space.</p> PARAMETER DESCRIPTION <code>obj</code> <p>3D complex object.</p> <p> TYPE: <code>ndarray</code> </p> <code>px_size_x_A</code> <p>Pixel size along x (\u00c5).</p> <p> TYPE: <code>float</code> </p> <code>px_size_y_A</code> <p>Pixel size along y (\u00c5).</p> <p> TYPE: <code>float</code> </p> <code>slice_distance</code> <p>Slice spacing (\u00c5).</p> <p> TYPE: <code>float</code> </p> <code>beta_wedge</code> <p>Cone sharpness.</p> <p> TYPE: <code>float</code> </p> <code>wegde_mu</code> <p>Regularization weight.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>loss_term</code> <p>Regularization loss.</p> <p> TYPE: <code>float</code> </p> <code>grad_obj</code> <p>Gradient of the loss with respect to the object.</p> <p> TYPE: <code>ndarray</code> </p>"},{"location":"reference/objective.html#pypty.objective.compute_mixed_object_variance_constraint","title":"<code>compute_mixed_object_variance_constraint</code>","text":"<p>Regularize variance across object modes by penalizing their differences.</p> PARAMETER DESCRIPTION <code>this_obj</code> <p>Complex object array with multiple modes.</p> <p> TYPE: <code>ndarray</code> </p> <code>weight</code> <p>Regularization strength.</p> <p> TYPE: <code>float</code> </p> <code>sigma</code> <p>Smoothing kernel width in frequency space.</p> <p> TYPE: <code>float</code> </p> <code>return_direction</code> <p>If True, return the gradient.</p> <p> TYPE: <code>bool</code> </p> <code>smart_memory</code> <p>Use memory-efficient FFT loops.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>reg_term</code> <p>Mixed variance loss.</p> <p> TYPE: <code>float</code> </p> <code>grad</code> <p>Gradient with respect to the object if <code>return_direction</code> is True.</p> <p> TYPE: <code>ndarray or None</code> </p>"},{"location":"reference/objective.html#pypty.objective.compute_probe_constraint","title":"<code>compute_probe_constraint</code>","text":"<p>Apply reciprocal space constraint to the probe using an aperture mask. Penalize probe values outside an aperture.</p> PARAMETER DESCRIPTION <code>to_reg_probe</code> <p>Complex probe array.</p> <p> TYPE: <code>ndarray</code> </p> <code>aperture</code> <p>Binary mask or scalar defining aperture radius.</p> <p> TYPE: <code>ndarray or float</code> </p> <code>weight</code> <p>Regularization weight.</p> <p> TYPE: <code>float</code> </p> <code>return_direction</code> <p>If True, return the gradient.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>reg_term</code> <p>Loss from masked frequency components.</p> <p> TYPE: <code>float</code> </p> <code>probe_fft</code> <p>Gradient of the constraint if requested.</p> <p> TYPE: <code>ndarray or None</code> </p>"},{"location":"reference/objective.html#pypty.objective.compute_slow_axis_constraint_on_grid","title":"<code>compute_slow_axis_constraint_on_grid</code>","text":"<p>Apply second-order TV regularization along the slow scan axis.</p> PARAMETER DESCRIPTION <code>something</code> <p>Positions or tilts to regularize.</p> <p> TYPE: <code>ndarray</code> </p> <code>scan_size</code> <p>Size of the scan grid.</p> <p> TYPE: <code>tuple</code> </p> <code>tv_reg_weight</code> <p>Regularization weight.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>reg_term</code> <p>Regularization loss.</p> <p> TYPE: <code>float</code> </p> <code>grad</code> <p>Gradient with respect to the input.</p> <p> TYPE: <code>ndarray</code> </p>"},{"location":"reference/objective.html#pypty.objective.compute_window_constraint","title":"<code>compute_window_constraint</code>","text":"<p>Penalize probe values outside a predefined window region in real-space.</p> PARAMETER DESCRIPTION <code>to_reg_probe</code> <p>Complex probe array.</p> <p> TYPE: <code>ndarray</code> </p> <code>current_window</code> <p>Window mask.</p> <p> TYPE: <code>ndarray</code> </p> <code>current_window_weight</code> <p>Weight of the constraint.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>reg_term</code> <p>Window constraint loss.</p> <p> TYPE: <code>float</code> </p> <code>reg_grad</code> <p>Gradient of the loss with respect to the probe.</p> <p> TYPE: <code>ndarray</code> </p>"},{"location":"reference/objective.html#pypty.objective.loss_and_direction","title":"<code>loss_and_direction</code>","text":"<p>Compute the total loss and gradients for ptychographic reconstruction.</p> <p>This is the core function of PyPty that performs forward and backward propagation, calculates the loss between measured and simulated patterns, and computes the gradients of all active reconstruction parameters (object, probe, positions, tilts, etc.).</p> PARAMETER DESCRIPTION <code>this_obj</code> <p>Complex 4D object (current estimate)</p> <p> TYPE: <code>ndarray</code> </p> <code>full_probe</code> <p>Complex probe (y,x,modes) optionally 4D (y,x,modes, scenatios)</p> <p> TYPE: <code>ndarray</code> </p> <code>this_pos_array</code> <p>Integer beam postions in pixels [[y0,x0],.. [yn, xn]]. Note: units are pixels, not angstrom!</p> <p> TYPE: <code>ndarray</code> </p> <code>this_pos_correction</code> <p>Float sub-pixel postions for more precise beam shift. Note: units are pixels, not angstrom!</p> <p> TYPE: <code>ndarray</code> </p> <code>this_tilt_array</code> <p>Beam tilts in radians, shape should be (N_measurements, 6), where first two tilts are applied before the sample, second and third are applied inside (tilted propagator) and two last are applied after the sample</p> <p> TYPE: <code>ndarray</code> </p> <code>this_tilts_correction</code> <p>legacy paramter, actually is not really required. It is a correction that is added to the tilts array.</p> <p> TYPE: <code>ndarray</code> </p> <code>this_distances</code> <p>either just one value for a common slice spacing or list of values for each slice. If object has N slices, it should have N-1 entries.</p> <p> TYPE: <code>ndarray</code> </p> <code>measured_array</code> <p>array or h5-dataset with diffraction patterns. Should be 3D, [N_measurements, y,x]</p> <p> TYPE: <code>ndarray</code> </p> <code>algorithm_type</code> <p>string indicating the loss function (error metric)</p> <p> </p> <code>this_wavelength</code> <p>Electron wavelength in Angstrom</p> <p> TYPE: <code>float</code> </p> <code>this_step_probe</code> <p>do you refine the beam?</p> <p> TYPE: <code>float</code> </p> <code>this_step_obj</code> <p>do you refine the object?</p> <p> TYPE: <code>float</code> </p> <code>this_step_pos_correction</code> <p>do you refine the positions?</p> <p> </p> <code>this_step_tilts</code> <p>do you refine the tilts?</p> <p> TYPE: <code>float</code> </p> <code>masks</code> <p>optional, if the data is compressed, you should provide the 3D array with virtual detectors [N_detectors, y,x].</p> <p> TYPE: <code>ndarray</code> </p> <code>pixel_size_x_A</code> <p>real-space pixel size in x-direction (Angstrom).</p> <p> TYPE: <code>float</code> </p> <code>pixel_size_y_A</code> <p>real-space pixel size in y-direction (Angstrom).</p> <p> TYPE: <code>float</code> </p> <code>recon_type</code> <p>\"far_field\" or \"near_field\". Changes the exit-wave propagation regime.</p> <p> TYPE: <code>string</code> </p> <code>Cs</code> <p>Spherical aberration (Angstrom). Only needed for near-field propagation.</p> <p> TYPE: <code>float</code> </p> <code>defocus_array</code> <p>Array of exit-wave defocus values (Angstrom). Only needed for near-field propagation.</p> <p> TYPE: <code>ndarray</code> </p> <code>alpha_near_field</code> <p>Flux-preserving correction for near-field propagation.</p> <p> TYPE: <code>float</code> </p> <code>damping_cutoff_multislice</code> <p>Cutoff (fraction smaller than 1) beyond which the Fouirer-space is cleaned.</p> <p> TYPE: <code>float</code> </p> <code>smooth_rolloff</code> <p>Smooth rolloff for Fourier masking</p> <p> TYPE: <code>float</code> </p> <code>propmethod</code> <p>string indicating the method for split-step integration</p> <p> TYPE: <code>string</code> </p> <code>this_chopped_sequence</code> <p> TYPE: <code>ndarray</code> </p> <code>load_one_by_one</code> <p> TYPE: <code>bool</code> </p> <code>data_multiplier</code> <p> TYPE: <code>int</code> </p> <code>data_pad</code> <p> TYPE: <code>int</code> </p> <code>phase_plate_in_h5</code> <p> TYPE: <code>string</code> </p> <code>this_loss_weight</code> <p> TYPE: <code>float</code> </p> <code>data_bin</code> <p> TYPE: <code>int</code> </p> <code>data_shift_vector</code> <p> TYPE: <code>tuple</code> </p> <code>upsample_pattern</code> <p> TYPE: <code>int</code> </p> <code>static_background</code> <p> TYPE: <code>ndarray or float</code> </p> <code>this_step_static_background</code> <p> TYPE: <code>float</code> </p> <code>tilt_mode</code> <p> TYPE: <code>int</code> </p> <code>aberration_marker</code> <p> TYPE: <code>ndarray</code> </p> <code>probe_marker</code> <p> TYPE: <code>ndarray</code> </p> <code>aberrations_array</code> <p> TYPE: <code>ndarray</code> </p> <code>compute_batch</code> <p> TYPE: <code>int</code> </p> <code>phase_only_obj</code> <p> TYPE: <code>bool</code> </p> <code>beam_current</code> <p> TYPE: <code>ndarray</code> </p> <code>this_beam_current_step</code> <p> TYPE: <code>float</code> </p> <code>this_step_aberrations_array</code> <p> TYPE: <code>float</code> </p> <code>default_float</code> <p> TYPE: <code>dtype</code> </p> <code>default_complex</code> <p> TYPE: <code>dtype</code> </p> <code>xp</code> <p> TYPE: <code>module</code> </p> <code>is_first_epoch</code> <p> TYPE: <code>bool</code> </p> <code>scan_size</code> <p> TYPE: <code>tuple</code> </p> <code>fast_axis_reg_weight_positions</code> <p> TYPE: <code>float</code> </p> <code>slow_axis_reg_weight_positions</code> <p> TYPE: <code>float</code> </p> <code>slow_axis_reg_weight_tilts</code> <p> TYPE: <code>float</code> </p> <code>current_deformation_reg_weight_positions</code> <p> TYPE: <code>float</code> </p> <code>current_deformation_reg_weight_tilts</code> <p> TYPE: <code>float</code> </p> <code>fast_axis_reg_weight_tilts</code> <p> TYPE: <code>float</code> </p> <code>aperture_mask</code> <p> TYPE: <code>ndarray</code> </p> <code>probe_reg_weight</code> <p> TYPE: <code>float</code> </p> <code>current_window_weight</code> <p> TYPE: <code>float</code> </p> <code>current_window</code> <p> TYPE: <code>ndarray</code> </p> <code>phase_norm_weight</code> <p> TYPE: <code>float</code> </p> <code>abs_norm_weight</code> <p> TYPE: <code>float</code> </p> <code>atv_weight</code> <p> TYPE: <code>float</code> </p> <code>atv_q</code> <p> TYPE: <code>float</code> </p> <code>atv_p</code> <p> TYPE: <code>float</code> </p> <code>mixed_variance_weight</code> <p> TYPE: <code>float</code> </p> <code>mixed_variance_sigma</code> <p> TYPE: <code>float</code> </p> <code>smart_memory</code> <p> TYPE: <code>bool</code> </p> <code>print_flag</code> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>loss</code> <p>Total loss value.</p> <p> TYPE: <code>float</code> </p> <code>sse</code> <p>Sum of squared errors.</p> <p> TYPE: <code>float</code> </p> <code>object_grad</code> <p>Gradient of the loss with respect to the object.</p> <p> TYPE: <code>ndarray</code> </p> <code>probe_grad</code> <p>Gradient of the loss with respect to the probe.</p> <p> TYPE: <code>ndarray</code> </p> <code>pos_grad</code> <p>Gradient of the loss with respect to scan position corrections.</p> <p> TYPE: <code>ndarray</code> </p> <code>tilts_grad</code> <p>Gradient of the loss with respect to tilts.</p> <p> TYPE: <code>ndarray</code> </p> <code>static_background_grad</code> <p>Gradient of the loss with respect to static background.</p> <p> TYPE: <code>ndarray</code> </p> <code>aberrations_array_grad</code> <p>Gradient of the loss with respect to aberration coefficients.</p> <p> TYPE: <code>ndarray</code> </p> <code>beam_current_grad</code> <p>Gradient of the loss with respect to beam current.</p> <p> TYPE: <code>ndarray</code> </p> <code>constraint_contributions</code> <p>Individual regularization loss terms added to the total loss.</p> <p> TYPE: <code>list</code> </p>"},{"location":"reference/objective.html#pypty.objective.make_basis_orthogonal","title":"<code>make_basis_orthogonal</code>","text":"<p>Orthogonalize a set of 1D basis vectors using Gram-Schmidt.</p> PARAMETER DESCRIPTION <code>vectors</code> <p>2D array of vectors to orthogonalize.</p> <p> TYPE: <code>ndarray</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>Orthogonalized basis.</p>"},{"location":"reference/objective.html#pypty.objective.make_states_orthogonal","title":"<code>make_states_orthogonal</code>","text":"<p>Apply Gram-Schmidt orthogonalization to probe modes.</p> PARAMETER DESCRIPTION <code>probe_states</code> <p>Probe array with multiple modes.</p> <p> TYPE: <code>ndarray</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>Orthogonalized probe states.</p>"},{"location":"reference/objective.html#pypty.objective.scatteradd_abers","title":"<code>scatteradd_abers</code>","text":"<p>Adds batched aberration updates to their respective positions in the full aberration array. This wrapper is needed to support older CuPy version.</p> PARAMETER DESCRIPTION <code>full</code> <p>Full aberration gradient array.</p> <p> TYPE: <code>ndarray</code> </p> <code>indic</code> <p>Indices specifying where to add each batch.</p> <p> TYPE: <code>array_like</code> </p> <code>batches</code> <p>Batched gradients to scatter-add.</p> <p> TYPE: <code>ndarray</code> </p>"},{"location":"reference/objective.html#pypty.objective.scatteradd_probe","title":"<code>scatteradd_probe</code>","text":"<p>Adds batched probe updates to their respective positions in the full probe array. This wrapper is needed to support older CuPy version.</p> PARAMETER DESCRIPTION <code>full</code> <p>Full probe gradient array.</p> <p> TYPE: <code>ndarray</code> </p> <code>indic</code> <p>Indices specifying where to add each batch.</p> <p> TYPE: <code>array_like</code> </p> <code>batches</code> <p>Batched gradients to scatter-add.</p> <p> TYPE: <code>ndarray</code> </p>"},{"location":"reference/se.html","title":"<code>pypty.se</code>","text":""},{"location":"reference/se.html#pypty.se.compensate_pattern_drift","title":"<code>compensate_pattern_drift</code>","text":"<p>Compensate for drift in diffraction patterns via phase correlation.</p> PARAMETER DESCRIPTION <code>aperture</code> <p>The binary aperture mask used for phase correlation.</p> <p> TYPE: <code>ndarray</code> </p> <code>patterns</code> <p>The diffraction patterns to be compensated for drift.</p> <p> TYPE: <code>ndarray</code> </p> RETURNS DESCRIPTION <code>patterns</code> <p>The compensated diffraction patterns.</p> <p> TYPE: <code>ndarray</code> </p>"},{"location":"reference/se.html#pypty.se.create_binned_dataset","title":"<code>create_binned_dataset</code>","text":"<p>Downsample a dataset by spatial binning and save it to a new file.</p> PARAMETER DESCRIPTION <code>path_orig</code> <p>The file path of the original dataset.</p> <p> TYPE: <code>str</code> </p> <code>path_new</code> <p>The file path to save the binned dataset.</p> <p> TYPE: <code>str</code> </p> <code>bin</code> <p>The binning factor to downsample the dataset.</p> <p> TYPE: <code>int</code> </p>"},{"location":"reference/se.html#pypty.se.get_aperture","title":"<code>get_aperture</code>","text":"<p>Generate a binary aperture mask based on the mean diffraction pattern.</p> PARAMETER DESCRIPTION <code>params</code> <p>Dictionary containing parameters including data path, data padding, plotting option, and bright threshold.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>params</code> <p>Updated parameters dictionary containing the generated aperture mask.</p> <p> TYPE: <code>dict</code> </p>"},{"location":"reference/se.html#pypty.se.get_virtual_annular_detector","title":"<code>get_virtual_annular_detector</code>","text":"<p>Create virtual detector signals from annular masks.</p> PARAMETER DESCRIPTION <code>pypty_params</code> <p>Dictionary containing parameters including data path, scan size, plotting option, and output folder.</p> <p> TYPE: <code>dict</code> </p> <code>inner_rad</code> <p>Inner radius of the annular mask. Default is 0.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0</code> </p> <code>outer_rad</code> <p>Outer radius of the annular mask. Default is 1.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> <code>save</code> <p>Whether to save the resulting virtual detector signal as a .npy file. Default is False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>offset_x</code> <p>X-offset for the annular mask. Default is 0.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0</code> </p> <code>offset_y</code> <p>Y-offset for the annular mask. Default is 0.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>signal</code> <p>The computed virtual detector signal.</p> <p> TYPE: <code>ndarray</code> </p>"},{"location":"reference/se.html#pypty.se.getvirtualhaadf","title":"<code>getvirtualhaadf</code>","text":"<p>Compute a virtual HAADF image from a 4D-STEM dataset.</p> PARAMETER DESCRIPTION <code>pypty_params</code> <p>Dictionary containing parameters including data path, scan size, plotting option, and output folder.</p> <p> TYPE: <code>dict</code> </p> <code>save</code> <p>Whether to save the resulting HAADF image as a .npy file. Default is True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>haadf</code> <p>The computed virtual HAADF image.</p> <p> TYPE: <code>ndarray</code> </p>"},{"location":"reference/tcbf.html","title":"<code>pypty.tcbf</code>","text":""},{"location":"reference/tcbf.html#pypty.tcbf.run_tcbf_alignment","title":"<code>run_tcbf_alignment</code>","text":"<p>Align and fit the beam contrast transfer function (CTF) using 4D-STEM data.</p> <p>This function estimates beam aberrations by aligning individual pixel images using  cross-correlation and fitting a CTF model. It supports iterative fitting with various  binning levels and options for low-frequency drift compensation.</p> PARAMETER DESCRIPTION <code>params</code> <p>Dictionary containing PyPTY experimental and reconstruction settings.</p> <p> </p> <code>binning_for_fit</code> <p>List (for integers) of binning factors for each iteration of the CTF fit.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[8]</code> </p> <code>save</code> <p>Whether to save intermediate tcBF images and shift estimates.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>optimize_angle</code> <p>Whether to include probe rotation angle in the fit.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>aberrations</code> <p>Initial guess for aberrations. If None, n_aberrations_to_fit zeros will be used.</p> <p> TYPE: <code>list</code> DEFAULT: <code>None</code> </p> <code>n_aberrations_to_fit</code> <p>Number of aberrations to fit if no initial guess is provided.</p> <p> TYPE: <code>int</code> DEFAULT: <code>12</code> </p> <code>reference_type</code> <p>Reference used for cross-correlation (\"bf\" or \"zero\").</p> <p> TYPE: <code>string</code> DEFAULT: <code>'bf'</code> </p> <code>refine_box_dim</code> <p>Radius (in pixels) of the interpolation box for sub-pixel shift refinement.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <code>upsample</code> <p>Factor for refining cross-correlation to estimate sub-pixel shifts.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> <code>cross_corr_type</code> <p>Type of cross-correlation to use (\"phase\" or \"classical\").</p> <p> TYPE: <code>str</code> DEFAULT: <code>'phase'</code> </p> <code>cancel_large_shifts</code> <p>Threshold (0\u20131) to ignore large shift outliers in the fit.</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> <code>pattern_blur_width</code> <p>Radius for optional circular blur mask applied to patterns.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>scan_pad</code> <p>Number of scan pixels to pad around the dataset (auto if None).</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>aperture</code> <p>Aperture mask. If None, attempts to extract from parameters.</p> <p> TYPE: <code>ndarray</code> DEFAULT: <code>None</code> </p> <code>subscan_region</code> <p>Subregion for CTF fitting: [left, top, right, bottom].</p> <p> TYPE: <code>list</code> DEFAULT: <code>None</code> </p> <code>compensate_lowfreq_drift</code> <p>Whether to compensate for pattern drift in large FOVs.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>append_lowfreq_shifts_to_params</code> <p>Whether to store low-frequency drift corrections in <code>params</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>interpolate_scan_factor</code> <p>Factor to upsample the scan via interpolation (experimental).</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>binning_cross_corr</code> <p>Binning factor before peak detection in cross-correlation.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>phase_cross_corr_formula</code> <p>Use analytical peak refinement formula for phase correlation.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_scale_lsq</code> <p>Scaling factor for residuals in <code>least_squares</code>.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> <code>x_scale_lsq</code> <p>Scaling for initial step size in <code>least_squares</code>.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> <code>loss_lsq</code> <p>Loss function for <code>least_squares</code> optimization.</p> <p> TYPE: <code>string</code> DEFAULT: <code>'linear'</code> </p> <code>tol_ctf</code> <p>Tolerance (<code>ftol</code>) for stopping criterion in optimization.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-08</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Updated parameter dictionary with fitted aberrations, defocus, and potentially updated scan positions and rotation.</p>"},{"location":"reference/tcbf.html#pypty.tcbf.run_tcbf_compressed_alignment","title":"<code>run_tcbf_compressed_alignment</code>","text":"<p>Perform a CTF alignment using compressed 4D-STEM data and masked bright-field regions.</p> <p>This function fits the beam CTF to the shifts between the individual pixel images of the 4d-stem dataset. It's the same as run_tcbf_alignment, but for compressed data. The shift estimation is done via cross-correaltion.</p> PARAMETER DESCRIPTION <code>params</code> <p>Dictionary containing experimental and reconstruction settings.</p> <p> TYPE: <code>dict</code> </p> <code>num_iterations</code> <p>Number of fitting iterations to perform.</p> <p> TYPE: <code>int</code> </p> <code>save</code> <p>Whether to save intermediate tcBF images and shift maps. Default is True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>optimize_angle</code> <p>Whether to include probe rotation angle in the CTF fit. Default is True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>aberrations</code> <p>Initial guess for the aberration coefficients. If None, it will be inferred or zero-initialized.</p> <p> TYPE: <code>list or None</code> DEFAULT: <code>None</code> </p> <code>n_aberrations_to_fit</code> <p>Number of aberration coefficients to fit if <code>aberrations</code> is not provided. Default is 12.</p> <p> TYPE: <code>int</code> DEFAULT: <code>12</code> </p> <code>reference_type</code> <p>\"bf\" to use the tcBF image as a reference, \"zero\" to use the central pixel. Default is \"bf\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'bf'</code> </p> <code>refine_box_dim</code> <p>Size of the cropped region around the cross-correlation peak for sub-pixel refinement. Default is 10.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <code>upsample</code> <p>Upsampling factor for sub-pixel interpolation. Default is 3.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> <code>cross_corr_type</code> <p>Cross-correlation method: \"phase\" (recommended) or \"classic\". Default is \"phase\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'phase'</code> </p> <code>cancel_large_shifts</code> <p>Threshold to reject large shift outliers during fitting. Value between 0 and 1. Default is None.</p> <p> TYPE: <code>float or None</code> DEFAULT: <code>None</code> </p> <code>pattern_blur_width</code> <p>Width of blur kernel for patterns prior to analysis. Default is None.</p> <p> TYPE: <code>int or None</code> DEFAULT: <code>None</code> </p> <code>scan_pad</code> <p>Number of scan pixels to pad around the scan to prevent wrap-around. Default is auto.</p> <p> TYPE: <code>int or None</code> DEFAULT: <code>None</code> </p> <code>aperture</code> <p>Aperture mask defining pixels to analyze. If None, it will be loaded from <code>params</code>.</p> <p> TYPE: <code>ndarray or None</code> DEFAULT: <code>None</code> </p> <code>subscan_region</code> <p>Optional subregion [left, top, right, bottom] on which to perform the alignment. Default is None.</p> <p> TYPE: <code>list or None</code> DEFAULT: <code>None</code> </p> <code>compensate_lowfreq_drift</code> <p>Whether to compute and correct for slow drifting of the aperture over time. Default is False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>append_lowfreq_shifts_to_params</code> <p>If True, saves the low-frequency correction back into <code>params</code>. Default is True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>interpolate_scan_factor</code> <p>Experimental: interpolate scan grid by this factor (e.g., 2 for 2x upsampled grid). Default is 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>binning_cross_corr</code> <p>Binning factor applied to cross-correlation maps before refinement. Default is 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>phase_cross_corr_formula</code> <p>If True, uses analytical subpixel peak estimation for phase correlation. Default is False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>f_scale_lsq</code> <p>Scaling factor for least squares residuals (<code>f_scale</code>). Default is 1.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> <code>x_scale_lsq</code> <p>Initial step scaling (<code>x_scale</code>) for least squares. Default is 1.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> <code>loss_lsq</code> <p>Loss type for least squares optimizer. E.g., \"linear\", \"huber\". Default is \"linear\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'linear'</code> </p> <code>tol_ctf</code> <p>Tolerance for optimizer convergence (<code>ftol</code>). Default is 1e-8.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-08</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Updated dictionary of reconstruction parameters including fitted aberrations and scan rotation.</p>"},{"location":"reference/tcbf.html#pypty.tcbf.upsampled_tcbf","title":"<code>upsampled_tcbf</code>","text":"<p>Perform an upsampled tcBF (transmission coherent Bright Field) reconstruction.</p> <p>This function reconstructs a tcBF image on an upsampled scan grid from 4D-STEM data. It applies Fourier-based shifts to align the bright field pixel images and combines them into a final image. Prior to calling this function, it is recommended to run the tcBF alignment routine to update <code>pypty_params</code>.</p> PARAMETER DESCRIPTION <code>pypty_params</code> <p>Dictionary containing experimental parameters and reconstruction settings. This should include keys such as 'data_path', 'scan_size', 'aperture_mask', 'acc_voltage', etc.</p> <p> TYPE: <code>dict</code> </p> <code>upsample</code> <p>Upsampling factor for the scan grid. Default is 5.</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> <code>pad</code> <p>Number of additional scan positions to pad on each side to avoid wrap-around artifacts. Default is 10.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <code>compensate_lowfreq_drift</code> <p>If True, compensates for low-frequency drift of the aperture. Requires that run_tcbf_alignment has been executed to provide drift corrections. Default is False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>default_float</code> <p>Precision for floating point computations. Use 64 for higher precision or 32 for lower memory usage. Default is 64.</p> <p> TYPE: <code>(64, 32)</code> DEFAULT: <code>64</code> </p> <code>round_shifts</code> <p>If True, shifts are rounded and alignment is performed using array roll operations. If False, FFT-based subpixel shifting is used. Default is False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>xp</code> <p>Backend array module (e.g., numpy or cupy). Default is cupy.</p> <p> TYPE: <code>module</code> DEFAULT: <code>numpy</code> </p> <code>save</code> <p>Flag to save the output image. If True, the image is saved to disk. Ignored if 'save_preprocessing_files' is set in <code>pypty_params</code>. Default is 0 (False).</p> <p> TYPE: <code>bool or int</code> DEFAULT: <code>0</code> </p> <code>max_parallel_fft</code> <p>Maximum number of FFTs to perform in parallel for vectorized processing. Default is 100.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>bin_fac</code> <p>Binning factor for the data in reciprocal space. Default is 1 (no binning).</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>Real-valued tcBF image reconstructed on the upsampled grid.</p> <code>float</code> <p>Final pixel size in \u00c5ngstr\u00f6ms after upsampling.</p>"},{"location":"reference/utils.html","title":"<code>pypty.utils</code>","text":""},{"location":"reference/utils.html#pypty.utils.apply_defocus_probe","title":"<code>apply_defocus_probe</code>","text":"<p>Apply a defocus phase shift to a probe in Fourier space.</p> PARAMETER DESCRIPTION <code>probe</code> <p>The input probe wavefunction.</p> <p> TYPE: <code>ndarray</code> </p> <code>distance</code> <p>Defocus distance in meters.</p> <p> TYPE: <code>float</code> </p> <code>acc_voltage</code> <p>Acceleration voltage in kiloelectronvolts (keV).</p> <p> TYPE: <code>float</code> </p> <code>pixel_size_x_A</code> <p>Pixel size along x in angstroms.</p> <p> TYPE: <code>float</code> </p> <code>pixel_size_y_A</code> <p>Pixel size along y in angstroms.</p> <p> TYPE: <code>float</code> </p> <code>default_complex</code> <p>Complex data type for computation.</p> <p> TYPE: <code>dtype</code> </p> <code>default_float</code> <p>Float data type for computation.</p> <p> TYPE: <code>dtype</code> </p> <code>xp</code> <p>Numerical backend (NumPy or CuPy).</p> <p> TYPE: <code>module</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>The defocused probe.</p>"},{"location":"reference/utils.html#pypty.utils.apply_probe_modulation","title":"<code>apply_probe_modulation</code>","text":"<p>Apply defocus, aberrations, Hermite mode generation, and other modulations to the probe.</p> PARAMETER DESCRIPTION <code>probe</code> <p>Initial probe.</p> <p> TYPE: <code>ndarray</code> </p> <code>extra_probe_defocus</code> <p>Defocus distance to apply.</p> <p> TYPE: <code>float</code> </p> <code>acc_voltage</code> <p>Accelerating voltage in keV.</p> <p> TYPE: <code>float</code> </p> <code>pixel_size_x_A</code> <p>Pixel size in x (\u00c5).</p> <p> TYPE: <code>float</code> </p> <code>pixel_size_y_A</code> <p>Pixel size in y (\u00c5).</p> <p> TYPE: <code>float</code> </p> <code>aberrations</code> <p>List of aberration coefficients.</p> <p> TYPE: <code>list or ndarray</code> </p> <code>print_flag</code> <p>Whether to print info.</p> <p> TYPE: <code>bool</code> </p> <code>beam_ctf</code> <p>Optional beam CTF to apply.</p> <p> TYPE: <code>ndarray or None</code> </p> <code>n_hermite_probe_modes</code> <p>Number of Hermite modes in (y, x).</p> <p> TYPE: <code>tuple or None</code> </p> <code>defocus_spread_modes</code> <p>Defocus values to generate additional modes.</p> <p> TYPE: <code>list or None</code> </p> <code>probe_marker</code> <p>Probe assignment array for multi-scenario.</p> <p> TYPE: <code>ndarray or None</code> </p> <code>default_complex</code> <p>Complex type.</p> <p> TYPE: <code>dtype</code> </p> <code>default_float</code> <p>Float type.</p> <p> TYPE: <code>dtype</code> </p> <code>xp</code> <p>Numerical backend.</p> <p> TYPE: <code>module</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>Modulated probe array.</p>"},{"location":"reference/utils.html#pypty.utils.complex_grad_to_mag_grad","title":"<code>complex_grad_to_mag_grad</code>","text":"<p>Calculate a magnitude gradient from a complex gradient and separate magnitude and phase arrays.</p> PARAMETER DESCRIPTION <code>grad</code> <p>The complex gradient.</p> <p> TYPE: <code>array_like</code> </p> <code>abs</code> <p>The magnitude array.</p> <p> TYPE: <code>array_like</code> </p> <code>phase</code> <p>The phase array.</p> <p> TYPE: <code>array_like</code> </p> RETURNS DESCRIPTION <code>array_like</code> <p>The magnitude gradient.</p>"},{"location":"reference/utils.html#pypty.utils.complex_grad_to_phase_abs_grad","title":"<code>complex_grad_to_phase_abs_grad</code>","text":"<p>Compute the phase gradient and negative amplitude gradient from a complex gradient.</p> PARAMETER DESCRIPTION <code>grad</code> <p>The Wirtinger derivative (dL/dz*).</p> <p> TYPE: <code>array_like</code> </p> <code>array</code> <p>The complex array (z = exp(-a + i*phase)).</p> <p> TYPE: <code>array_like</code> </p> RETURNS DESCRIPTION <code>tuple of array_like</code> <p>A tuple containing: - Phase gradient (dL/dp). - Negative amplitude gradient (dL/da).</p>"},{"location":"reference/utils.html#pypty.utils.complex_grad_to_phase_grad","title":"<code>complex_grad_to_phase_grad</code>","text":"<p>Convert a Wirtinger derivative to the gradient with respect to the phase.</p> PARAMETER DESCRIPTION <code>grad</code> <p>The Wirtinger derivative (dL/dz*).</p> <p> TYPE: <code>array_like</code> </p> <code>array</code> <p>The complex array (z = |z| exp(i*phase)).</p> <p> TYPE: <code>array_like</code> </p> RETURNS DESCRIPTION <code>array_like</code> <p>The phase gradient (dL/dp).</p>"},{"location":"reference/utils.html#pypty.utils.construct_update_abs_proto_phase","title":"<code>construct_update_abs_proto_phase</code>","text":"<p>Compute object updates projected along phase gradients.</p> PARAMETER DESCRIPTION <code>object_grad</code> <p>The gradient of the object.</p> <p> TYPE: <code>array_like</code> </p> <code>obj</code> <p>The current object array.</p> <p> TYPE: <code>array_like</code> </p> RETURNS DESCRIPTION <code>array_like</code> <p>The computed update for the object.</p>"},{"location":"reference/utils.html#pypty.utils.convert_num_to_nmab","title":"<code>convert_num_to_nmab</code>","text":"<p>Convert a number of aberration terms to (n, m, ab) indices based on Krivanek notation.</p> PARAMETER DESCRIPTION <code>num_abs</code> <p>Number of aberration coefficients.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>tuple of lists</code> <p>Lists of n, m, and ab strings ('', 'a', or 'b') for each aberration mode.</p>"},{"location":"reference/utils.html#pypty.utils.convert_to_nxs","title":"<code>convert_to_nxs</code>","text":"<p>Convert saved PyPty reconstruction data to NeXus (.nxs) format.</p> PARAMETER DESCRIPTION <code>folder_path</code> <p>Directory containing saved reconstruction files.</p> <p> TYPE: <code>str</code> </p> <code>output_file</code> <p>Path where the NeXus file will be saved.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/utils.html#pypty.utils.convert_to_string","title":"<code>convert_to_string</code>","text":"<p>Convert parameter dictionary to string format, including lambda serialization.</p> PARAMETER DESCRIPTION <code>dicti2</code> <p>Original parameter dictionary.</p> <p> TYPE: <code>dict</code> </p> <code>strip_dataset_from_params</code> <p>Whether to exclude 'dataset' key (default is True).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Dictionary with string values.</p>"},{"location":"reference/utils.html#pypty.utils.create_probe_from_nothing","title":"<code>create_probe_from_nothing</code>","text":"<p>Generate an initial probe guess when no valid probe is provided.</p> <p>Depending on the input, this function either uses an aperture mask, computes a mean pattern from the dataset, or adjusts an existing mean pattern to generate a probe. It applies shifting, binning, padding, and scaling to produce a probe suitable for the specified reconstruction type.</p> PARAMETER DESCRIPTION <code>probe</code> <p>Input probe. If set to \"aperture\", the aperture mask is used. If None, the probe is generated based on the mean pattern.</p> <p> TYPE: <code>ndarray, str, or None</code> </p> <code>data_pad</code> <p>Padding size applied to the data.</p> <p> TYPE: <code>int</code> </p> <code>mean_pattern</code> <p>Mean pattern used to generate the probe if no probe is provided.</p> <p> TYPE: <code>ndarray or None</code> </p> <code>aperture_mask</code> <p>Aperture mask used when probe is set to \"aperture\".</p> <p> TYPE: <code>ndarray</code> </p> <code>tilt_mode</code> <p>Flag indicating if tilt mode is active.</p> <p> TYPE: <code>bool</code> </p> <code>tilts</code> <p>Tilt values.</p> <p> TYPE: <code>ndarray</code> </p> <code>dataset</code> <p>Measured dataset.</p> <p> TYPE: <code>ndarray</code> </p> <code>estimate_aperture_based_on_binary</code> <p>Factor used to threshold the dataset for aperture estimation.</p> <p> TYPE: <code>bool or float</code> </p> <code>pixel_size_x_A</code> <p>Pixel size in the x-direction in angstroms.</p> <p> TYPE: <code>float</code> </p> <code>acc_voltage</code> <p>Acceleration voltage in keV.</p> <p> TYPE: <code>float</code> </p> <code>data_multiplier</code> <p>Factor to scale the data intensity.</p> <p> TYPE: <code>float</code> </p> <code>masks</code> <p>Optional masks to apply to the mean pattern.</p> <p> TYPE: <code>ndarray or None</code> </p> <code>data_shift_vector</code> <p>Vector indicating the shift to be applied to the data.</p> <p> TYPE: <code>list or tuple of int</code> </p> <code>data_bin</code> <p>Binning factor.</p> <p> TYPE: <code>int</code> </p> <code>upsample_pattern</code> <p>Upsampling factor applied to the pattern.</p> <p> TYPE: <code>int</code> </p> <code>default_complex_cpu</code> <p>Complex data type for CPU computations.</p> <p> TYPE: <code>dtype</code> </p> <code>print_flag</code> <p>Flag controlling verbosity.</p> <p> TYPE: <code>int</code> </p> <code>algorithm</code> <p>Identifier for the reconstruction algorithm.</p> <p> TYPE: <code>str</code> </p> <code>measured_data_shape</code> <p>Shape of the measured data.</p> <p> TYPE: <code>tuple</code> </p> <code>n_obj_modes</code> <p>Number of object modes.</p> <p> TYPE: <code>int</code> </p> <code>probe_marker</code> <p>Marker array for probe scenarios.</p> <p> TYPE: <code>ndarray or None</code> </p> <code>recon_type</code> <p>Type of reconstruction (\"near_field\" or \"far_field\").</p> <p> TYPE: <code>str</code> </p> <code>defocus_array</code> <p>Array of defocus values.</p> <p> TYPE: <code>ndarray</code> </p> <code>Cs</code> <p>Spherical aberration coefficient.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>The generated probe as a complex array.</p>"},{"location":"reference/utils.html#pypty.utils.create_spatial_frequencies","title":"<code>create_spatial_frequencies</code>","text":"<p>Generate spatial frequency grids and corresponding masks for multislice simulations.</p> PARAMETER DESCRIPTION <code>px</code> <p>Pixel size in the x-direction.</p> <p> TYPE: <code>float</code> </p> <code>py</code> <p>Pixel size in the y-direction.</p> <p> TYPE: <code>float</code> </p> <code>shape</code> <p>Size of the grid.</p> <p> TYPE: <code>int</code> </p> <code>damping_cutoff_multislice</code> <p>Damping cutoff factor for multislice simulations.</p> <p> TYPE: <code>float</code> </p> <code>smooth_rolloff</code> <p>Smoothing rolloff parameter.</p> <p> TYPE: <code>float</code> </p> <code>default_float</code> <p>Data type for computations.</p> <p> TYPE: <code>data - type</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>Tuple containing: - q2: 2D array of squared spatial frequencies. - qx: 2D array of spatial frequencies in x. - qy: 2D array of spatial frequencies in y. - exclude_mask: Mask in Fourier space. - exclude_mask_ishift: Unshifted mask.</p>"},{"location":"reference/utils.html#pypty.utils.create_static_background_from_nothing","title":"<code>create_static_background_from_nothing</code>","text":"<p>Generate an initial static background if none is provided.</p> PARAMETER DESCRIPTION <code>static_background</code> <p>Initial static background value or None.</p> <p> TYPE: <code>float or ndarray</code> </p> <code>probe</code> <p>Probe wavefunction.</p> <p> TYPE: <code>ndarray</code> </p> <code>damping_cutoff_multislice</code> <p>Maximum spatial frequency used.</p> <p> TYPE: <code>float</code> </p> <code>data_pad</code> <p>Padding to be applied.</p> <p> TYPE: <code>int</code> </p> <code>upsample_pattern</code> <p>Upsampling factor used.</p> <p> TYPE: <code>int</code> </p> <code>default_float</code> <p>Data type for output.</p> <p> TYPE: <code>dtype</code> </p> <code>recon_type</code> <p>Type of reconstruction ('near_field' or 'far_field').</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>Initialized static background.</p>"},{"location":"reference/utils.html#pypty.utils.delete_dataset_from_params","title":"<code>delete_dataset_from_params</code>","text":"<p>Delete the 'dataset' key from saved parameter file.</p> PARAMETER DESCRIPTION <code>params_path</code> <p>Path to the pickled parameters file.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/utils.html#pypty.utils.downsample_something","title":"<code>downsample_something</code>","text":"<p>Downsample a 2D array.</p> PARAMETER DESCRIPTION <code>something</code> <p>The 2D array to be downsampled.</p> <p> TYPE: <code>ndarray</code> </p> <code>upsample</code> <p>Downsampling factor.</p> <p> TYPE: <code>int</code> </p> <code>xp</code> <p>Array module, e.g., numpy or cupy.</p> <p> TYPE: <code>module</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>The downsampled array.</p>"},{"location":"reference/utils.html#pypty.utils.downsample_something_3d","title":"<code>downsample_something_3d</code>","text":"<p>Downsample a 3D array along the last two axes.</p> PARAMETER DESCRIPTION <code>something</code> <p>The 3D array to be downsampled.</p> <p> TYPE: <code>ndarray</code> </p> <code>upsample</code> <p>Downsampling factor.</p> <p> TYPE: <code>int</code> </p> <code>xp</code> <p>Array module, e.g., numpy or cupy.</p> <p> TYPE: <code>module</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>The downsampled 3D array.</p>"},{"location":"reference/utils.html#pypty.utils.fourier_clean","title":"<code>fourier_clean</code>","text":"<p>Apply a Fourier filter to the input array. Supports 2D or 3D arrays.</p> PARAMETER DESCRIPTION <code>array</code> <p>Input array (2D or 3D) to be filtered.</p> <p> TYPE: <code>array_like</code> </p> <code>cutoff</code> <p>Cutoff frequency (default is 0.66).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.66</code> </p> <code>mask</code> <p>Predefined mask to apply. If None, a mask is generated.</p> <p> TYPE: <code>array_like or None</code> DEFAULT: <code>None</code> </p> <code>rolloff</code> <p>Rolloff parameter for smoothing the mask (default is 0).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0</code> </p> <code>default_float</code> <p>Data type for computations (default is cp.float32).</p> <p> TYPE: <code>data - type</code> DEFAULT: <code>float32</code> </p> <code>xp</code> <p>Array module (default is cp).</p> <p> TYPE: <code>module</code> DEFAULT: <code>numpy</code> </p> RETURNS DESCRIPTION <code>array_like</code> <p>The filtered array after applying the Fourier filter.</p>"},{"location":"reference/utils.html#pypty.utils.fourier_clean_3d","title":"<code>fourier_clean_3d</code>","text":"<p>Apply a 3D Fourier filter to the input array.</p> PARAMETER DESCRIPTION <code>array</code> <p>Input 3D array to be filtered.</p> <p> TYPE: <code>array_like</code> </p> <code>cutoff</code> <p>Cutoff frequency (default is 0.66).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.66</code> </p> <code>mask</code> <p>Predefined mask to apply. If None, a mask is generated.</p> <p> TYPE: <code>array_like or None</code> DEFAULT: <code>None</code> </p> <code>rolloff</code> <p>Rolloff parameter for smoothing the mask (default is 0).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0</code> </p> <code>default_float</code> <p>Data type for computations (default is cp.float32).</p> <p> TYPE: <code>data - type</code> DEFAULT: <code>float32</code> </p> <code>xp</code> <p>Array module (default is cp).</p> <p> TYPE: <code>module</code> DEFAULT: <code>numpy</code> </p> RETURNS DESCRIPTION <code>array_like</code> <p>The filtered array after applying the Fourier filter.</p>"},{"location":"reference/utils.html#pypty.utils.generate_hermite_modes","title":"<code>generate_hermite_modes</code>","text":"<p>Generate Hermite polynomial-based probe modes from a main mode.</p> PARAMETER DESCRIPTION <code>main_mode</code> <p>The main probe mode.</p> <p> TYPE: <code>ndarray</code> </p> <code>n_herm_x</code> <p>Max Degree of Hermite polynomials in x.</p> <p> TYPE: <code>int</code> </p> <code>n_herm_y</code> <p>Max Degree of Hermite polynomials in y.</p> <p> TYPE: <code>int</code> </p> <code>default_complex</code> <p>Complex data type to use.</p> <p> TYPE: <code>dtype</code> </p> <code>xp</code> <p>Numerical backend.</p> <p> TYPE: <code>module</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>Stack of Hermite-based probe modes.</p>"},{"location":"reference/utils.html#pypty.utils.generate_mask_for_grad_from_pos","title":"<code>generate_mask_for_grad_from_pos</code>","text":"<p>Construct a binary mask from given positions and footprint dimensions.</p> PARAMETER DESCRIPTION <code>shapex</code> <p>Width of the mask.</p> <p> TYPE: <code>int</code> </p> <code>shapey</code> <p>Height of the mask.</p> <p> TYPE: <code>int</code> </p> <code>positions_list</code> <p>List of (y, x) positions where the mask should be activated.</p> <p> TYPE: <code>list of tuple</code> </p> <code>shape_footprint_x</code> <p>Footprint width.</p> <p> TYPE: <code>int</code> </p> <code>shape_footprint_y</code> <p>Footprint height.</p> <p> TYPE: <code>int</code> </p> <code>shrink</code> <p>Shrink factor to adjust the footprint (default is 0).</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>array_like</code> <p>The constructed binary mask.</p>"},{"location":"reference/utils.html#pypty.utils.get_compute_batch","title":"<code>get_compute_batch</code>","text":"<p>Estimate the optimal compute batch size based on GPU memory usage.</p> PARAMETER DESCRIPTION <code>compute_batch</code> <p>Initial guess or default.</p> <p> TYPE: <code>int</code> </p> <code>load_one_by_one</code> <p>Whether data is streamed instead of fully loaded.</p> <p> TYPE: <code>bool</code> </p> <code>hist_size</code> <p>History size for optimizers.</p> <p> TYPE: <code>int</code> </p> <code>measured_data_shape</code> <p>Shape of the input dataset.</p> <p> TYPE: <code>tuple</code> </p> <code>memory_saturation</code> <p>Proportion of GPU memory to use.</p> <p> TYPE: <code>float</code> </p> <code>smart_memory</code> <p>User-provided memory strategy.</p> <p> TYPE: <code>callable or bool</code> </p> <code>data_pad</code> <p>Padding applied to data.</p> <p> TYPE: <code>int</code> </p> <code>obj_shape</code> <p>Shape of the object array.</p> <p> TYPE: <code>tuple</code> </p> <code>probe_shape</code> <p>Shape of the probe array.</p> <p> TYPE: <code>tuple</code> </p> <code>dtype</code> <p>Data type string ('single' or 'double').</p> <p> TYPE: <code>str</code> </p> <code>propmethod</code> <p>Propagation method name.</p> <p> TYPE: <code>str</code> </p> <code>print_flag</code> <p>Verbosity.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>Suggested batch size, load_one_by_one flag, and memory strategy.</p>"},{"location":"reference/utils.html#pypty.utils.get_ctf","title":"<code>get_ctf</code>","text":"<p>Compute the scalar contrast transfer function (CTF) from aberrations.</p> PARAMETER DESCRIPTION <code>aberrations</code> <p>List of aberration coefficients.</p> <p> TYPE: <code>list or ndarray</code> </p> <code>kx</code> <p>Spatial frequency in x-direction.</p> <p> TYPE: <code>ndarray</code> </p> <code>ky</code> <p>Spatial frequency in y-direction.</p> <p> TYPE: <code>ndarray</code> </p> <code>wavelength</code> <p>Electron wavelength.</p> <p> TYPE: <code>float</code> </p> <code>angle_offset</code> <p>Additional rotation angle in radians (default is 0).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>The computed CTF.</p>"},{"location":"reference/utils.html#pypty.utils.get_ctf_derivatives","title":"<code>get_ctf_derivatives</code>","text":"<p>Compute spatial derivatives of the CTF with respect to kx and ky.</p> PARAMETER DESCRIPTION <code>aberrations</code> <p>List of aberration coefficients.</p> <p> TYPE: <code>list or ndarray</code> </p> <code>kx</code> <p>Spatial frequency in x-direction.</p> <p> TYPE: <code>ndarray</code> </p> <code>ky</code> <p>Spatial frequency in y-direction.</p> <p> TYPE: <code>ndarray</code> </p> <code>wavelength</code> <p>Electron wavelength.</p> <p> TYPE: <code>float</code> </p> <code>angle_offset</code> <p>Additional rotation angle (default is 0).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>tuple of ndarray</code> <p>Derivatives of CTF with respect to kx and ky.</p>"},{"location":"reference/utils.html#pypty.utils.get_ctf_gradient_rotation_angle","title":"<code>get_ctf_gradient_rotation_angle</code>","text":"<p>Compute the gradient of the phase with respect to rotation angle.</p> PARAMETER DESCRIPTION <code>aberrations</code> <p>List of aberration coefficients.</p> <p> TYPE: <code>list or ndarray</code> </p> <code>kx</code> <p>Spatial frequency in x-direction.</p> <p> TYPE: <code>ndarray</code> </p> <code>ky</code> <p>Spatial frequency in y-direction.</p> <p> TYPE: <code>ndarray</code> </p> <code>wavelength</code> <p>Electron wavelength.</p> <p> TYPE: <code>float</code> </p> <code>angle_offset</code> <p>Additional angular offset (default is 0).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>tuple of ndarray</code> <p>Derivatives of the CTF gradient in x and y directions with respect to angular change.</p>"},{"location":"reference/utils.html#pypty.utils.get_ctf_matrix","title":"<code>get_ctf_matrix</code>","text":"<p>Generate a matrix of phase contributions for all aberration modes.</p> PARAMETER DESCRIPTION <code>kx</code> <p>Spatial frequency in x-direction.</p> <p> TYPE: <code>ndarray</code> </p> <code>ky</code> <p>Spatial frequency in y-direction.</p> <p> TYPE: <code>ndarray</code> </p> <code>num_abs</code> <p>Number of aberration coefficients.</p> <p> TYPE: <code>int</code> </p> <code>wavelength</code> <p>Electron wavelength.</p> <p> TYPE: <code>float</code> </p> <code>xp</code> <p>Array module (default is cupy).</p> <p> TYPE: <code>module</code> DEFAULT: <code>numpy</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>list of Zernike polynomials (num_abs, height, width) with phase contributions.</p>"},{"location":"reference/utils.html#pypty.utils.get_cupy_memory_usage","title":"<code>get_cupy_memory_usage</code>","text":"<p>Print current CuPy GPU memory usage statistics.</p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/utils.html#pypty.utils.get_steps_epoch","title":"<code>get_steps_epoch</code>","text":"<p>Evaluate step values for the current epoch.</p> PARAMETER DESCRIPTION <code>steps</code> <p>List of (multiplier, callable) or fixed values.</p> <p> TYPE: <code>list</code> </p> <code>epoch</code> <p>Current training epoch.</p> <p> TYPE: <code>int</code> </p> <code>default_float</code> <p>Float precision type.</p> <p> TYPE: <code>dtype</code> </p> RETURNS DESCRIPTION <code>list</code> <p>List of step values.</p>"},{"location":"reference/utils.html#pypty.utils.get_value_for_epoch","title":"<code>get_value_for_epoch</code>","text":"<p>Evaluate a list of values or functions at the current epoch.</p> PARAMETER DESCRIPTION <code>func_or_value</code> <p>List of fixed values or callables.</p> <p> TYPE: <code>list</code> </p> <code>epoch</code> <p>Current epoch number.</p> <p> TYPE: <code>int</code> </p> <code>default_float</code> <p>Float precision type.</p> <p> TYPE: <code>dtype</code> </p> RETURNS DESCRIPTION <code>list</code> <p>Evaluated values.</p>"},{"location":"reference/utils.html#pypty.utils.get_window","title":"<code>get_window</code>","text":"<p>Create a circular cosine-tapered window mask.</p> PARAMETER DESCRIPTION <code>shape</code> <p>Size of the square window.</p> <p> TYPE: <code>int</code> </p> <code>r0</code> <p>Inner radius where tapering begins (normalized).</p> <p> TYPE: <code>float</code> </p> <code>r_max</code> <p>Outer radius where mask falls to zero (normalized).</p> <p> TYPE: <code>float</code> </p> <code>inverted</code> <p>If True, returns 1 - mask (default is True).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>A 2D mask array of the specified shape.</p>"},{"location":"reference/utils.html#pypty.utils.lambda_to_string","title":"<code>lambda_to_string</code>","text":"<p>Extract lambda function source as a string.</p> PARAMETER DESCRIPTION <code>f</code> <p>Lambda function.</p> <p> TYPE: <code>function</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Extracted string source of the lambda.</p>"},{"location":"reference/utils.html#pypty.utils.load_nexus_params","title":"<code>load_nexus_params</code>","text":"<p>Load reconstruction parameters from a NeXus (.nxs) HDF5 file.</p> PARAMETER DESCRIPTION <code>path_nexus</code> <p>Path to the .nxs file.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Dictionary of extracted parameters.</p>"},{"location":"reference/utils.html#pypty.utils.load_params","title":"<code>load_params</code>","text":"<p>Load parameter dictionary from a .pkl file.</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to the .pkl parameter file.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Loaded parameters.</p>"},{"location":"reference/utils.html#pypty.utils.nmab_to_strings","title":"<code>nmab_to_strings</code>","text":"<p>Convert aberration indices into string identifiers in Krivanek notation.</p> PARAMETER DESCRIPTION <code>possible_n</code> <p>List of radial indices.</p> <p> TYPE: <code>list of int</code> </p> <code>possible_m</code> <p>List of azimuthal indices.</p> <p> TYPE: <code>list of int</code> </p> <code>possible_ab</code> <p>List of aberration mode types ('', 'a', 'b').</p> <p> TYPE: <code>list of str</code> </p> RETURNS DESCRIPTION <code>list of str</code> <p>List of formatted aberration identifiers like 'C30a', 'C11', etc.</p>"},{"location":"reference/utils.html#pypty.utils.padfft","title":"<code>padfft</code>","text":"<p>Pad the input array in Fourier space by padding its FFT.</p> PARAMETER DESCRIPTION <code>array</code> <p>Input array to be padded.</p> <p> TYPE: <code>ndarray</code> </p> <code>pad</code> <p>Number of pixels to pad on each side.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>The padded array in spatial domain.</p>"},{"location":"reference/utils.html#pypty.utils.padprobetodatafarfield","title":"<code>padprobetodatafarfield</code>","text":"<p>Pad or crop a probe in Fourier space to match far-field data dimensions.</p> PARAMETER DESCRIPTION <code>probe</code> <p>The probe wavefunction.</p> <p> TYPE: <code>ndarray</code> </p> <code>measured_data_shape</code> <p>Shape of the measured data.</p> <p> TYPE: <code>tuple</code> </p> <code>data_pad</code> <p>Padding applied to the data.</p> <p> TYPE: <code>int</code> </p> <code>upsample_pattern</code> <p>Upsampling factor used in the reconstruction.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>Adjusted probe wavefunction.</p>"},{"location":"reference/utils.html#pypty.utils.padprobetodatanearfield","title":"<code>padprobetodatanearfield</code>","text":"<p>Pad or crop a probe for near-field reconstruction.</p> <p>This function adjusts the probe wavefunction by padding or cropping it to match the near-field measured data dimensions after upsampling and padding.</p> PARAMETER DESCRIPTION <code>probe</code> <p>The input probe wavefunction.</p> <p> TYPE: <code>ndarray</code> </p> <code>measured_data_shape</code> <p>Shape of the measured data.</p> <p> TYPE: <code>tuple</code> </p> <code>data_pad</code> <p>Padding size applied to the data.</p> <p> TYPE: <code>int</code> </p> <code>upsample_pattern</code> <p>Upsampling factor applied to the measured data.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>The adjusted probe wavefunction.</p>"},{"location":"reference/utils.html#pypty.utils.phase_cross_corr_align","title":"<code>phase_cross_corr_align</code>","text":"<p>Align two FFT-transformed images using phase cross-correlation.</p> PARAMETER DESCRIPTION <code>im_ref_fft</code> <p>Reference image FFT.</p> <p> TYPE: <code>ndarray</code> </p> <code>im_2_fft</code> <p>FFT of the image to be aligned.</p> <p> TYPE: <code>ndarray</code> </p> <code>refine_box_dim</code> <p>Size of the interpolation box for sub-pixel alignment.</p> <p> TYPE: <code>int</code> </p> <code>upsample</code> <p>Upsampling factor for interpolation.</p> <p> TYPE: <code>int</code> </p> <code>x_real</code> <p>Real space x grid.</p> <p> TYPE: <code>ndarray</code> </p> <code>y_real</code> <p>Real space y grid.</p> <p> TYPE: <code>ndarray</code> </p> <code>shift_y</code> <p>Predefined shift in y (optional).</p> <p> TYPE: <code>float or None</code> DEFAULT: <code>None</code> </p> <code>shift_x</code> <p>Predefined shift in x (optional).</p> <p> TYPE: <code>float or None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>Shifted FFT of the second image.</p>"},{"location":"reference/utils.html#pypty.utils.prepare_main_loop_params","title":"<code>prepare_main_loop_params</code>","text":"<p>Prepare main loop parameters for reconstruction.</p> <p>This function adjusts scan positions, pads the object if necessary, handles subpixel corrections, and computes the electron wavelength based on the accelerating voltage.</p> PARAMETER DESCRIPTION <code>algorithm</code> <p>Identifier for the reconstruction algorithm.</p> <p> TYPE: <code>any</code> </p> <code>probe</code> <p>The probe array.</p> <p> TYPE: <code>ndarray</code> </p> <code>obj</code> <p>The object array.</p> <p> TYPE: <code>ndarray</code> </p> <code>positions</code> <p>Array of scan positions.</p> <p> TYPE: <code>ndarray</code> </p> <code>tilts</code> <p>Array of tilt angles.</p> <p> TYPE: <code>ndarray</code> </p> <code>measured_data_shape</code> <p>Shape of the measured data.</p> <p> TYPE: <code>tuple</code> </p> <code>acc_voltage</code> <p>Accelerating voltage in keV.</p> <p> TYPE: <code>float</code> </p> <code>allow_subPixel_shift</code> <p>If True, compute subpixel corrections (default is True).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>sequence</code> <p>Sequence of indices for positions (default is None, which uses full range).</p> <p> TYPE: <code>list or callable</code> DEFAULT: <code>None</code> </p> <code>use_full_FOV</code> <p>If True, use full field-of-view adjustments (default is False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>print_flag</code> <p>Verbosity flag (default is 0).</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>default_float_cpu</code> <p>Float data type for CPU computations (default is np.float64).</p> <p> TYPE: <code>data - type</code> DEFAULT: <code>float64</code> </p> <code>default_complex_cpu</code> <p>Complex data type for CPU computations (default is np.complex128).</p> <p> TYPE: <code>data - type</code> DEFAULT: <code>complex128</code> </p> <code>default_int_cpu</code> <p>Integer data type for CPU computations (default is np.int64).</p> <p> TYPE: <code>data - type</code> DEFAULT: <code>int64</code> </p> <code>probe_constraint_mask</code> <p>Optional mask for probe constraints.</p> <p> TYPE: <code>ndarray or None</code> DEFAULT: <code>None</code> </p> <code>aperture_mask</code> <p>Optional aperture mask.</p> <p> TYPE: <code>ndarray or None</code> DEFAULT: <code>None</code> </p> <code>extra_space_on_side_px</code> <p>Extra padding (in pixels) to add to scan positions (default is 0).</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>A tuple containing: - obj : ndarray     The padded object array. - positions : ndarray     Adjusted (rounded) scan positions. - int     A placeholder zero (reserved for future use). - sequence : list     The sequence of indices used. - wavelength : float     Computed electron wavelength in angstroms. - full_pos_correction : ndarray     Subpixel corrections for scan positions. - tilts_correction : ndarray     Array of zeros with same shape as tilts (tilt corrections). - aperture_mask : ndarray or None     The probe constraint mask or aperture mask if provided.</p>"},{"location":"reference/utils.html#pypty.utils.prepare_saving_stuff","title":"<code>prepare_saving_stuff</code>","text":"<p>Prepare folder and loss CSV for saving training logs.</p> PARAMETER DESCRIPTION <code>output_folder</code> <p>Directory for results.</p> <p> TYPE: <code>str</code> </p> <code>save_loss_log</code> <p>Whether to save loss values.</p> <p> TYPE: <code>bool</code> </p> <code>epoch_prev</code> <p>Previous epoch index.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/utils.html#pypty.utils.preprocess_dataset","title":"<code>preprocess_dataset</code>","text":"<p>Apply preprocessing steps to the dataset including shifting, binning, padding, and scaling.</p> PARAMETER DESCRIPTION <code>dataset</code> <p>The input dataset.</p> <p> TYPE: <code>ndarray</code> </p> <code>load_one_by_one</code> <p>Whether data is loaded incrementally.</p> <p> TYPE: <code>bool</code> </p> <code>algorithm_type</code> <p>Type of reconstruction algorithm.</p> <p> TYPE: <code>str</code> </p> <code>recon_type</code> <p>Type of reconstruction (e.g., near_field, far_field).</p> <p> TYPE: <code>str</code> </p> <code>data_shift_vector</code> <p>Vector indicating pixel shift in y and x.</p> <p> TYPE: <code>list of int</code> </p> <code>data_bin</code> <p>Binning factor.</p> <p> TYPE: <code>int</code> </p> <code>data_pad</code> <p>Padding size.</p> <p> TYPE: <code>int</code> </p> <code>upsample_pattern</code> <p>Upsampling factor for the pattern.</p> <p> TYPE: <code>int</code> </p> <code>data_multiplier</code> <p>Factor to scale data intensity.</p> <p> TYPE: <code>float</code> </p> <code>xp</code> <p>Array module, e.g., numpy or cupy.</p> <p> TYPE: <code>module</code> </p> <code>force_pad</code> <p>If True, apply forced padding.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>Tuple containing: - preprocessed dataset - data_shift_vector - data_bin - data_pad - data_multiplier</p>"},{"location":"reference/utils.html#pypty.utils.print_pypty_header","title":"<code>print_pypty_header</code>","text":"<p>Print formatted header announcing start of reconstruction.</p> PARAMETER DESCRIPTION <code>data_path</code> <p>Path to the dataset.</p> <p> TYPE: <code>str</code> </p> <code>output_folder</code> <p>Directory where results are saved.</p> <p> TYPE: <code>str</code> </p> <code>save_loss_log</code> <p>Whether loss logging is enabled.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/utils.html#pypty.utils.print_recon_state","title":"<code>print_recon_state</code>","text":"<p>Display current reconstruction progress including loss, optimization state, and updates.</p> PARAMETER DESCRIPTION <code>t0</code> <p>Start time of the epoch (Unix timestamp).</p> <p> TYPE: <code>float</code> </p> <code>algorithm</code> <p>Name of the loss or optimization algorithm used.</p> <p> TYPE: <code>str</code> </p> <code>epoch</code> <p>Current training epoch.</p> <p> TYPE: <code>int</code> </p> <code>current_loss</code> <p>Loss value at current epoch.</p> <p> TYPE: <code>float</code> </p> <code>current_sse</code> <p>Sum of squared errors.</p> <p> TYPE: <code>float</code> </p> <code>current_obj_step</code> <p>Whether the object is being updated.</p> <p> TYPE: <code>bool</code> </p> <code>current_probe_step</code> <p>Whether the probe is being updated.</p> <p> TYPE: <code>bool</code> </p> <code>current_probe_pos_step</code> <p>Whether the scan grid is being updated.</p> <p> TYPE: <code>bool</code> </p> <code>current_tilts_step</code> <p>Whether tilt corrections are being updated.</p> <p> TYPE: <code>bool</code> </p> <code>current_static_background_step</code> <p>Whether static background is being updated.</p> <p> TYPE: <code>bool</code> </p> <code>current_aberrations_array_step</code> <p>Whether aberration coefficients are being updated.</p> <p> TYPE: <code>bool</code> </p> <code>current_beam_current_step</code> <p>Whether beam current is being updated.</p> <p> TYPE: <code>bool</code> </p> <code>current_hist_length</code> <p>Optimizer memory length (0=GD, 1=CG, &gt;1=BFGS).</p> <p> TYPE: <code>int</code> </p> <code>print_flag</code> <p>Verbosity flag: 0 = silent, 1 = single-line print, 2 = verbose.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/utils.html#pypty.utils.save_current_checkpoint_obj_probe","title":"<code>save_current_checkpoint_obj_probe</code>","text":"<p>Save intermediate reconstruction data as checkpoints.</p> <p>This function saves the current state of the object, probe, tilt corrections, scan positions, static background, and aberrations to disk. It is intended to allow resuming reconstruction from the last checkpoint.</p> PARAMETER DESCRIPTION <code>output_folder</code> <p>Directory where checkpoint files will be saved.</p> <p> TYPE: <code>str</code> </p> <code>obj</code> <p>The current object array.</p> <p> TYPE: <code>ndarray or GPU array</code> </p> <code>probe</code> <p>The current probe array.</p> <p> TYPE: <code>ndarray or GPU array</code> </p> <code>tilts_correction</code> <p>Correction values for tilt angles.</p> <p> TYPE: <code>ndarray</code> </p> <code>full_pos_correction</code> <p>Sub-pixel correction values for scan positions.</p> <p> TYPE: <code>ndarray</code> </p> <code>positions</code> <p>Scan positions array.</p> <p> TYPE: <code>ndarray</code> </p> <code>tilts</code> <p>Tilt angles array.</p> <p> TYPE: <code>ndarray</code> </p> <code>static_background</code> <p>Static background array.</p> <p> TYPE: <code>ndarray</code> </p> <code>current_probe_step</code> <p>Flag indicating whether to save the probe.</p> <p> TYPE: <code>bool</code> </p> <code>current_obj_step</code> <p>Flag indicating whether to save the object.</p> <p> TYPE: <code>bool</code> </p> <code>current_probe_pos_step</code> <p>Flag indicating whether to save the scan positions.</p> <p> TYPE: <code>bool</code> </p> <code>current_tilts_step</code> <p>Flag indicating whether to save the tilt angles.</p> <p> TYPE: <code>bool</code> </p> <code>current_static_background_step</code> <p>Flag indicating whether to save the static background.</p> <p> TYPE: <code>bool</code> </p> <code>current_aberrations_array_step</code> <p>Flag indicating whether to save the aberrations array.</p> <p> TYPE: <code>bool</code> </p> <code>aberrations_array</code> <p>The current aberrations array.</p> <p> TYPE: <code>ndarray or GPU array</code> </p> <code>beam_current</code> <p>The current beam current array.</p> <p> TYPE: <code>ndarray or GPU array or None</code> </p> <code>bcstep</code> <p>Flag indicating whether to save the beam current.</p> <p> TYPE: <code>bool</code> </p> <code>xp</code> <p>Numerical backend (e.g., numpy or cupy).</p> <p> TYPE: <code>module</code> </p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/utils.html#pypty.utils.save_params","title":"<code>save_params</code>","text":"<p>Save parameters to a .pkl file, optionally removing the dataset.</p> PARAMETER DESCRIPTION <code>params_path</code> <p>Output path for the parameter file.</p> <p> TYPE: <code>str</code> </p> <code>params</code> <p>Parameter dictionary to save.</p> <p> TYPE: <code>dict</code> </p> <code>strip_dataset_from_params</code> <p>If True, remove the dataset entry.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/utils.html#pypty.utils.save_updated_arrays","title":"<code>save_updated_arrays</code>","text":"<p>Save current reconstruction state and log loss metrics during training.</p> <p>This function saves checkpoints for object, probe, tilts, scan positions, static background,  aberration coefficients, and beam current if specified. It also logs loss and constraint  contributions in a CSV file if logging is enabled.</p> PARAMETER DESCRIPTION <code>output_folder</code> <p>Directory where files will be saved.</p> <p> TYPE: <code>str</code> </p> <code>epoch</code> <p>Current epoch number.</p> <p> TYPE: <code>int</code> </p> <code>current_probe_step</code> <p>Whether to save the current probe.</p> <p> TYPE: <code>bool</code> </p> <code>current_probe_pos_step</code> <p>Whether to save current scan positions.</p> <p> TYPE: <code>bool</code> </p> <code>current_tilts_step</code> <p>Whether to save current tilts.</p> <p> TYPE: <code>bool</code> </p> <code>current_obj_step</code> <p>Whether to save the current object.</p> <p> TYPE: <code>bool</code> </p> <code>obj</code> <p>Object array to save.</p> <p> TYPE: <code>ndarray or ndarray</code> </p> <code>probe</code> <p>Probe array to save.</p> <p> TYPE: <code>ndarray or ndarray</code> </p> <code>tilts_correction</code> <p>Tilt correction values.</p> <p> TYPE: <code>ndarray</code> </p> <code>full_pos_correction</code> <p>Sub-pixel scan position correction.</p> <p> TYPE: <code>ndarray</code> </p> <code>positions</code> <p>Integer scan positions.</p> <p> TYPE: <code>ndarray</code> </p> <code>tilts</code> <p>Original tilt values.</p> <p> TYPE: <code>ndarray</code> </p> <code>static_background</code> <p>Static background array.</p> <p> TYPE: <code>ndarray or ndarray</code> </p> <code>current_aberrations_array_step</code> <p>Whether to save aberration array.</p> <p> TYPE: <code>bool</code> </p> <code>current_static_background_step</code> <p>Whether to save static background.</p> <p> TYPE: <code>bool</code> </p> <code>count</code> <p>Not used inside the function.</p> <p> TYPE: <code>int</code> </p> <code>current_loss</code> <p>Current loss value.</p> <p> TYPE: <code>float</code> </p> <code>current_sse</code> <p>Current sum of squared errors.</p> <p> TYPE: <code>float</code> </p> <code>aberrations</code> <p>Array of aberration coefficients.</p> <p> TYPE: <code>ndarray or ndarray</code> </p> <code>beam_current</code> <p>Array of beam current values.</p> <p> TYPE: <code>ndarray or ndarray</code> </p> <code>current_beam_current_step</code> <p>Whether to save beam current.</p> <p> TYPE: <code>bool</code> </p> <code>save_flag</code> <p>Whether to trigger checkpoint saving.</p> <p> TYPE: <code>bool</code> </p> <code>save_loss_log</code> <p>Whether to log loss. If set to 2, log full breakdown of constraints.</p> <p> TYPE: <code>bool or int</code> </p> <code>constraint_contributions</code> <p>List of constraint term contributions to the loss.</p> <p> TYPE: <code>list</code> </p> <code>actual_step</code> <p>Step size applied in the optimizer.</p> <p> TYPE: <code>float</code> </p> <code>count_linesearch</code> <p>Number of line search iterations.</p> <p> TYPE: <code>int</code> </p> <code>d_value</code> <p>Initial directional derivative.</p> <p> TYPE: <code>float</code> </p> <code>new_d_value</code> <p>New directional derivative after the step.</p> <p> TYPE: <code>float</code> </p> <code>current_update_step_bfgs</code> <p>Step size suggested by BFGS or optimizer.</p> <p> TYPE: <code>float</code> </p> <code>t0</code> <p>Start time of the epoch (used for timing).</p> <p> TYPE: <code>float</code> </p> <code>xp</code> <p>NumPy or CuPy module used for computation.</p> <p> TYPE: <code>module</code> </p> <code>warnings</code> <p>Warning string to be logged.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/utils.html#pypty.utils.shift_probe_fourier","title":"<code>shift_probe_fourier</code>","text":"<p>Shift a probe in Fourier space by applying a phase ramp.</p> PARAMETER DESCRIPTION <code>probe</code> <p>The input probe array.</p> <p> TYPE: <code>array_like</code> </p> <code>shift_px</code> <p>Shift in pixels (y, x).</p> <p> TYPE: <code>tuple of float</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>Tuple containing the shifted probe, the phase mask, the Fourier transform of the probe, and the spatial frequency grids (maskx, masky).</p>"},{"location":"reference/utils.html#pypty.utils.string_params_to_usefull_params","title":"<code>string_params_to_usefull_params</code>","text":"<p>Convert string-encoded lambdas in parameter dictionary back to callables.</p> PARAMETER DESCRIPTION <code>params</code> <p>Parameter dictionary possibly containing lambda strings.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Updated dictionary with callables.</p>"},{"location":"reference/utils.html#pypty.utils.string_to_lambda","title":"<code>string_to_lambda</code>","text":"<p>Convert stringified lambda expression to a Python function.</p> PARAMETER DESCRIPTION <code>lambda_string</code> <p>Lambda string to evaluate.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>callable or str</code> <p>The resulting function or original string if evaluation fails.</p>"},{"location":"reference/utils.html#pypty.utils.try_to_gpu","title":"<code>try_to_gpu</code>","text":"<p>Convert all key reconstruction variables to GPU arrays if using CuPy.</p> PARAMETER DESCRIPTION <code>obj</code> <p>Object array.</p> <p> TYPE: <code>ndarray</code> </p> <code>probe</code> <p>Probe array.</p> <p> TYPE: <code>ndarray</code> </p> <code>positions</code> <p>Integer scan positions.</p> <p> TYPE: <code>ndarray</code> </p> <code>full_pos_correction</code> <p>Sub-pixel scan grid correction.</p> <p> TYPE: <code>ndarray</code> </p> <code>tilts</code> <p>Tilt values.</p> <p> TYPE: <code>ndarray</code> </p> <code>tilts_correction</code> <p>Tilt corrections.</p> <p> TYPE: <code>ndarray</code> </p> <code>masks</code> <p>Optional segmentation or region masks.</p> <p> TYPE: <code>ndarray or None</code> </p> <code>defocus_array</code> <p>Array of defocus values per position.</p> <p> TYPE: <code>ndarray</code> </p> <code>slice_distances</code> <p>Slice spacing in multislice simulations.</p> <p> TYPE: <code>ndarray</code> </p> <code>aperture_mask</code> <p>Probe aperture mask.</p> <p> TYPE: <code>ndarray or None</code> </p> <code>dataset</code> <p>Measured dataset.</p> <p> TYPE: <code>ndarray</code> </p> <code>load_one_by_one</code> <p>Whether dataset is streamed from disk.</p> <p> TYPE: <code>bool</code> </p> <code>static_background</code> <p>Static background array.</p> <p> TYPE: <code>ndarray or None</code> </p> <code>aberrations_array</code> <p>Array of aberration coefficients.</p> <p> TYPE: <code>ndarray or None</code> </p> <code>beam_current</code> <p>Beam current scaling factor.</p> <p> TYPE: <code>ndarray or None</code> </p> <code>default_float</code> <p>Float precision dtype for casting.</p> <p> TYPE: <code>dtype</code> </p> <code>default_complex</code> <p>Complex precision dtype for casting.</p> <p> TYPE: <code>dtype</code> </p> <code>default_int</code> <p>Integer dtype for casting.</p> <p> TYPE: <code>dtype</code> </p> <code>xp</code> <p>Numerical backend (<code>numpy</code> or <code>cupy</code>).</p> <p> TYPE: <code>module</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>The same variables in GPU format (if using CuPy), with proper types.</p>"},{"location":"reference/utils.html#pypty.utils.try_to_initialize_beam_current","title":"<code>try_to_initialize_beam_current</code>","text":"<p>Initialize beam current array or pad if it's too short.</p> PARAMETER DESCRIPTION <code>beam_current</code> <p>Existing beam current values.</p> <p> TYPE: <code>ndarray or None</code> </p> <code>measured_data_shape</code> <p>Shape of measured dataset.</p> <p> TYPE: <code>tuple</code> </p> <code>default_float</code> <p>Float type for the array.</p> <p> TYPE: <code>dtype</code> </p> <code>xp</code> <p>NumPy or CuPy.</p> <p> TYPE: <code>module</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>Initialized or padded beam current.</p>"},{"location":"reference/utils.html#pypty.utils.upsample_something","title":"<code>upsample_something</code>","text":"<p>Upsample a 2D array.</p> PARAMETER DESCRIPTION <code>something</code> <p>The 2D array to be upsampled.</p> <p> TYPE: <code>ndarray</code> </p> <code>upsample</code> <p>Upsampling factor.</p> <p> TYPE: <code>int</code> </p> <code>scale</code> <p>If True, scales the result to conserve total sum (default is True).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>xp</code> <p>Array module (default is numpy).</p> <p> TYPE: <code>module</code> DEFAULT: <code>numpy</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>The upsampled array.</p>"},{"location":"reference/utils.html#pypty.utils.upsample_something_3d","title":"<code>upsample_something_3d</code>","text":"<p>Upsample a 3D array along the last two axes.</p> PARAMETER DESCRIPTION <code>something</code> <p>The 3D array to be upsampled.</p> <p> TYPE: <code>ndarray</code> </p> <code>upsample</code> <p>Upsampling factor.</p> <p> TYPE: <code>int</code> </p> <code>scale</code> <p>If True, scales the upsampled result to conserve total sum (default is True).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>xp</code> <p>Array module, e.g., numpy or cupy (default is numpy).</p> <p> TYPE: <code>module</code> DEFAULT: <code>numpy</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>The upsampled 3D array.</p>"},{"location":"reference/utils.html#pypty.utils.wolfe_1","title":"<code>wolfe_1</code>","text":"<p>Check the Armijo condition (Wolfe condition 1) for line search.</p> PARAMETER DESCRIPTION <code>value</code> <p>The current function value.</p> <p> TYPE: <code>float</code> </p> <code>new_value</code> <p>The function value after the step.</p> <p> TYPE: <code>float</code> </p> <code>d_value</code> <p>The directional derivative at the current point.</p> <p> TYPE: <code>float</code> </p> <code>step</code> <p>Step size.</p> <p> TYPE: <code>float</code> </p> <code>wolfe_c1</code> <p>Armijo condition constant (default is 0.5).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.5</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the condition is satisfied, False otherwise.</p>"},{"location":"reference/utils.html#pypty.utils.wolfe_2","title":"<code>wolfe_2</code>","text":"<p>Check the curvature condition (Wolfe condition 2) for line search.</p> PARAMETER DESCRIPTION <code>d_value</code> <p>The directional derivative at the current point.</p> <p> TYPE: <code>float</code> </p> <code>new_d_value</code> <p>The directional derivative after the step.</p> <p> TYPE: <code>float</code> </p> <code>wolfe_c2</code> <p>Curvature condition constant (default is 0.9).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.9</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the condition is satisfied, False otherwise.</p>"},{"location":"reference/vaa.html","title":"<code>pypty.vaa</code>","text":""},{"location":"reference/vaa.html#pypty.vaa.add_scalebar_ax","title":"<code>add_scalebar_ax</code>","text":"<p>Add a scale bar to a given axis.</p> PARAMETER DESCRIPTION <code>ax</code> <p>The axes to which the scale bar will be added.</p> <p> TYPE: <code>Axes</code> </p> <code>x</code> <p>The x-coordinate of the bottom left corner of the scale bar.</p> <p> TYPE: <code>float</code> </p> <code>y</code> <p>The y-coordinate of the bottom left corner of the scale bar.</p> <p> TYPE: <code>float</code> </p> <code>width</code> <p>The width of the scale bar in pixels.</p> <p> TYPE: <code>float</code> </p> <code>height</code> <p>The height of the scale bar in pixels.</p> <p> TYPE: <code>float</code> </p> <code>x_t</code> <p>The x-coordinate for the text label.</p> <p> TYPE: <code>float</code> </p> <code>y_t</code> <p>The y-coordinate for the text label.</p> <p> TYPE: <code>float</code> </p> <code>px_size</code> <p>The pixel size in the same units as the width and height.</p> <p> TYPE: <code>float</code> </p> <code>unit</code> <p>The unit of measurement for the scale bar.</p> <p> TYPE: <code>str</code> </p>"},{"location":"reference/vaa.html#pypty.vaa.complex_array_to_rgb","title":"<code>complex_array_to_rgb</code>","text":"<p>Convert a complex array to RGB format.</p> PARAMETER DESCRIPTION <code>X</code> <p>The input array of complex numbers.</p> <p> TYPE: <code>ndarray</code> </p> <code>theme</code> <p>The color theme, either 'dark' or 'light' (default is 'dark').</p> <p> TYPE: <code>str</code> DEFAULT: <code>'dark'</code> </p> <code>rmax</code> <p>Maximum absolute value for normalization (default is None).</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>The RGB representation of the input array.</p>"},{"location":"reference/vaa.html#pypty.vaa.complex_pca","title":"<code>complex_pca</code>","text":"<p>Perform PCA on complex data.</p> PARAMETER DESCRIPTION <code>data</code> <p>The input data array of shape (N_y, N_x, N_obs).</p> <p> TYPE: <code>ndarray</code> </p> <code>n_components</code> <p>The number of principal components to retain.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>The reduced data array of shape (N_y, N_x, n_components).</p>"},{"location":"reference/vaa.html#pypty.vaa.fit_aberrations_to_wave","title":"<code>fit_aberrations_to_wave</code>","text":"<p>Calculate model positions based on step size and angle.</p> PARAMETER DESCRIPTION <code>wave</code> <p>complex real-space wave</p> <p> TYPE: <code>ndarray</code> </p> <code>px_size_A</code> <p> </p> <code>acc_voltage</code> <p> </p> <code>thresh</code> <p> DEFAULT: <code>0</code> </p> <code>aberrations_guess</code> <p> DEFAULT: <code>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</code> </p> <code>plot</code> <p> DEFAULT: <code>True</code> </p> <code>ftol</code> <p> DEFAULT: <code>1e-20</code> </p> <code>xtol</code> <p> DEFAULT: <code>1e-20</code> </p> <code>loss</code> <p> DEFAULT: <code>'linear'</code> </p> <code>max_mrad</code> <p> DEFAULT: <code>inf</code> </p> RETURNS DESCRIPTION <code>list</code> <p>list of fitted aberrations (in Angstrom)</p>"},{"location":"reference/vaa.html#pypty.vaa.get_affine_tranform","title":"<code>get_affine_tranform</code>","text":"<p>Calculate the affine transformation matrix from positions.</p> PARAMETER DESCRIPTION <code>positions</code> <p>The measured positions.</p> <p> TYPE: <code>ndarray</code> </p> <code>scan_size</code> <p>The size of the scan grid.</p> <p> TYPE: <code>tuple</code> </p> <code>px_size_A</code> <p>Pixel size in angstroms.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>The deformation matrix.</p>"},{"location":"reference/vaa.html#pypty.vaa.get_step_angle_scan_grid","title":"<code>get_step_angle_scan_grid</code>","text":"<p>Determine the step size and angle for a scan grid.</p> PARAMETER DESCRIPTION <code>positions</code> <p>The measured positions.</p> <p> TYPE: <code>ndarray</code> </p> <code>scan_size</code> <p>The size of the scan grid.</p> <p> TYPE: <code>tuple</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>The step size and angle in degrees.</p>"},{"location":"reference/vaa.html#pypty.vaa.mesh_model_positions","title":"<code>mesh_model_positions</code>","text":"<p>Calculate model positions based on step size and angle.</p> PARAMETER DESCRIPTION <code>step_size</code> <p>The step size for the model.</p> <p> TYPE: <code>float</code> </p> <code>angle_rad</code> <p>The angle in radians.</p> <p> TYPE: <code>float</code> </p> <code>x</code> <p>The x coordinates.</p> <p> TYPE: <code>ndarray</code> </p> <code>y</code> <p>The y coordinates.</p> <p> TYPE: <code>ndarray</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>The model x and y coordinates.</p>"},{"location":"reference/vaa.html#pypty.vaa.mesh_objective_positions","title":"<code>mesh_objective_positions</code>","text":"<p>Objective function for mesh optimization.</p> PARAMETER DESCRIPTION <code>ini_guess</code> <p>Initial guess for the optimization.</p> <p> TYPE: <code>list</code> </p> <code>x</code> <p>The x coordinates.</p> <p> TYPE: <code>ndarray</code> </p> <code>y</code> <p>The y coordinates.</p> <p> TYPE: <code>ndarray</code> </p> <code>mesh_x</code> <p>The mesh x coordinates.</p> <p> TYPE: <code>ndarray</code> </p> <code>mesh_y</code> <p>The mesh y coordinates.</p> <p> TYPE: <code>ndarray</code> </p> RETURNS DESCRIPTION <code>float</code> <p>The sum of squared differences.</p>"},{"location":"reference/vaa.html#pypty.vaa.outputlog_plots","title":"<code>outputlog_plots</code>","text":"<p>Plot log file data from PyPty.</p> PARAMETER DESCRIPTION <code>loss_path</code> <p>Path to the PyPty CSV file.</p> <p> TYPE: <code>str</code> </p> <code>skip_first</code> <p>Number of initial iterations to skip (default is 0).</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>plot_time</code> <p>If True, a second x-axis showing time in seconds will be added on top of the plot.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>list</code> <p>List of plotted figures.</p>"},{"location":"reference/vaa.html#pypty.vaa.plot_complex_modes","title":"<code>plot_complex_modes</code>","text":"<p>Plot complex modes in RGB format.</p> PARAMETER DESCRIPTION <code>p</code> <p>The input array of complex modes.</p> <p> TYPE: <code>ndarray</code> </p> <code>nm</code> <p>The number of modes to plot.</p> <p> TYPE: <code>int</code> </p> <code>sub</code> <p>The number of rows for the subplot layout.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Figure</code> <p>The figure containing the plotted complex modes.</p>"},{"location":"reference/vaa.html#pypty.vaa.plot_modes","title":"<code>plot_modes</code>","text":"<p>Plot the modes of a tensor.</p> PARAMETER DESCRIPTION <code>ttt</code> <p>A 3D or 4D array containing the modes to be plotted.</p> <p> TYPE: <code>ndarray</code> </p>"},{"location":"reference/vaa.html#pypty.vaa.radial_average","title":"<code>radial_average</code>","text":"<p>Calculate the radial average of a 2D array.</p> PARAMETER DESCRIPTION <code>ff</code> <p>The input 2D array.</p> <p> TYPE: <code>ndarray</code> </p> <code>r_bins</code> <p>The bin size for the radial average.</p> <p> TYPE: <code>float</code> </p> <code>r_max</code> <p>The maximum radius for averaging.</p> <p> TYPE: <code>float</code> </p> <code>r_min</code> <p>The minimum radius for averaging.</p> <p> TYPE: <code>float</code> </p> <code>px_size_A</code> <p>Pixel size in angstroms.</p> <p> TYPE: <code>float</code> </p> <code>plot</code> <p>If True, the radial average will be plotted (default is True).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Figure</code> <p>The figure containing the plot if <code>plot</code> is True.</p>"}]}